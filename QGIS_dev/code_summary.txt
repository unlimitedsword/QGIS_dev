正在处理文件: AnalysisToolboxWidget.cpp
(AnalysisToolboxWidget.cpp)
// AnalysisToolboxWidget.cpp
#include "AnalysisToolboxWidget.h"
#include "ResampleDialog.h"
#include "ReprojectRasterDialog.h"
#include "RasterClipDialog.h"
#include "BufferDialog.h"
#include "SpatialJoinDialog.h"
#include "ZonalStatisticsDialog.h"

#include <QVBoxLayout>
#include <QTreeView>
#include <QStandardItemModel>
#include <QDebug>

// --- 引入未来会创建的工具对话框的头文件 (占位符) ---
// #include "SpatialJoinDialog.h"
// #include "BufferDialog.h"
// ... 等等

AnalysisToolboxWidget::AnalysisToolboxWidget(QWidget* parent)
    : QWidget(parent)
{
    setupUI();
}

AnalysisToolboxWidget::~AnalysisToolboxWidget()
{
}

void AnalysisToolboxWidget::setupUI()
{
    QVBoxLayout* mainLayout = new QVBoxLayout(this);

    m_toolTreeView = new QTreeView(this);
    m_toolModel = new QStandardItemModel(this);
    m_toolModel->setHorizontalHeaderLabels({ "分析工具" }); // 设置表头
    m_toolTreeView->setModel(m_toolModel);
    m_toolTreeView->setHeaderHidden(false); // 显示表头，让它看起来更像一个工具箱
    m_toolTreeView->setEditTriggers(QAbstractItemView::NoEditTriggers); // 禁止编辑

    populateToolTree(); // 填充工具

    connect(m_toolTreeView, &QTreeView::doubleClicked, this, &AnalysisToolboxWidget::onItemDoubleClicked);

    mainLayout->addWidget(m_toolTreeView);
    setLayout(mainLayout);
}

void AnalysisToolboxWidget::populateToolTree()
{
    // --- 1. 空间分析 ---
    QStandardItem* spatialAnalysisGroup = new QStandardItem("空间分析");
    spatialAnalysisGroup->setEditable(false); // 组节点不可编辑
    // spatialAnalysisGroup->setIcon(QIcon(":/icons/group.png")); // 可选：设置图标
    m_toolModel->appendRow(spatialAnalysisGroup);

    QStandardItem* spatialJoinItem = new QStandardItem("空间连接 (点落入面)");
    spatialJoinItem->setData(static_cast<int>(AnalysisToolId::SpatialJoin), ToolIdRole);
    spatialJoinItem->setEditable(false);
    // spatialJoinItem->setIcon(QIcon(":/icons/spatial_join.png"));
    spatialAnalysisGroup->appendRow(spatialJoinItem);

    QStandardItem* bufferItem = new QStandardItem("缓冲区分析");
    bufferItem->setData(static_cast<int>(AnalysisToolId::Buffer), ToolIdRole);
    bufferItem->setEditable(false);
    spatialAnalysisGroup->appendRow(bufferItem);


    // --- 2. 栅格数据处理 ---
    QStandardItem* rasterGroup = new QStandardItem("栅格数据处理");
    rasterGroup->setEditable(false);
    m_toolModel->appendRow(rasterGroup);

    //QStandardItem* rasterStatsItem = new QStandardItem("波段统计");
    //rasterStatsItem->setData(static_cast<int>(AnalysisToolId::RasterStats), ToolIdRole);
    //rasterStatsItem->setEditable(false);
    //rasterGroup->appendRow(rasterStatsItem);

    QStandardItem* rasterClipItem = new QStandardItem("地图裁剪");
    rasterClipItem->setData(static_cast<int>(AnalysisToolId::RasterClip), ToolIdRole);
    rasterClipItem->setEditable(false);
    rasterGroup->appendRow(rasterClipItem);

    QStandardItem* rasterResampleItem = new QStandardItem("重采样");
    rasterResampleItem->setData(static_cast<int>(AnalysisToolId::RasterResample), ToolIdRole);
    rasterResampleItem->setEditable(false);
    rasterGroup->appendRow(rasterResampleItem);

    QStandardItem* rasterReprojectItem = new QStandardItem("投影转换");
    rasterReprojectItem->setData(static_cast<int>(AnalysisToolId::RasterReproject), ToolIdRole);
    rasterReprojectItem->setEditable(false);
    rasterGroup->appendRow(rasterReprojectItem);


    // --- 3. 分区统计 ---
    QStandardItem* zonalStatsGroup = new QStandardItem("分区统计");
    zonalStatsGroup->setEditable(false);
    m_toolModel->appendRow(zonalStatsGroup);

    QStandardItem* zonalStatsItem = new QStandardItem("栅格分区统计");
    zonalStatsItem->setData(static_cast<int>(AnalysisToolId::ZonalStats), ToolIdRole);
    zonalStatsItem->setEditable(false);
    zonalStatsGroup->appendRow(zonalStatsItem);

    // 自动展开所有顶级项
    for (int i = 0; i < m_toolModel->rowCount(); ++i) {
        m_toolTreeView->expand(m_toolModel->index(i, 0));
    }
}

void AnalysisToolboxWidget::onItemDoubleClicked(const QModelIndex& index)
{
    // 检查是否是叶子节点（即具体的工具项，而不是分组项）
    QStandardItem* item = m_toolModel->itemFromIndex(index);
    if (!item || item->hasChildren()) { // 如果是分组项，则不处理
        return;
    }

    AnalysisToolId toolId = static_cast<AnalysisToolId>(item->data(ToolIdRole).toInt());

    qDebug() << "Tool double clicked:" << item->text() << "with ID:" << static_cast<int>(toolId);

    // 根据工具ID，创建并显示对应的对话框
    // 这里是未来实现的核心，现在只是占位符
    switch (toolId)
    {
    case AnalysisToolId::SpatialJoin:
    {
        SpatialJoinDialog* sjDialog = new SpatialJoinDialog(this);
        sjDialog->setAttribute(Qt::WA_DeleteOnClose);
        sjDialog->show();
        qDebug() << "SpatialJoinDialog opened.";
    }
    break;
    case AnalysisToolId::Buffer:
    {
        BufferDialog* bufferDialog = new BufferDialog(this);
        bufferDialog->setAttribute(Qt::WA_DeleteOnClose);
        bufferDialog->show();
        qDebug() << "BufferDialog opened.";
    }
    break;

    case AnalysisToolId::RasterClip: // 假设这是您为裁剪定义的ID
    {
        RasterClipDialog* clipDialog = new RasterClipDialog(this);
        clipDialog->setAttribute(Qt::WA_DeleteOnClose);
        clipDialog->show();
        qDebug() << "RasterClipDialog opened.";
    }
    break;
    case AnalysisToolId::RasterResample: // 重采样定义的ID
    {
        ResampleDialog* resampleDialog = new ResampleDialog(this);
        resampleDialog->setAttribute(Qt::WA_DeleteOnClose);
        resampleDialog->show();
        qDebug() << "ResampleDialog opened.";
    }
    break;
    case AnalysisToolId::RasterReproject: // 假设这是您为投影转换定义的ID
    {
        ReprojectRasterDialog* reprojectDialog = new ReprojectRasterDialog(this);
        reprojectDialog->setAttribute(Qt::WA_DeleteOnClose);
        reprojectDialog->show();
        qDebug() << "ReprojectRasterDialog opened.";
    }
    break;
    case AnalysisToolId::ZonalStats:
    {
        ZonalStatisticsDialog* zonalDialog = new ZonalStatisticsDialog(this);
        zonalDialog->setAttribute(Qt::WA_DeleteOnClose);
        zonalDialog->show();
        qDebug() << "ZonalStatisticsDialog opened.";
    }
    break;
    default:
        qWarning() << "Unknown tool ID:" << static_cast<int>(toolId);
        break;
    }
}
正在处理文件: AttributeTableDialog.cpp
(AttributeTableDialog.cpp)
#include "attributetabledialog.h"
#include "Output_Manager.h"

#include <qgsvectorlayer.h>
#include <qgsvectorlayercache.h>
#include <qgsattributetablemodel.h>
#include <qgsattributetablefiltermodel.h>
#include <qgsmapcanvas.h>
#include <qgsexpression.h>
#include <qgsexpressioncontext.h>
#include <qgsexpressioncontextutils.h> // 包含这个头文件以获取全局上下文
#include <QVariant>
#include <QLabel>
#include <QTableView>
#include <QVBoxLayout>
#include <QHBoxLayout>
#include <QGroupBox>
#include <QComboBox>
#include <QRadioButton>
#include <QPushButton>
#include <QLineEdit>
#include <QHeaderView>
#include <QButtonGroup>
#include <QDebug>
#include <QMessageBox>
#include <QItemSelectionModel>

// ... 构造函数和析构函数保持不变 ...
AttributeTableDialog::AttributeTableDialog(QgsVectorLayer* layer, QgsMapCanvas* canvas, QWidget* parent)
    : QDialog(parent), m_layer(layer), m_canvas(canvas), m_currentSortOrder(Qt::AscendingOrder), m_deleteWarningShown(false)
{
    // ...
    setWindowTitle(QString("属性表 - %1").arg(m_layer->name()));
    resize(1100, 700); // 增大默认尺寸以容纳新控件
    setupUI();
}
AttributeTableDialog::~AttributeTableDialog() {}


void AttributeTableDialog::setupUI()
{
    // --- 主控制面板布局 ---
    QHBoxLayout* controlLayout = new QHBoxLayout();

    // --- 1. 字段选择 (始终显示，最左侧) ---
    controlLayout->addWidget(new QLabel("选择字段:", this));
    m_fieldComboBox = new QComboBox(this);
    controlLayout->addWidget(m_fieldComboBox);

    // --- 2. 操作模式选择 (始终显示，字段选择右侧) ---
    QGroupBox* modeGroupBox = new QGroupBox("操作模式", this);
    QHBoxLayout* modeLayout = new QHBoxLayout();
    m_sortRadioButton = new QRadioButton("排序", this);
    m_searchRadioButton = new QRadioButton("搜索", this);
    QButtonGroup* modeGroup = new QButtonGroup(this);
    modeGroup->addButton(m_sortRadioButton);
    modeGroup->addButton(m_searchRadioButton);
    modeLayout->addWidget(m_sortRadioButton);
    modeLayout->addWidget(m_searchRadioButton);
    modeGroupBox->setLayout(modeLayout);
    controlLayout->addWidget(modeGroupBox);

    // --- 3. 动态控件区域 (排序或搜索，会根据模式变化) ---
    // 我们创建一个 QHBoxLayout 来容纳这部分，这样可以控制它们的相对顺序
    QHBoxLayout* dynamicControlsLayout = new QHBoxLayout();

    // a. 排序控件 (默认添加到 dynamicControlsLayout)
    m_sortOrderButton = new QPushButton("升序", this);
    dynamicControlsLayout->addWidget(m_sortOrderButton);

    // b. 搜索控件 (默认添加到 dynamicControlsLayout)
    m_searchLineEdit = new QLineEdit(this);
    m_searchLineEdit->setPlaceholderText("输入搜索关键字...");
    m_searchButton = new QPushButton("搜索", this);
    dynamicControlsLayout->addWidget(m_searchLineEdit);
    dynamicControlsLayout->addWidget(m_searchButton);

    // 将这个动态控件布局添加到主控制布局
    controlLayout->addLayout(dynamicControlsLayout);

    // --- 4. 右侧固定操作按钮 (在所有动态控件之后，用伸缩项隔开) ---
    controlLayout->addStretch(); // 添加一个伸缩项，将后续按钮推到最右边

    // a. 反向选择按钮
    m_invertSelectionButton = new QPushButton("反向选择", this);
    m_invertSelectionButton->setIcon(QIcon(":/QGIS_dev/resource/images/反选.png"));
    m_invertSelectionButton->setToolTip("选中所有当前未选中的行，并取消选中当前已选中的行");
    controlLayout->addWidget(m_invertSelectionButton);

    // b. 删除按钮 (最右侧)
    m_deleteButton = new QPushButton("删除选中", this);
    m_deleteButton->setIcon(QIcon(":/QGIS_dev/resource/images/删除.png"));
    m_deleteButton->setToolTip("删除表格中所有选中的行");
    QgsVectorDataProvider* provider = m_layer->dataProvider();
    if (!provider || !(provider->capabilities())) {
        m_deleteButton->setEnabled(false);
        m_deleteButton->setToolTip("该图层的数据源不支持删除操作。");
    }
    controlLayout->addWidget(m_deleteButton);


    // --- 2. 创建并设置 Table View ---
    m_tableView = new QTableView(this); // **先创建**
    m_tableView->setSortingEnabled(false);
    m_tableView->setSelectionMode(QAbstractItemView::ExtendedSelection); // **后设置**
    m_tableView->setSelectionBehavior(QAbstractItemView::SelectRows);


    // --- 3. 创建并设置数据模型 ---
    QgsVectorLayerCache* layerCache = new QgsVectorLayerCache(m_layer, 1000, this);
    m_tableModel = new QgsAttributeTableModel(layerCache, this);
    m_filterModel = new QgsAttributeTableFilterModel(m_canvas, m_tableModel, this);
    m_tableView->setModel(m_filterModel);
    m_tableModel->loadLayer();

    // 在模型加载数据后，立即尝试同步图层中已有的选择到表格中
    synchronizeTableSelectionWithLayer();

    // --- 4. 组装主布局 ---
    QVBoxLayout* mainLayout = new QVBoxLayout(this);
    mainLayout->addLayout(controlLayout);
    mainLayout->addWidget(m_tableView);
    setLayout(mainLayout);


    // --- 5. 连接信号和槽 ---
    connect(m_fieldComboBox, QOverload<int>::of(&QComboBox::currentIndexChanged), this, &AttributeTableDialog::onFieldSelectionChanged);
    connect(m_sortOrderButton, &QPushButton::clicked, this, &AttributeTableDialog::onSortOrderToggle);
    connect(m_searchButton, &QPushButton::clicked, this, &AttributeTableDialog::onSearchButtonClicked);
    connect(m_sortRadioButton, &QRadioButton::toggled, this, &AttributeTableDialog::onFilterModeChanged);
    connect(m_deleteButton, &QPushButton::clicked, this, &AttributeTableDialog::onDeleteSelectedFeatures);
    connect(m_layer, &QgsVectorLayer::selectionChanged, this, &AttributeTableDialog::synchronizeTableSelectionWithLayer);
    connect(m_invertSelectionButton, &QPushButton::clicked, this, &AttributeTableDialog::onInvertSelection); // +++ 连接新信号槽 +++

    // --- 6. 设置初始状态 ---
    populateFieldsComboBox();
    m_sortRadioButton->setChecked(true);
    updateControlsState();
}

// +++ 实现新增的槽函数和辅助函数 +++

void AttributeTableDialog::populateFieldsComboBox()
{
    m_fieldComboBox->blockSignals(true); // 避免在填充时触发信号
    m_fieldComboBox->clear();
    m_fieldComboBox->addItem("--- (不选择字段) ---", -1); // 添加一个默认/空选项

    const QgsFields fields = m_layer->fields();
    for (int i = 0; i < fields.count(); ++i) {
        m_fieldComboBox->addItem(fields.field(i).name(), i); // 显示字段名，存储字段索引
    }
    m_fieldComboBox->blockSignals(false);
}

void AttributeTableDialog::updateControlsState()
{
    bool fieldSelected = (m_fieldComboBox->currentIndex() > 0);

    m_sortRadioButton->setEnabled(fieldSelected);
    m_searchRadioButton->setEnabled(fieldSelected);

    if (!fieldSelected) {
        m_sortRadioButton->setChecked(false);
        m_searchRadioButton->setChecked(false);
    }

    bool sortMode = m_sortRadioButton->isChecked();
    bool searchMode = m_searchRadioButton->isChecked();

    m_sortOrderButton->setVisible(sortMode && fieldSelected);
    m_searchLineEdit->setVisible(searchMode && fieldSelected);
    m_searchButton->setVisible(searchMode && fieldSelected);
}

// 当用户在下拉框中选择一个新字段时
void AttributeTableDialog::onFieldSelectionChanged(int index)
{
    // 清除排序
    m_filterModel->sort(-1, Qt::AscendingOrder);

    // 清除过滤，并强制刷新视图
    m_filterModel->setFilterMode(QgsAttributeTableFilterModel::ShowAll);
    m_filterModel->setFilterExpression(QgsExpression(), QgsExpressionContext());
    m_filterModel->invalidate(); // ++ 正确的刷新方式 ++

    if (index > 0) {
        m_sortRadioButton->setChecked(true);
    }
    updateControlsState();
}


// 当用户点击“升序/降序”按钮时
void AttributeTableDialog::onSortOrderToggle()
{
    if (m_currentSortOrder == Qt::AscendingOrder) {
        m_currentSortOrder = Qt::DescendingOrder;
        m_sortOrderButton->setText("降序");
    }
    else {
        m_currentSortOrder = Qt::AscendingOrder;
        m_sortOrderButton->setText("升序");
    }

    int fieldIndex = m_fieldComboBox->currentData().toInt();
    if (fieldIndex >= 0) {
        // 排序前，确保是对所有行进行操作
        m_filterModel->setFilterMode(QgsAttributeTableFilterModel::ShowAll);
        m_filterModel->setFilterExpression(QgsExpression(), QgsExpressionContext()); // 清除可能存在的过滤器

        // sort() 方法会自动处理视图更新
        m_filterModel->sort(fieldIndex, m_currentSortOrder);
    }
}

void AttributeTableDialog::onFilterModeChanged()
{
    // 当从“搜索”模式切换回“排序”模式时，清除过滤器
    if (m_sortRadioButton->isChecked()) {
        if (m_filterModel->filterMode() != QgsAttributeTableFilterModel::ShowAll ||
            !m_filterModel->filterExpression().isEmpty()) {

            qDebug() << "Mode switched to Sort. Clearing filter.";
            m_filterModel->setFilterMode(QgsAttributeTableFilterModel::ShowAll);
            m_filterModel->setFilterExpression(QgsExpression(), QgsExpressionContext());
            m_filterModel->invalidate();
        }
    }
    updateControlsState();
}


// 当用户点击“搜索”按钮时
void AttributeTableDialog::onSearchButtonClicked()
{
    qDebug() << "------------------------------------------";
    qDebug() << "[START] onSearchButtonClicked() called.";

    // 字段选择检查
    int fieldIndex = m_fieldComboBox->currentData().toInt();
    qDebug() << "[DEBUG] Current field index from ComboBox:" << fieldIndex;
    if (fieldIndex < 0) {
        QMessageBox::information(this, "提示", "请先从下拉框中选择一个要搜索的字段。");
        qDebug() << "------------------------------------------";
        return;
    }

    // 获取搜索文本
    QString searchText = m_searchLineEdit->text().trimmed();
    qDebug() << "[DEBUG] Search text from LineEdit:" << "\"" << searchText << "\"";

    // 处理空搜索
    if (searchText.isEmpty()) {
        qDebug() << "[ACTION] Clearing filter because search text is empty.";
        m_filterModel->setFilterMode(QgsAttributeTableFilterModel::ShowAll);
        m_filterModel->invalidate();

        // 更新视图
        if (m_tableView) {
            m_tableView->viewport()->update();
        }

        qDebug() << "------------------------------------------";
        return;
    }

    // 获取字段信息
    QString fieldName = m_layer->fields().field(fieldIndex).name();
    QMetaType::Type fieldType = static_cast<QMetaType::Type>(m_layer->fields().field(fieldIndex).type());

    qDebug() << "[DEBUG] Field name:" << fieldName;
    qDebug() << "[DEBUG] Field type (QVariant type):" << fieldType;
    qDebug() << "[DEBUG] Field type name:" << m_layer->fields().field(fieldIndex).typeName();

    // 根据字段类型构建表达式
    QString filterString;
    if (fieldType == QMetaType::Int || fieldType == QMetaType::LongLong ||
        fieldType == QMetaType::Double || fieldType == QMetaType::ULongLong) {
        bool isNumeric;
        double numericValue = searchText.toDouble(&isNumeric);

        if (isNumeric) {
            filterString = QString("\"%1\" = %2").arg(fieldName).arg(numericValue);
            qDebug() << "[INFO] Numeric field. Using exact match:" << filterString;
        }
        else {
            filterString = QString("to_string(\"%1\") ILIKE '%%2%'").arg(fieldName).arg(searchText);
            qDebug() << "[INFO] Numeric field with non-numeric search. Using string conversion:" << filterString;
        }
    }
    else {
        filterString = QString("\"%1\" ILIKE '%%2%'").arg(fieldName).arg(searchText);
        qDebug() << "[INFO] String field. Using ILIKE:" << filterString;
    }

    qDebug() << "[DEBUG] Constructed filter string:" << filterString;

    // 创建表达式
    QgsExpression expression(filterString);
    QgsExpressionContext context;
    context.appendScopes(QgsExpressionContextUtils::globalProjectLayerScopes(m_layer));

    if (!expression.prepare(&context)) {
        qDebug() << "[ERROR] Expression preparation failed:" << expression.parserErrorString();
        QMessageBox::critical(this, "表达式错误",
            QString("无法解析搜索表达式:\n%1\n\n错误信息: %2")
            .arg(expression.expression())
            .arg(expression.parserErrorString()));
        return;
    }

    // ===== 基于官方API的解决方案 =====
    QgsFeatureRequest request;
    request.setFilterExpression(expression);
    request.setExpressionContext(context);

    // 获取匹配的特征ID
    QgsFeatureIds matchingIds;
    QgsFeatureIterator it = m_layer->getFeatures(request);
    QgsFeature feature;
    while (it.nextFeature(feature)) {
        matchingIds.insert(feature.id());
    }

    qDebug() << "[DEBUG] Found" << matchingIds.size() << "matching features";

    // 使用官方API设置过滤特征
    m_filterModel->setFilterMode(QgsAttributeTableFilterModel::ShowFilteredList);
    m_filterModel->setFilteredFeatures(matchingIds);

    // 强制刷新模型 - 官方推荐的更新方式
    m_filterModel->invalidate();

    // 可选：触发特征过滤信号
    emit m_filterModel->featuresFiltered();
    // ================================

    // 更新视图
    if (m_tableView) {
        m_tableView->viewport()->update();
    }

    // 调试输出
    qDebug() << "[DEBUG] After setting filtered features:";
    qDebug() << "  - Filter mode: " << m_filterModel->filterMode();
    qDebug() << "  - Filtered features count: " << m_filterModel->filteredFeatures().size();
    qDebug() << "  - Row count in filter model: " << m_filterModel->rowCount();

    qDebug() << "[END] Filter applied and view updated.";
    qDebug() << "------------------------------------------";
}

// ====================== 新增：实现删除功能 ======================
void AttributeTableDialog::onDeleteSelectedFeatures()
{
    if (!m_layer || !m_filterModel || !m_tableView) return;

    // 1. 获取当前在表格视图中【实际被高亮选中】的行的模型索引
    QModelIndexList selectedViewIndexes = m_tableView->selectionModel()->selectedRows();

    if (selectedViewIndexes.isEmpty()) {
        QMessageBox::information(this, "提示", "没有选中任何行进行删除。");
        return;
    }

    // 2. 将这些视图索引转换为要素ID
    QgsFeatureIds idsToDelete;
    for (const QModelIndex& viewIndex : selectedViewIndexes) {
        if (viewIndex.isValid()) {
            QModelIndex sourceIndex = m_filterModel->mapToSource(viewIndex);
            idsToDelete.insert(m_tableModel->rowToId(sourceIndex.row()));
        }
    }

    if (idsToDelete.isEmpty()) {
        // 这通常不应该发生，但作为保险
        QMessageBox::information(this, "提示", "无法识别选中的要素。");
        return;
    }

    // 3. 弹出确认对话框 (只在本次打开属性表时提示一次)
    if (!m_deleteWarningShown) {
        QMessageBox::StandardButton reply;
        reply = QMessageBox::warning(this, "确认删除",
            QString("您确定要永久删除选中的 %1 个要素吗？\n\n此操作无法撤销！").arg(idsToDelete.size()),
            QMessageBox::Yes | QMessageBox::No);

        if (reply == QMessageBox::No) {
            return;
        }
        m_deleteWarningShown = true;
    }

    // 4. 执行删除操作 (这部分逻辑不变，是正确的)
    if (!m_layer->isEditable()) {
        if (!m_layer->startEditing()) {
            QMessageBox::critical(this, "错误", "无法开启图层编辑模式，删除失败。");
            return;
        }
    }
    if (m_layer->dataProvider()->deleteFeatures(idsToDelete)) {
        if (!m_layer->commitChanges()) {
            QMessageBox::critical(this, "错误", "删除成功，但提交更改失败。请检查数据源。");
            m_layer->rollBack();
        }
        else {
            OutputManager::instance()->logMessage(QString("成功删除 %1 个要素。").arg(idsToDelete.size()));
        }
    }
    else {
        QMessageBox::critical(this, "错误", "从数据源删除要素失败。");
        m_layer->rollBack();
    }

    // 5. 刷新地图和属性表
    m_layer->triggerRepaint();
    // 删除后，模型数据源已改变，让模型自己通知视图刷新
    m_tableModel->loadLayer(); // 重新加载数据，这会强制刷新所有内容
    // 或者更温和的方式，如果上面的loadLayer太慢：
    // m_filterModel->invalidate(); 
}

// +++ 新增一个辅助函数，用于同步表格选择 +++
void AttributeTableDialog::synchronizeTableSelectionWithLayer()
{
    if (!m_layer || !m_filterModel || !m_tableView) return;

    // 1. 清除表格中当前所有的选择
    m_tableView->selectionModel()->clearSelection();

    // 2. 获取图层当前选中的要素ID
    QgsFeatureIds selectedFids = m_layer->selectedFeatureIds();

    if (selectedFids.isEmpty()) {
        return; // 如果图层没有选中要素，则无需操作
    }

    // 3. 遍历选中的要素ID，在表格中找到对应的行并选中它们
    QItemSelection selection;
    for (const QgsFeatureId fid : selectedFids) {
        // QgsAttributeTableFilterModel 有一个 fidToIndexList 方法可以找到对应的 ModelIndex
        QModelIndexList viewIndexes = m_filterModel->fidToIndexList(fid);
        for (const QModelIndex& viewIndex : viewIndexes) {
            if (viewIndex.isValid()) {
                // 我们要选中整行
                QModelIndex left = m_filterModel->index(viewIndex.row(), 0);

                QModelIndex right = m_filterModel->index(viewIndex.row(), m_filterModel->columnCount(QModelIndex()) - 1);

                selection.select(left, right);
            }
        }
    }

    // 4. 应用新的选择到表格视图
    if (!selection.isEmpty()) {
        m_tableView->selectionModel()->select(selection, QItemSelectionModel::Select | QItemSelectionModel::Rows);
        // 可选：滚动到第一个选中的行
        if (!selection.indexes().isEmpty()) {
            m_tableView->scrollTo(selection.indexes().first());
        }
    }
}

void AttributeTableDialog::onInvertSelection()
{
    if (!m_layer || !m_filterModel || !m_tableView) return;

    qDebug() << "[START] onInvertSelection called.";

    // 1. 获取当前表格视图中【所有可见行】的模型索引
    QList<QModelIndex> allVisibleViewIndexes;
    for (int row = 0; row < m_filterModel->rowCount(); ++row) {
        allVisibleViewIndexes.append(m_filterModel->index(row, 0));
    }

    if (allVisibleViewIndexes.isEmpty()) {
        qDebug() << "[INFO] No rows in current view. Nothing to invert.";
        return;
    }

    // 2. 获取当前在表格视图中【实际被高亮选中】的行的模型索引
    QModelIndexList currentlySelectedViewIndexes = m_tableView->selectionModel()->selectedRows();

    // 3. 创建一个新的QItemSelection，用于存储反选后的结果
    QItemSelection newSelection;

    // 4. 遍历所有可见行
    for (const QModelIndex& viewIndex : allVisibleViewIndexes) {
        if (viewIndex.isValid()) {
            bool wasSelected = false;
            // 检查这一行之前是否被选中
            for (const QModelIndex& selectedIdx : currentlySelectedViewIndexes) {
                if (selectedIdx.row() == viewIndex.row()) {
                    wasSelected = true;
                    break;
                }
            }

            if (!wasSelected) {
                // 如果这行之前没被选中，现在就选中它
                QModelIndex left = m_filterModel->index(viewIndex.row(), 0);
                QModelIndex right = m_filterModel->index(viewIndex.row(), m_filterModel->columnCount(QModelIndex()) - 1);
                newSelection.select(left, right);
            }
            // 如果这行之前被选中了，那么在新的selection里它就是未选中状态 (因为我们从空selection开始构建)
        }
    }

    // 5. 应用新的选择到表格视图
    //    a. 先清除旧的视觉选择
    m_tableView->selectionModel()->clearSelection();
    //    b. 再应用新的视觉选择
    if (!newSelection.isEmpty()) {
        m_tableView->selectionModel()->select(newSelection, QItemSelectionModel::Select | QItemSelectionModel::Rows);
    }

    // 6. **核心：根据表格UI的最新选择状态，去更新图层的选择集**
    QgsFeatureIds fidsToSelectInLayer;
    QModelIndexList finalSelectedViewIndexes = m_tableView->selectionModel()->selectedRows();
    for (const QModelIndex& viewIndex : finalSelectedViewIndexes) {
        if (viewIndex.isValid()) {
            QModelIndex sourceIndex = m_filterModel->mapToSource(viewIndex);
            fidsToSelectInLayer.insert(m_tableModel->rowToId(sourceIndex.row()));
        }
    }

    // 更新图层选择集（先清空，再设置）
    m_layer->removeSelection();
    if (!fidsToSelectInLayer.isEmpty()) {
        m_layer->selectByIds(fidsToSelectInLayer);
    }

    qDebug() << "[END] Invert selection finished. UI selection updated. Layer selected count:" << m_layer->selectedFeatureCount();
}
正在处理文件: BufferDialog.cpp
(BufferDialog.cpp)
#include "BufferDialog.h"
#include <QVBoxLayout>
#include <QHBoxLayout>
#include <QGridLayout>
#include <QLabel>
#include <QComboBox>
#include <QPushButton>
#include <QLineEdit>
#include <QFileDialog>
#include <QMessageBox>
#include <QStandardPaths>
#include <QFileInfo>
#include <QDoubleSpinBox>
#include <QSpinBox>
#include <QCheckBox>
#include <QGroupBox>
#include <memory> // 用于std::unique_ptr

#include <qgsapplication.h>
#include <qgsgeometry.h>
#include <qgsproject.h>
#include <qgsvectorlayer.h>
#include <qgscoordinatereferencesystem.h>
#include <qgsprocessingfeedback.h>
#include <qgsprocessingcontext.h>
#include <qgsprocessingalgorithm.h> // 替换qgsprocessingrunner.h
#include <qgscolorbutton.h>
#include <qgssinglesymbolrenderer.h>
#include <qgsfillsymbol.h>
#include <qgsunittypes.h>
#include <qgsfields.h> // 用于复制属性
#include <qgsdistancearea.h> // 用于单位转换和距离计算
#include <qgsprocessingregistry.h>
#include <qgsvectorfilewriter.h>
#include "Output_Manager.h"
#include <QDebug>

#include "gdal_priv.h"
#include "ogrsf_frmts.h" // OGR Simple Features Library
#include "ogr_geometry.h" // OGR Geometry
#include "ogr_spatialref.h" // OGR Spatial Reference
#include "cpl_conv.h"
#include "cpl_string.h"

BufferDialog::BufferDialog(QWidget* parent)
    : QDialog(parent), m_currentInputLayer(nullptr)
{
    setWindowTitle("缓冲区分析");
    setMinimumWidth(500);
    setupUI();
    populateInputLayerComboBox();
    populateUnitComboBox();

    // 初始更新默认输出路径
    connect(m_inputLayerCombo, QOverload<int>::of(&QComboBox::currentIndexChanged),
        this, &BufferDialog::onInputLayerChanged);
    connect(m_spinBufferDistance, QOverload<double>::of(&QDoubleSpinBox::valueChanged),
        this, &BufferDialog::updateDefaultOutputPath);
}

BufferDialog::~BufferDialog()
{
}

void BufferDialog::setupUI()
{
    QVBoxLayout* mainLayout = new QVBoxLayout(this);
    QGridLayout* gridLayout = new QGridLayout();

    // 1. 输入图层
    gridLayout->addWidget(new QLabel("输入图层:", this), 0, 0);
    m_inputLayerCombo = new QComboBox(this);
    gridLayout->addWidget(m_inputLayerCombo, 0, 1);
    m_btnSelectInputLayerFile = new QPushButton("从文件...", this);
    gridLayout->addWidget(m_btnSelectInputLayerFile, 0, 2); // 暂时禁用文件选择，简化
    m_lblSelectedInputLayerInfo = new QLabel("当前选择: 无", this);
    gridLayout->addWidget(m_lblSelectedInputLayerInfo, 1, 0, 1, 3);

    // 2. 缓冲区参数
    gridLayout->addWidget(new QLabel("缓冲区距离:", this), 2, 0);
    m_spinBufferDistance = new QDoubleSpinBox(this);
    m_spinBufferDistance->setDecimals(2);
    m_spinBufferDistance->setMinimum(0.01);
    m_spinBufferDistance->setMaximum(1000000.0);
    m_spinBufferDistance->setValue(100.0);
    gridLayout->addWidget(m_spinBufferDistance, 2, 1);

    m_unitCombo = new QComboBox(this);
    gridLayout->addWidget(m_unitCombo, 2, 2);

    gridLayout->addWidget(new QLabel("端点平滑度 (段数):", this), 3, 0);
    m_spinSegments = new QSpinBox(this);
    m_spinSegments->setMinimum(1); // 至少1段
    m_spinSegments->setMaximum(100);
    m_spinSegments->setValue(8); // QGIS默认值
    gridLayout->addWidget(m_spinSegments, 3, 1, 1, 2);

    m_chkDissolveResult = new QCheckBox("溶解缓冲区结果", this);
    m_chkDissolveResult->setChecked(false);
    gridLayout->addWidget(m_chkDissolveResult, 4, 0, 1, 3);

    // 3. 输出图层路径
    gridLayout->addWidget(new QLabel("输出图层路径:", this), 5, 0);
    m_editOutputLayerPath = new QLineEdit(this);
    m_editOutputLayerPath->setPlaceholderText("选择输出文件路径...");
    gridLayout->addWidget(m_editOutputLayerPath, 5, 1);
    m_btnSelectOutputLayer = new QPushButton("浏览...", this);
    gridLayout->addWidget(m_btnSelectOutputLayer, 5, 2);

    // 4. 可视化参数
    QGroupBox* vizGroup = new QGroupBox("输出图层可视化", this);
    QGridLayout* vizLayout = new QGridLayout(vizGroup);

    m_lblFillColor = new QLabel("填充颜色:", vizGroup);
    m_btnFillColor = new QgsColorButton(vizGroup);
    m_btnFillColor->setDefaultColor(QColor(0, 0, 255, 100)); // 蓝色半透明
    m_btnFillColor->setColor(m_btnFillColor->defaultColor());
    vizLayout->addWidget(m_lblFillColor, 0, 0);
    vizLayout->addWidget(m_btnFillColor, 0, 1);

    m_lblFillOpacity = new QLabel("填充透明度 (0-1):", vizGroup);
    m_spinFillOpacity = new QDoubleSpinBox(vizGroup);
    m_spinFillOpacity->setDecimals(2);
    m_spinFillOpacity->setMinimum(0.0);
    m_spinFillOpacity->setMaximum(1.0);
    m_spinFillOpacity->setValue(m_btnFillColor->color().alphaF()); // 从颜色按钮同步
    connect(m_btnFillColor, &QgsColorButton::colorChanged, this, [this](const QColor& color) {
        m_spinFillOpacity->setValue(color.alphaF());
        });
    connect(m_spinFillOpacity, QOverload<double>::of(&QDoubleSpinBox::valueChanged), this, [this](double value) {
        QColor c = m_btnFillColor->color();
        c.setAlphaF(value);
        m_btnFillColor->setColor(c);
        });
    vizLayout->addWidget(m_lblFillOpacity, 0, 2);
    vizLayout->addWidget(m_spinFillOpacity, 0, 3);


    m_lblStrokeColor = new QLabel("边界颜色:", vizGroup);
    m_btnStrokeColor = new QgsColorButton(vizGroup);
    m_btnStrokeColor->setDefaultColor(Qt::black);
    m_btnStrokeColor->setColor(m_btnStrokeColor->defaultColor());
    vizLayout->addWidget(m_lblStrokeColor, 1, 0);
    vizLayout->addWidget(m_btnStrokeColor, 1, 1);

    m_lblStrokeWidth = new QLabel("边界宽度:", vizGroup);
    m_spinStrokeWidth = new QDoubleSpinBox(vizGroup);
    m_spinStrokeWidth->setDecimals(2);
    m_spinStrokeWidth->setMinimum(0.0);
    m_spinStrokeWidth->setValue(0.26); // QGIS默认
    vizLayout->addWidget(m_lblStrokeWidth, 1, 2);
    vizLayout->addWidget(m_spinStrokeWidth, 1, 3);

    vizGroup->setLayout(vizLayout);
    gridLayout->addWidget(vizGroup, 6, 0, 1, 3);


    mainLayout->addLayout(gridLayout);
    mainLayout->addStretch();

    // 5. 按钮
    QHBoxLayout* buttonLayout = new QHBoxLayout();
    buttonLayout->addStretch();
    m_btnOk = new QPushButton("确定", this);
    m_btnCancel = new QPushButton("取消", this);
    buttonLayout->addWidget(m_btnOk);
    buttonLayout->addWidget(m_btnCancel);
    mainLayout->addLayout(buttonLayout);

    setLayout(mainLayout);

    // 连接信号
    connect(m_btnSelectInputLayerFile, &QPushButton::clicked, this, &BufferDialog::onSelectInputLayerClicked);
    connect(m_btnSelectOutputLayer, &QPushButton::clicked, this, &BufferDialog::onSelectOutputLayerClicked);
    connect(m_btnOk, &QPushButton::clicked, this, &BufferDialog::onOkClicked);
    connect(m_btnCancel, &QPushButton::clicked, this, &QDialog::reject);
}

void BufferDialog::populateInputLayerComboBox()
{
    m_inputLayerCombo->clear();
    m_inputLayerCombo->addItem("--- 从项目中选择矢量图层 ---", QVariant());
    QList<QgsMapLayer*> layers = QgsProject::instance()->mapLayers().values();
    for (QgsMapLayer* layer : layers) {
            if (auto vectorLayer = qobject_cast<QgsVectorLayer*>(layer)) {
                m_inputLayerCombo->addItem(vectorLayer->name(), QVariant::fromValue(vectorLayer));
            }
    }
    onInputLayerChanged(); // 更新初始状态
}

void BufferDialog::populateUnitComboBox()
{
    m_unitCombo->clear();
    // QgsUnitTypes::DistanceUnit 是 QGIS 3.x 的方式
    m_unitCombo->addItem(QgsUnitTypes::toString(Qgis::DistanceUnit::Meters), static_cast<int>(Qgis::DistanceUnit::Meters));
    m_unitCombo->addItem(QgsUnitTypes::toString(Qgis::DistanceUnit::Kilometers), static_cast<int>(Qgis::DistanceUnit::Kilometers));
    m_unitCombo->addItem(QgsUnitTypes::toString(Qgis::DistanceUnit::Feet), static_cast<int>(Qgis::DistanceUnit::Feet));
    m_unitCombo->addItem(QgsUnitTypes::toString(Qgis::DistanceUnit::Miles), static_cast<int>(Qgis::DistanceUnit::Miles));
    m_unitCombo->addItem(QgsUnitTypes::toString(Qgis::DistanceUnit::Degrees), static_cast<int>(Qgis::DistanceUnit::Degrees)); // 度 (用于地理坐标系)

    // 默认选中米
    int meterIndex = m_unitCombo->findData(static_cast<int>(Qgis::DistanceUnit::Meters));
    if (meterIndex != -1) {
        m_unitCombo->setCurrentIndex(meterIndex);
    }
}

void BufferDialog::onSelectInputLayerClicked()
{
    QString filter = "ESRI Shapefiles (*.shp);;GeoPackage (*.gpkg);;所有文件 (*.*)";
    QString filePath = QFileDialog::getOpenFileName(
        this,
        "选择输入矢量文件",
        QStandardPaths::writableLocation(QStandardPaths::HomeLocation),
        filter
    );
    if (filePath.isEmpty())
        return;

    // 尝试加载为矢量图层
    std::unique_ptr<QgsVectorLayer> tempLayer(new QgsVectorLayer(filePath, QFileInfo(filePath).baseName(), "ogr"));
    if (!tempLayer->isValid()) {
        QMessageBox::critical(this, "加载错误", "无法加载所选文件为有效矢量图层:\n" + filePath);
        return;
    }

    // 更新UI显示
    m_lblSelectedInputLayerInfo->setText(QString("当前选择: %1 (文件)").arg(QFileInfo(filePath).fileName()));
    m_inputLayerCombo->setCurrentIndex(0); // 选中“--- 从项目中选择矢量图层 ---”

    // 设置当前输入图层为临时加载的图层
    m_currentInputLayer = tempLayer.release(); // 交给成员变量管理

    // 更新单位下拉框（根据图层CRS）
    if (m_currentInputLayer->crs().isValid()) {
        Qgis::DistanceUnit layerUnits = Qgis::DistanceUnit::Meters; // 默认米
        int unitIndex = m_unitCombo->findData(static_cast<int>(layerUnits));
        if (unitIndex != -1) {
            m_unitCombo->setCurrentIndex(unitIndex);
        }
        else if (m_currentInputLayer->crs().isGeographic()) {
            int degIndex = m_unitCombo->findData(static_cast<int>(Qgis::DistanceUnit::Degrees));
            if (degIndex != -1) m_unitCombo->setCurrentIndex(degIndex);
        }
    }

    updateDefaultOutputPath();
}

void BufferDialog::onInputLayerChanged()
{
    m_currentInputLayer = nullptr;
    if (m_inputLayerCombo->currentIndex() > 0) {
        QVariant data = m_inputLayerCombo->currentData();
        QgsVectorLayer* layer = qvariant_cast<QgsVectorLayer*>(data);
        if (layer && QgsProject::instance()->mapLayer(layer->id())) {
            m_currentInputLayer = layer;
            m_lblSelectedInputLayerInfo->setText(QString("当前选择: %1").arg(layer->name()));
            // 尝试根据图层CRS的单位更新单位下拉框的默认值
            if (layer->crs().isValid()) {
                Qgis::DistanceUnit layerUnits = Qgis::DistanceUnit::Meters; // Default to meters
                int unitIndex = m_unitCombo->findData(static_cast<int>(layerUnits));
                if (unitIndex != -1) {
                    m_unitCombo->setCurrentIndex(unitIndex);
                }
                else if (layer->crs().isGeographic()) {
                    int degIndex = m_unitCombo->findData(static_cast<int>(Qgis::DistanceUnit::Degrees));
                    if (degIndex != -1) m_unitCombo->setCurrentIndex(degIndex);
                }
            }
        }
    }
    else {
        m_lblSelectedInputLayerInfo->setText("当前选择: 无");
    }
    updateDefaultOutputPath();
}


void BufferDialog::updateDefaultOutputPath()
{
    if (!m_currentInputLayer) {
        m_editOutputLayerPath->clear();
        return;
    }
    QFileInfo fi(m_currentInputLayer->source());
    QString baseName = fi.completeBaseName();
    if (baseName.isEmpty()) baseName = m_currentInputLayer->name().remove(QRegExp("[^a-zA-Z0-9_]")); // 如果source是内存图层

    QString dirPath = QgsProject::instance()->homePath(); // 默认保存到项目路径
    if (fi.exists()) dirPath = fi.absolutePath();

    double dist = m_spinBufferDistance->value();

    QString defaultOutputName = QString("%1_buffer_%2.%3").arg(baseName).arg(dist).arg("shp"); // 默认shp
    m_editOutputLayerPath->setText(QDir(dirPath).filePath(defaultOutputName));
}


void BufferDialog::onSelectOutputLayerClicked()
{
    QString filter = "ESRI Shapefiles (*.shp);;GeoPackage (*.gpkg);;GeoTIFF (*.tif);;All files (*.*)";
    QString defaultDir = QgsProject::instance()->homePath();

    if (defaultDir.isEmpty()) {
        defaultDir = QStandardPaths::writableLocation(QStandardPaths::DocumentsLocation);
    }

    QString fileName = QFileDialog::getSaveFileName(this, "保存输出图层",
        m_editOutputLayerPath->text(),
        filter);
    if (!fileName.isEmpty()) {
        m_editOutputLayerPath->setText(fileName);
    }
}
// 公共接口实现
QgsVectorLayer* BufferDialog::selectedInputLayer() const { return m_currentInputLayer; }
double BufferDialog::bufferDistance() const { return m_spinBufferDistance->value(); }
Qgis::DistanceUnit BufferDialog::distanceUnits() const { return static_cast<Qgis::DistanceUnit>(m_unitCombo->currentData().toInt()); }
int BufferDialog::segments() const { return m_spinSegments->value(); }
bool BufferDialog::dissolveResult() const { return m_chkDissolveResult->isChecked(); }
QString BufferDialog::outputLayerPath() const { return m_editOutputLayerPath->text(); }
QColor BufferDialog::fillColor() const { return m_btnFillColor->color(); }
double BufferDialog::fillOpacity() const { return m_spinFillOpacity->value(); }
QColor BufferDialog::strokeColor() const { return m_btnStrokeColor->color(); }
double BufferDialog::strokeWidth() const { return m_spinStrokeWidth->value(); }


void BufferDialog::onOkClicked()
{
    QString inputPath = m_currentInputLayer ? m_currentInputLayer->source() : QString();
    double distanceValueFromUI = bufferDistance();
    Qgis::DistanceUnit unitSelectedByUser = distanceUnits();
    int segments = this->segments();
    bool dissolve = dissolveResult();
    QString outputPath = outputLayerPath();

    if (inputPath.isEmpty() || outputPath.isEmpty() || distanceValueFromUI <= 0) {
        QMessageBox::warning(this, "输入错误", "请检查所有输入参数。");
        return;
    }

    qDebug() << "\n====== 开始GDAL缓冲区分析 ======";
    qDebug() << "输入图层:" << inputPath;
    qDebug() << "UI距离值:" << distanceValueFromUI;
    qDebug() << "UI单位:" << QgsUnitTypes::toString(unitSelectedByUser) << "(" << static_cast<int>(unitSelectedByUser) << ")";
    qDebug() << "段数:" << segments;
    qDebug() << "溶解:" << dissolve;
    qDebug() << "输出路径:" << outputPath;


    GDALAllRegister();
    OGRRegisterAll();

    GDALDataset* poSrcDS = (GDALDataset*)GDALOpenEx(inputPath.toUtf8().constData(), GDAL_OF_VECTOR | GDAL_OF_READONLY, nullptr, nullptr, nullptr);
    if (!poSrcDS) {
        QMessageBox::critical(this, "GDAL错误", "无法打开输入矢量文件: " + inputPath + "\n" + CPLGetLastErrorMsg());
        return;
    }
    OGRLayer* poSrcLayer = poSrcDS->GetLayer(0);
    if (!poSrcLayer) {
        QMessageBox::critical(this, "GDAL错误", "无法获取输入图层。");
        GDALClose(poSrcDS);
        return;
    }
    OGRSpatialReference* poSrcSRS = poSrcLayer->GetSpatialRef();

    // --- 重点修改区域开始 ---
    double distanceInSrcUnits = distanceValueFromUI; // 默认值，如果无法进行转换则使用

    if (poSrcSRS != nullptr) {
        double distanceInMeters_fromUserSelection; // 用户选择的单位转换成米

        // 步骤1: 将用户界面上的距离和单位统一转换为米 (除非用户选择的就是度)
        bool userSelectedDegrees = (unitSelectedByUser == Qgis::DistanceUnit::Degrees);

        if (!userSelectedDegrees) {
            switch (unitSelectedByUser) {
            case Qgis::DistanceUnit::Meters:
                distanceInMeters_fromUserSelection = distanceValueFromUI;
                break;
            case Qgis::DistanceUnit::Kilometers:
                distanceInMeters_fromUserSelection = distanceValueFromUI * 1000.0;
                break;
            case Qgis::DistanceUnit::Feet:
                distanceInMeters_fromUserSelection = distanceValueFromUI * 0.3048;
                break;
            case Qgis::DistanceUnit::Miles:
                distanceInMeters_fromUserSelection = distanceValueFromUI * 1609.34;
                break;
            default:
                QMessageBox::warning(this, "单位警告", "未知的缓冲区单位，将按输入值直接处理。");
                // distanceInSrcUnits 保持为 distanceValueFromUI
                goto end_unit_conversion_label; // 直接跳到转换结束
            }
            qDebug() << "用户输入已转换为米:" << distanceInMeters_fromUserSelection << "m";
        }

        // 步骤2: 根据图层坐标系，将米（或度）转换为图层实际单位
        if (poSrcSRS->IsGeographic()) {
            if (userSelectedDegrees) {
                distanceInSrcUnits = distanceValueFromUI; // 用户选了度，图层是地理坐标系，直接用
                qDebug() << "图层为地理坐标系，用户单位为度。缓冲区距离 (度):" << distanceInSrcUnits;
            }
            else {
                // 图层是地理坐标系，用户单位是米/公里等线性单位，需转为度
                // 1度约等于111195米 (这是一个平均值，更精确的计算会考虑纬度)
                // QGIS内部进行此类操作时可能会临时投影到合适的等距方位投影
                // GDAL OGR_G_Buffer 在地理坐标系上期望距离参数也是度
                distanceInSrcUnits = distanceInMeters_fromUserSelection / 111195.0;
                qDebug() << "图层为地理坐标系，用户选择线性单位。缓冲区距离 (近似度):" << distanceInSrcUnits;
            }
        }
        else { // 图层是投影坐标系
            if (userSelectedDegrees) {
                // 用户选了度，但图层是投影坐标系。这种情况通常不建议。
                // QGIS桌面通常不允许为投影图层选择“度”作为缓冲区单位。
                // 我们这里采取一个策略：警告并按原始值处理，期望用户知道其含义。
                QMessageBox::warning(this, "单位不匹配警告", "为投影坐标系图层选择“度”作为缓冲区单位可能产生非预期结果。将直接使用输入值作为图层单位的距离。");
                distanceInSrcUnits = distanceValueFromUI;
                qDebug() << "图层为投影坐标系，用户单位为度。缓冲区距离 (按图层单位):" << distanceInSrcUnits;
            }
            else {
                // 图层是投影坐标系，用户单位是米/公里等线性单位
                // 获取投影坐标系的线性单位对应的米数 (例如，如果单位是英尺，返回0.3048)
                double metersPerLayerUnit = poSrcSRS->GetLinearUnits(nullptr); // 获取1个图层单位等于多少米
                if (metersPerLayerUnit > 1e-9) { // 避免除以0或非常小的值
                    distanceInSrcUnits = distanceInMeters_fromUserSelection / metersPerLayerUnit;
                    qDebug() << "图层为投影坐标系。1图层单位=" << metersPerLayerUnit << "米。缓冲区距离 (图层单位):" << distanceInSrcUnits;
                }
                else {
                    qDebug() << "无法确定投影坐标系的有效线性单位因子 (因子=" << metersPerLayerUnit
                        << ")。假设图层单位是米。";
                    distanceInSrcUnits = distanceInMeters_fromUserSelection; // 回退：假设图层单位是米
                }
            }
        }
    }
    else { // poSrcSRS is NULL (图层没有坐标系信息)
        qDebug() << "输入图层无坐标系信息。将直接使用用户输入值 (" << distanceValueFromUI
            << ") 和单位 (" << QgsUnitTypes::toString(unitSelectedByUser)
            << ") 作为缓冲区的距离。";
        // 在这种情况下，如果用户选了公里但图层单位是米，结果会不正确。
        // 但没有CRS信息，无法做更智能的转换。
        // 为了与之前的逻辑（和QGIS某些工具的行为）保持一定一致性，
        // 如果是常见线性单位，我们还是先转成米，再假设图层单位是米
        // 如果是度，就直接用。这是一个折衷。
        switch (unitSelectedByUser) {
        case Qgis::DistanceUnit::Meters:     distanceInSrcUnits = distanceValueFromUI; break;
        case Qgis::DistanceUnit::Kilometers: distanceInSrcUnits = distanceValueFromUI * 1000.0; break; // 这里产生100000
        case Qgis::DistanceUnit::Feet:       distanceInSrcUnits = distanceValueFromUI * 0.3048; break;
        case Qgis::DistanceUnit::Miles:      distanceInSrcUnits = distanceValueFromUI * 1609.34; break;
        case Qgis::DistanceUnit::Degrees:    distanceInSrcUnits = distanceValueFromUI; break; // 直接用度
        default: distanceInSrcUnits = distanceValueFromUI; break; // 其他未知单位直接用
        }
        qDebug() << "无CRS，最终采用的缓冲距离(假设目标单位兼容米或度):" << distanceInSrcUnits;
        // 如果图层是度为单位但无CRS，而用户选了公里，上面的转换会导致距离值很大（如100km -> 100000）
        // 这时GDAL Buffer会将其解释为100000度，这是不正确的。
        // 最安全的做法是，如果无CRS，就直接用 distanceValueFromUI，并警告用户。
        // distanceInSrcUnits = distanceValueFromUI; // Revert to this simpler logic for no-CRS
        // QMessageBox::warning(this, "坐标系缺失", "输入图层缺少坐标系信息。缓冲区距离将直接使用您输入的值，请确保其单位与图层内部单位一致。");

    }

end_unit_conversion_label:;
    qDebug() << "最终用于 OGR_G_Buffer 的距离值:" << distanceInSrcUnits;
    // --- 重点修改区域结束 ---


    const char* pszDriverName = "ESRI Shapefile";
    if (outputPath.endsWith(".gpkg", Qt::CaseInsensitive)) pszDriverName = "GPKG";

    GDALDriver* poDriver = GetGDALDriverManager()->GetDriverByName(pszDriverName);
    if (poDriver == nullptr) {
        QMessageBox::critical(this, "GDAL错误", QString("无法获取驱动: %1").arg(pszDriverName));
        GDALClose(poSrcDS);
        return;
    }

    if (QFile::exists(outputPath)) {
        if (GDALDeleteDataset(poDriver, outputPath.toUtf8().constData()) != CE_None) {
            qDebug() << "无法删除已存在的输出文件:" << outputPath << CPLGetLastErrorMsg();
            // 可以选择报错返回，或者继续尝试覆盖 (Create可能失败)
        }
    }
    GDALDataset* poDstDS = poDriver->Create(outputPath.toUtf8().constData(), 0, 0, 0, GDT_Unknown, nullptr);
    if (poDstDS == nullptr) {
        QMessageBox::critical(this, "GDAL错误", "无法创建输出文件: " + outputPath + "\n" + CPLGetLastErrorMsg());
        GDALClose(poSrcDS);
        return;
    }

    OGRLayer* poDstLayer = poDstDS->CreateLayer(QFileInfo(outputPath).completeBaseName().toUtf8().constData(),
        poSrcSRS,
        wkbPolygon, nullptr);
    if (poDstLayer == nullptr) {
        QMessageBox::critical(this, "GDAL错误", "无法创建输出图层。");
        GDALClose(poDstDS); GDALClose(poSrcDS);
        return;
    }
    OGRFeatureDefn* poSrcFDefn = poSrcLayer->GetLayerDefn();
    for (int iField = 0; iField < poSrcFDefn->GetFieldCount(); iField++) {
        OGRFieldDefn* poFieldDefn = poSrcFDefn->GetFieldDefn(iField);
        if (poDstLayer->CreateField(poFieldDefn) != OGRERR_NONE) {
            qWarning() << "无法创建字段:" << poFieldDefn->GetNameRef();
        }
    }

    OGRFeature* poSrcFeature;
    OGRFeature* poDstFeature = OGRFeature::CreateFeature(poDstLayer->GetLayerDefn());
    QList<OGRGeometry*> bufferedGeometries;

    poSrcLayer->ResetReading();
    int featureCount = 0;
    while ((poSrcFeature = poSrcLayer->GetNextFeature()) != nullptr) {
        featureCount++;
        OGRGeometry* poSrcGeom = poSrcFeature->GetGeometryRef();
        if (poSrcGeom != nullptr && !poSrcGeom->IsEmpty()) {
            OGRGeometry* poBufferedGeom = poSrcGeom->Buffer(distanceInSrcUnits, segments);

            if (poBufferedGeom != nullptr && !poBufferedGeom->IsEmpty()) {
                if (dissolve) {
                    bufferedGeometries.append(poBufferedGeom->clone()); // 克隆以备溶解
                    OGRGeometryFactory::destroyGeometry(poBufferedGeom);
                }
                else {
                    poDstFeature->SetFrom(poSrcFeature, TRUE); // 复制属性
                    poDstFeature->SetGeometryDirectly(poBufferedGeom); // poBufferedGeom所有权转移
                    if (poDstLayer->CreateFeature(poDstFeature) != OGRERR_NONE) {
                        qWarning() << "无法在输出图层创建要素。";
                    }
                    // poDstFeature->SetGeometry(nullptr) might be needed if reusing poDstFeature
                    // but SetGeometryDirectly transfers ownership, so it's fine.
                }
            }
            else if (poBufferedGeom) { // Buffer可能返回空几何
                OGRGeometryFactory::destroyGeometry(poBufferedGeom);
            }
        }
        OGRFeature::DestroyFeature(poSrcFeature);
    }
    qDebug() << "处理了" << featureCount << "个要素。";


    if (dissolve && !bufferedGeometries.isEmpty()) {
        qDebug() << "开始溶解" << bufferedGeometries.size() << "个缓冲区几何...";
        // OGRGeometryCollection oGeomColl; // 旧方法
        // for (OGRGeometry* geom : bufferedGeometries) {
        //    oGeomColl.addGeometry(geom); // addGeometry clones
        //    OGRGeometryFactory::destroyGeometry(geom); // 所以可以销毁原件
        // }
        // bufferedGeometries.clear();
        // OGRGeometry* poDissolvedGeom = oGeomColl.UnionCascaded();

        // 更高效的溶解方法，特别是对于大量几何图形
        OGRGeometry* poDissolvedGeom = nullptr;
        if (!bufferedGeometries.isEmpty()) {
            poDissolvedGeom = bufferedGeometries.takeFirst(); // 从第一个开始
            for (OGRGeometry* geom : bufferedGeometries) {
                OGRGeometry* tempUnion = poDissolvedGeom->Union(geom);
                OGRGeometryFactory::destroyGeometry(poDissolvedGeom);
                OGRGeometryFactory::destroyGeometry(geom);
                poDissolvedGeom = tempUnion;
                if (!poDissolvedGeom) { // Union失败
                    qWarning() << "溶解过程中Union操作失败。";
                    break;
                }
            }
        }
        bufferedGeometries.clear();


        if (poDissolvedGeom && !poDissolvedGeom->IsEmpty()) {
            // 对于溶解后的单个要素，属性如何处理？通常是清空或赋一个代表性值。
            // 这里我们不设置属性，只设置几何。
            poDstFeature->SetGeometryDirectly(poDissolvedGeom); // 所有权转移
            if (poDstLayer->CreateFeature(poDstFeature) != OGRERR_NONE) {
                qWarning() << "无法在输出图层创建溶解后的要素。";
            }
        }
        else if (poDissolvedGeom) { //可能是空的union结果
            OGRGeometryFactory::destroyGeometry(poDissolvedGeom);
            qDebug() << "溶解结果为空几何。";
        }
        qDebug() << "溶解完成。";
    }
    else if (dissolve && bufferedGeometries.isEmpty()) {
        qDebug() << "请求溶解但没有有效的缓冲区几何体可供溶解。";
    }

    OGRFeature::DestroyFeature(poDstFeature);

    GDALClose(poDstDS);
    GDALClose(poSrcDS);

    QgsVectorLayer* newLayer = new QgsVectorLayer(outputPath, QFileInfo(outputPath).baseName(), "ogr");
    if (newLayer->isValid()) {
        std::unique_ptr<QgsFillSymbol> fillSymbol(QgsFillSymbol::createSimple({
            {"color", fillColor().name(QColor::HexArgb)},
            {"style", "solid"},
            {"outline_color", strokeColor().name(QColor::HexArgb)},
            {"outline_width", QString::number(strokeWidth())},
            {"outline_style", "solid"} // 添加边界样式以确保可见
            }));
        // fillSymbol->setOpacity(fillOpacity()); // QgsColorButton已经包含alpha，所以这里不需要单独设置了
                                                // 如果颜色按钮的alphaF()与m_spinFillOpacity不同步则需要

        QColor currentFillColor = fillColor(); // 从按钮获取
        fillSymbol->setColor(currentFillColor); // 设置包含透明度的颜色
        // fillSymbol->setOpacity(currentFillColor.alphaF()); // 或者这样明确设置，如果上面setColor不处理alpha的话


        QgsSingleSymbolRenderer* renderer = new QgsSingleSymbolRenderer(fillSymbol.release()); // release所有权
        newLayer->setRenderer(renderer);
        newLayer->triggerRepaint(); // 确保刷新

        QgsProject::instance()->addMapLayer(newLayer);
        QMessageBox::information(this, "成功", "GDAL缓冲区分析完成！\n输出文件: " + outputPath);
        accept();
    }
    else {
        QMessageBox::critical(this, "加载错误", "缓冲区已生成，但无法加载到地图: " + outputPath + "\n错误: " + newLayer->error().message());
        delete newLayer; // 清理无效图层
    }
}

正在处理文件: CustomLayerTreeView.cpp
(CustomLayerTreeView.cpp)
#include "CustomLayerTreeView.h"
#include "Output_Manager.h" // 引入日志管理器
#include "AttributeTableDialog.h"
#include "RasterLayerPropertiesDialog.h"

#include <QTreeView>
#include <QStandardItemModel>
#include <QVBoxLayout>
#include <QVariant>
#include <QMenu>
#include <QColorDialog>
#include <QItemSelection>
#include <qgsmaplayer.h>
#include <qgsvectorlayer.h>
#include <qgsrasterlayer.h>
#include <qgssinglesymbolrenderer.h>
#include <qgssymbol.h>
#include <qgsmapcanvas.h>
#include <QDebug>
#include <QMessageBox>
#include <qgsproject.h> // 需要它来移除图层

const int LayerPtrRole = Qt::UserRole + 1;
CustomLayerTreeView::CustomLayerTreeView(QgsMapCanvas* canvas, QWidget* parent)
    : QWidget(parent), m_mapCanvas(canvas)
{
    m_treeView = new QTreeView(this);
    m_model = new QStandardItemModel(this);
    m_treeView->setModel(m_model);
    m_model->setHorizontalHeaderLabels({ "Layers" });
    m_treeView->setContextMenuPolicy(Qt::CustomContextMenu);

    connect(m_model, &QStandardItemModel::itemChanged, this, &CustomLayerTreeView::onItemChanged);
    connect(m_treeView, &QTreeView::customContextMenuRequested, this, &CustomLayerTreeView::onCustomContextMenuRequested);
    // +++ 连接QTreeView的selectionChanged信号到我们的新槽函数 +++
    connect(m_treeView->selectionModel(), &QItemSelectionModel::selectionChanged,
        this, &CustomLayerTreeView::onSelectionChanged);

    QVBoxLayout* layout = new QVBoxLayout(this);
    layout->setContentsMargins(0, 0, 0, 0);
    layout->addWidget(m_treeView);
    setLayout(layout);

}
CustomLayerTreeView::~CustomLayerTreeView()
{
}
void CustomLayerTreeView::addLayer(QgsMapLayer* layer)
{
    if (!layer) return;
    QStandardItem* item = new QStandardItem(layer->name());
    item->setCheckable(true);
    item->setCheckState(Qt::Checked);
    item->setData(QVariant::fromValue(static_cast<void*>(layer)), LayerPtrRole);

    item->setEditable(true);// 设置为可编辑

    QgsVectorLayer* vlayer = qobject_cast<QgsVectorLayer*>(layer);
    if (vlayer) {
        QgsSingleSymbolRenderer* renderer = dynamic_cast<QgsSingleSymbolRenderer*>(vlayer->renderer());
        if (renderer) {
            updateLayerItemIcon(item, renderer->symbol()->color());
        }
    }

    // 将新图层插入到模型的第0行
    m_model->insertRow(0, item);
}
// 当model的属性改变时立即同步
void CustomLayerTreeView::onItemChanged(QStandardItem* item)
{
    if (!item) return;
    // 获取关联的图层
    QgsMapLayer* layer = static_cast<QgsMapLayer*>(item->data(LayerPtrRole).value<void*>());
    if (!layer) return;

    // ==================== 关键修改 2: 处理重命名 ====================
    // 检查是否是名称发生了变化
    QString newName = item->text();
    if (layer->name() != newName) {
        QString oldName = layer->name();
        layer->setName(newName); // <<< 核心：更新QGIS图层对象的名称
        OutputManager::instance()->logMessage(QString("图层 '%1' 已重命名为 '%2'").arg(oldName).arg(newName));
        emit modelChanged(); // <<< 核心：发出信号，通知主窗口项目已变“脏”
        return; // 处理完重命名后直接返回，避免下面的逻辑重复执行
    }
    // ================================================================

    // 处理可见性变化（原有的逻辑）
    qDebug() << "Item changed:" << item->text() << "Check state:" << item->checkState();
    updateMapCanvasLayers();
    emit modelChanged(); // 可见性变化也应该标记为“脏”
}


// 右键菜单
void CustomLayerTreeView::onCustomContextMenuRequested(const QPoint& pos)
{
    QModelIndex index = m_treeView->indexAt(pos);
    if (!index.isValid()) {
        return;
    }
    QStandardItem* item = m_model->itemFromIndex(index);
    if (!item) return;
    QgsMapLayer* layer = static_cast<QgsMapLayer*>(item->data(LayerPtrRole).value<void*>());
    if (!layer) return;

    QMenu contextMenu(this);
    QAction* action = nullptr; // 用于接收创建的QAction指针

    // --- 1. 重命名 (通用) ---
    action = contextMenu.addAction("重命名");
    connect(action, &QAction::triggered, this, [=]() {
        m_treeView->edit(index);
        });

    // --- 2. 修改颜色 (仅矢量) ---
    if (auto vlayer = qobject_cast<QgsVectorLayer*>(layer)) {
        action = contextMenu.addAction("修改颜色...");
        connect(action, &QAction::triggered, this, [=]() {
            this->onChangeLayerColor(layer); // 内部会再次cast，安全
            });
    }
    contextMenu.addSeparator(); // 在编辑属性和移动顺序之间加分隔符

    // --- 3. 排序功能 (通用) ---
    action = contextMenu.addAction("上移一层");
    connect(action, &QAction::triggered, this, [=]() { this->onMoveLayerUp(index); });
    action->setEnabled(index.row() > 0);

    action = contextMenu.addAction("下移一层");
    connect(action, &QAction::triggered, this, [=]() { this->onMoveLayerDown(index); });
    action->setEnabled(index.row() < m_model->rowCount() - 1);

    contextMenu.addSeparator(); // 一层移动和顶/底移动之间加分隔符

    action = contextMenu.addAction("置于顶层");
    connect(action, &QAction::triggered, this, [=]() { this->onMoveToTop(index); });
    action->setEnabled(index.row() > 0);

    action = contextMenu.addAction("置于底层");
    connect(action, &QAction::triggered, this, [=]() { this->onMoveToBottom(index); });
    action->setEnabled(index.row() < m_model->rowCount() - 1);

    contextMenu.addSeparator(); // 在排序和打开属性/删除之间加分隔符

    // --- 4. 打开特定属性对话框 (根据类型) ---
    if (auto vlayer = qobject_cast<QgsVectorLayer*>(layer)) {
        action = contextMenu.addAction("打开属性表");
        connect(action, &QAction::triggered, this, [=]() {
            AttributeTableDialog* dialog = new AttributeTableDialog(vlayer, m_mapCanvas, this->window());
            dialog->setAttribute(Qt::WA_DeleteOnClose);
            dialog->show();
            });
    }
    else if (auto rlayer = qobject_cast<QgsRasterLayer*>(layer)) {
        action = contextMenu.addAction("属性...");
        connect(action, &QAction::triggered, this, [=]() {
            RasterLayerPropertiesDialog* dialog = new RasterLayerPropertiesDialog(rlayer, this->window());
            dialog->setAttribute(Qt::WA_DeleteOnClose);
            dialog->show();
            });
    }
    // (未来可以为其他图层类型添加 else if 分支)

    // 只有在确实添加了“打开属性表”或“属性...”后才加分隔符
    if (contextMenu.actions().size() > 0 && !contextMenu.actions().last()->isSeparator()) {
        contextMenu.addSeparator();
    }


    // --- 5. 删除图层 (通用，通常放最后) ---
    action = contextMenu.addAction("删除图层");
    connect(action, &QAction::triggered, this, [=]() { this->onRemoveLayer(index); });

    contextMenu.exec(m_treeView->viewport()->mapToGlobal(pos));
}

void CustomLayerTreeView::onMoveLayerUp(const QModelIndex& index)
{
    if (!index.isValid()) return;
    int row = index.row();
    if (row > 0) {
        QList<QStandardItem*> rowItems = m_model->takeRow(row);
        m_model->insertRow(row - 1, rowItems);
        updateMapCanvasLayers();
        m_treeView->setCurrentIndex(m_model->index(row - 1, 0));
        emit modelChanged(); // <<< 发出信号
    }
}
void CustomLayerTreeView::onMoveLayerDown(const QModelIndex& index)
{
    if (!index.isValid()) return;
    int row = index.row();
    if (row < m_model->rowCount() - 1) {
        QList<QStandardItem*> rowItems = m_model->takeRow(row);
        m_model->insertRow(row + 1, rowItems);
        updateMapCanvasLayers();
        m_treeView->setCurrentIndex(m_model->index(row + 1, 0));
        emit modelChanged(); // <<< 发出信号
    }
}

void CustomLayerTreeView::onMoveToTop(const QModelIndex& index)
{
    if (!index.isValid() || index.row() == 0) return; // 如果已经是顶层，则不操作

    // 从当前位置取出该行
    QList<QStandardItem*> rowItems = m_model->takeRow(index.row());
    // 将其插入到模型的第0行 (UI的顶层)
    m_model->insertRow(0, rowItems);

    updateMapCanvasLayers(); // 根据新的UI顺序刷新画布
    m_treeView->setCurrentIndex(m_model->index(0, 0)); // 更新选中项
    emit modelChanged();
}

void CustomLayerTreeView::onMoveToBottom(const QModelIndex& index)
{
    if (!index.isValid() || index.row() == m_model->rowCount() - 1) return; // 如果已经是底层，则不操作

    // 从当前位置取出该行
    QList<QStandardItem*> rowItems = m_model->takeRow(index.row());
    // 将其追加到模型的末尾 (UI的底层)
    m_model->appendRow(rowItems);

    updateMapCanvasLayers(); // 根据新的UI顺序刷新画布
    m_treeView->setCurrentIndex(m_model->index(m_model->rowCount() - 1, 0)); // 更新选中项
    emit modelChanged();
}


void CustomLayerTreeView::onChangeLayerColor(QgsMapLayer* layer)
{
    QgsVectorLayer* vectorLayer = qobject_cast<QgsVectorLayer*>(layer);
    if (!vectorLayer) return;
    // !! 修正: 对非QObject的类使用 dynamic_cast !!
    QgsSingleSymbolRenderer* renderer = dynamic_cast<QgsSingleSymbolRenderer*>(vectorLayer->renderer());
    if (!renderer) {
        qDebug() << "Cannot change color: layer does not use a single symbol renderer.";
        return;
    }

    const QColor newColor = QColorDialog::getColor(renderer->symbol()->color(), this, "选择新颜色");

    if (newColor.isValid()) {
        renderer->symbol()->setColor(newColor);
        vectorLayer->triggerRepaint();

        for (int i = 0; i < m_model->rowCount(); ++i) {
            QStandardItem* item = m_model->item(i);
            QgsMapLayer* itemLayer = static_cast<QgsMapLayer*>(item->data(LayerPtrRole).value<void*>());
            if (itemLayer == layer) {
                updateLayerItemIcon(item, newColor);
                emit modelChanged();
                break;
            }
        }
    }
}
void CustomLayerTreeView::updateLayerItemIcon(QStandardItem* item, const QColor& color)
{
    if (!item) return;
    QPixmap pixmap(16, 16);
    pixmap.fill(color);
    item->setIcon(QIcon(pixmap));
}
// --- !! 新增的槽函数实现 !! ---
void CustomLayerTreeView::onRemoveLayer(const QModelIndex& index)
{
    if (!index.isValid()) return;
    // 1. 获取图层和Item
    QStandardItem* item = m_model->itemFromIndex(index);
    if (!item) return;

    QgsMapLayer* layer = static_cast<QgsMapLayer*>(item->data(LayerPtrRole).value<void*>());
    if (!layer) return;

    // 2. 弹出确认对话框
    QMessageBox::StandardButton reply;
    reply = QMessageBox::question(this, "确认删除", QString("确定要删除图层 '%1' 吗？此操作无法撤销。").arg(layer->name()),
        QMessageBox::Yes | QMessageBox::No);
    if (reply == QMessageBox::No) {
        return;
    }

    // 3. 从 QGIS 项目中移除图层。
    //    这一步是核心，它会触发信号，让QGIS框架负责清理图层对象。
    QgsProject::instance()->removeMapLayer(layer->id());

    // 4. 从我们的视图模型中移除对应的行。
    //    此时，layer 指针已经是一个“悬垂指针”，QGIS很快会删除它。
    //    我们绝对不能再使用它，尤其是不能 delete 它。
    m_model->removeRow(index.row());

    // 5. 更新画布
    //    在 QGIS 3.x 中，removeMapLayer 信号通常会连接到画布的更新槽，
    //    所以这一步可能不是必需的，但为了保险起见，可以保留。
    updateMapCanvasLayers();
    m_mapCanvas->refresh();

}


void CustomLayerTreeView::updateMapCanvasLayers()
{
    QList<QgsMapLayer*> layersToRender;

    // 从UI模型的顶部 (index 0, 用户看到的顶层) 开始遍历
    for (int uiRow = 0; uiRow < m_model->rowCount(); ++uiRow)
    {
        QStandardItem* item = m_model->item(uiRow);
        if (item && item->checkState() == Qt::Checked)
        {
            QVariant layerVariant = item->data(LayerPtrRole);
            if (layerVariant.isValid()) {
                QgsMapLayer* layer = static_cast<QgsMapLayer*>(layerVariant.value<void*>());
                // 将UI列表中的图层，按顺序【追加】到渲染列表的【末尾】
                layersToRender.append(layer);
            }
        }
    }

    m_mapCanvas->setLayers(layersToRender);
    qDebug() << "Map canvas updated. UI Top (" << (m_model->rowCount() > 0 ? m_model->item(0)->text() : "N/A")
        << ") is Map Top. Render order (bottom to top):";
    for (QgsMapLayer* lyr : layersToRender) {
        qDebug() << "  - " << lyr->name();
    }
}



void CustomLayerTreeView::clear()
{
    m_model->clear();
    m_model->setHorizontalHeaderLabels({ "Layers" });
    updateMapCanvasLayers(); // 清空画布
}
// +++ 实现新槽函数的逻辑 +++
void CustomLayerTreeView::onSelectionChanged(const QItemSelection& selected, const QItemSelection& deselected)
{
    Q_UNUSED(deselected); // 不关心之前选中的是什么

    QModelIndexList indexes = selected.indexes();
    if (indexes.isEmpty()) {
        // 如果没有选中任何项（例如，清空图层后），发出一个nullptr信号
        emit currentLayerChanged(nullptr);
        return;
    }

    // 通常我们只关心第一个被选中的项
    QModelIndex currentIndex = indexes.first();
    QStandardItem* item = m_model->itemFromIndex(currentIndex);
    if (item) {
        QgsMapLayer* layer = static_cast<QgsMapLayer*>(item->data(LayerPtrRole).value<void*>());
        // 发出信号，将当前选中的图层指针传递出去
        emit currentLayerChanged(layer);
    }

}
正在处理文件: FeatureSelectionTool.cpp
(FeatureSelectionTool.cpp)
#include "featureselectiontool.h"
#include <qgsmapcanvas.h>
#include <qgsvectorlayer.h>
#include <qgsfeature.h>
#include <qgsproject.h>
#include <qgsmaplayer.h>
#include <qgsapplication.h>

#include <QToolTip> // 使用 Qt 的工具提示

FeatureSelectionTool::FeatureSelectionTool(QgsMapCanvas* canvas)
    : QgsMapToolIdentify(canvas)
{
    this->setCursor(Qt::ArrowCursor);
}

// 当工具被激活时，重置状态
void FeatureSelectionTool::activate()
{
    QgsMapTool::activate();
    clearCurrentSelection();
}

// 当工具被停用时，清理所有状态
void FeatureSelectionTool::deactivate()
{
    QgsMapTool::deactivate();
    clearCurrentSelection();
    QToolTip::hideText();
}

// 新的核心逻辑：鼠标移动事件
void FeatureSelectionTool::canvasMoveEvent(QgsMapMouseEvent* e)
{
    // 识别鼠标下的要素
    QList<IdentifyResult> results = this->identify(e->x(), e->y(), IdentifyMode::TopDownAll);

    if (results.isEmpty())
    {
        // 如果鼠标下没有要素，隐藏提示
        QToolTip::hideText();
        return;
    }

    // 只处理最顶层的矢量图层结果
    IdentifyResult topResult = results.first();
    QgsMapLayer* layer = topResult.mLayer;
    QgsFeature feature = topResult.mFeature;

    QgsVectorLayer* vlayer = qobject_cast<QgsVectorLayer*>(layer);
    if (!vlayer || !feature.isValid())
    {
        QToolTip::hideText();
        return;
    }

    // 获取要素的 "name" 属性
    QString displayName;
    int nameFieldIndex = vlayer->fields().indexOf("name");
    if (nameFieldIndex != -1) {
        displayName = feature.attribute("name").toString();
    }
    else {
        displayName = QString("ID: %1").arg(feature.id());
    }

    // 显示提示信息
    if (!displayName.isEmpty()) {
        QString tipText = QString("<b>名称:</b><br>%1").arg(displayName);
        QPoint globalPos = canvas()->mapToGlobal(e->pos());
        QToolTip::showText(globalPos, tipText, canvas());
    }
}


// 我们保留点击事件，用于真正“选定”和高亮要素
void FeatureSelectionTool::canvasReleaseEvent(QgsMapMouseEvent* e)
{
    QList<IdentifyResult> results = this->identify(e->x(), e->y(), IdentifyMode::TopDownAll);

    // 先清除之前的选择
    clearCurrentSelection();

    if (results.isEmpty()) {
        canvas()->refresh();
        return;
    }

    // 只处理最顶层的矢量图层结果
    IdentifyResult topResult = results.first();
    QgsMapLayer* layer = topResult.mLayer;
    QgsFeature feature = topResult.mFeature;

    QgsVectorLayer* vlayer = qobject_cast<QgsVectorLayer*>(layer);
    if (!vlayer || !feature.isValid()) {
        canvas()->refresh();
        return;
    }

    // 在图层上选择该要素，使其高亮
    vlayer->select(feature.id());

    // 记录下这次选择，方便之后清除
    m_lastSelectedLayer = vlayer;
    m_lastSelectedFeatureId = feature.id();
}

// 辅助函数，用于清除当前的选择
void FeatureSelectionTool::clearCurrentSelection()
{
    if (m_lastSelectedLayer)
    {
        m_lastSelectedLayer->deselect(m_lastSelectedFeatureId);
        m_lastSelectedLayer = nullptr;
    }
    else
    {
        // 如果没有特定记录，则作为备用方案，清除所有图层的选择
        QList<QgsMapLayer*> layers = QgsProject::instance()->mapLayers().values();
        for (QgsMapLayer* layer : layers) {
            // 使用动态类型检查来确保图层是矢量图层
            QgsVectorLayer* vectorLayer = qobject_cast<QgsVectorLayer*>(layer);
            if (vectorLayer) {
                vectorLayer->removeSelection();
            }
        }
    }
}
正在处理文件: FileLogger.cpp
(FileLogger.cpp)
#pragma once
#include "FileLogger.h"
#include <QDateTime>
#include <QDebug>

FileLogger::FileLogger(const QString& logFilePath, QObject* parent)
    : QObject(parent)
{
    m_logFile.setFileName(logFilePath);

    // 以追加模式打开文件，这样即使程序快速重启也不会覆盖日志
    // QIODevice::Text 会自动处理不同操作系统下的换行符
    if (!m_logFile.open(QIODevice::WriteOnly | QIODevice::Append | QIODevice::Text))
    {
        qWarning() << "无法打开日志文件进行写入:" << logFilePath;
        return;
    }

    // 将文本流与文件关联
    m_logStream.setDevice(&m_logFile);
    // 确保使用UTF-8编码，以支持中文字符
    m_logStream.setCodec("UTF-8");

    // (可选) 在日志文件开头写入一条启动信息
    QString startMessage = QString("===== 日志开始于 %1 =====\n")
        .arg(QDateTime::currentDateTime().toString("yyyy-MM-dd hh:mm:ss"));
    m_logStream << startMessage;
    m_logStream.flush(); // 立即写入
}

FileLogger::~FileLogger()
{
    // 在对象销毁时，确保所有缓冲数据都已写入文件并关闭文件
    if (m_logFile.isOpen()) {
        m_logStream.flush();
        m_logFile.close();
    }
}

void FileLogger::onMessageLogged(const QString& message, const QString& type)
{
    if (!m_logFile.isOpen()) {
        return; // 如果文件未成功打开，则不执行任何操作
    }

    // 格式化日志条目，与您在OutputWidget中的格式完全一致
    QString formattedMessage = QString("[%1][%2] %3")
        .arg(QDateTime::currentDateTime().toString("yyyy-MM-dd hh:mm:ss"))
        .arg(type)
        .arg(message);

    // 将格式化后的消息写入文件流，并添加换行符
    m_logStream << formattedMessage << Qt::endl;
}
正在处理文件: main.cpp
(main.cpp)
#pragma warning(disable:4996)
#include "QGIS_dev.h"
#include "FileLogger.h"
#include "Output_Manager.h"
#include <QTextCodec>
#include <QDir>
#include <QDateTime>
#include <QStyleFactory>
#include <qgsapplication.h>
#include <qgscoordinatereferencesystem.h>
#include <qgsproviderregistry.h>
#include <qgsmaplayer.h>
#include <qdebug.h>
#include <QMessageBox>
#include <QMetaType>


int main(int argc, char* argv[])
{
    // === STAGE 1: 创建QApplication实例 ===
    // 这是所有UI操作的前提，必须是第一步。
    QgsApplication a(argc, argv, true);
    qDebug() << "STAGE 1 PASSED: QgsApplication instance created.";

    // 注册 QgsMapLayer* 类型，让Qt的元对象系统在处理 QVariant 时能更好地识别它
    qRegisterMetaType<QgsMapLayer*>("QgsMapLayer*");

    // === STAGE 2: 强制设置环境变量 ===
    // 此时 QApplication 已存在，但 QGIS 核心还未初始化。
    // 这是设置环境变量的最佳时机。
    QString prefixPath = QgsApplication::applicationDirPath();

    // 使用 Qt 的 qputenv，它更安全
    // 它在内部处理了字符串的生命周期问题
    qputenv("PROJ_LIB", QDir::toNativeSeparators(prefixPath + "/share/proj").toLocal8Bit());
    qputenv("QT_PLUGIN_PATH", QDir::toNativeSeparators(prefixPath + "/plugins").toLocal8Bit());

    // 添加核心DLL目录到PATH，以防万一
    QByteArray pathEnv = qgetenv("PATH");
    QString newPath = QDir::toNativeSeparators(prefixPath) + ";" + pathEnv;
    qputenv("PATH", newPath.toLocal8Bit());

    // === STAGE 3: 初始化QGIS核心 ===
    // 此时环境变量已设置完毕，initQgis() 会在正确的环境下运行
    QgsApplication::setPrefixPath(prefixPath, true); // 仍然建议设置，因为它影响QGIS内部的其他路径逻辑
    QgsApplication::initQgis();
    qDebug() << "STAGE 3: QGIS Init 完成";

    // === STAGE 4: 关键功能测试 - CRS创建 ===
    QgsCoordinateReferenceSystem testCrs("EPSG:4326");
    if (testCrs.isValid()) {
        qDebug() << "STAGE 4: CRS Test - SUCCESS! 'EPSG:4326' created. Problem solved!";
    }
    else {
        qDebug() << "STAGE 4: CRS Test - FAILURE! Still cannot create CRS. This indicates a fundamental DLL or data file version mismatch.";
        return -1;
    }

    // === STAGE 5: 启动主程序 ===
    qDebug() << "All checks passed. Starting main application...";


    // ====================== 应用预设样式(qss) ======================
    // 1. 查看可用的样式 (可选，用于调试)
    qDebug() << "Available Qt styles:" << QStyleFactory::keys();

    // 2. 设置一个您喜欢的样式
    //    "Fusion" 通常是一个好的、跨平台的选择。
    //    您可以尝试 "Windows" (在Windows上) 或其他可用的样式。
    QString styleName = "Fusion";
    if (QStyleFactory::keys().contains(styleName, Qt::CaseInsensitive)) {
        a.setStyle(QStyleFactory::create(styleName));
        OutputManager::instance()->logMessage(QString("Application style set to: %1").arg(styleName));
    }
    else {
        OutputManager::instance()->logWarning(QString("Style '%1' not found. Using default application style.").arg(styleName));
        qDebug() << "Default style will be used. Available styles:" << QStyleFactory::keys();
    }


    int result = 0;
    {
        QGIS_dev w;
        w.setMinimumSize(1920, 1080);
        w.show();

        // 日志系统安全初始化并使用
        QDir logDir(QApplication::applicationDirPath());

        logDir.mkdir("logs");
        if (logDir.exists("logs")) {
            logDir.cd("logs");
        }
        QString timestamp = QDateTime::currentDateTime().toString("yyyy-MM-dd-HH-mm");
        QString logFilePath = logDir.filePath(timestamp + ".log");
        FileLogger* fileLogger = new FileLogger(logFilePath, &a);
        QObject::connect(OutputManager::instance(), &OutputManager::messageLogged, fileLogger, &FileLogger::onMessageLogged);
        OutputManager::instance()->logMessage("应用程序启动成功。");

        result = a.exec();
    }

    QgsApplication::exitQgis();
    return result;
}

正在处理文件: MapCanvas.cpp
(MapCanvas.cpp)
#include "MapCanvas.h"
#include <qgsmapcanvas.h>
#include <qgsmaptoolpan.h>
#include <qgsproject.h>
#include <qgsmaplayer.h>
#include <QVBoxLayout>
#include <QDebug>

MapCanvas::MapCanvas(QWidget* parent)
    : QWidget(parent)
{
    m_qgsCanvas = new QgsMapCanvas();
    m_qgsCanvas->setCanvasColor(Qt::white);
    m_qgsCanvas->enableAntiAliasing(true);

    QVBoxLayout* layout = new QVBoxLayout(this);
    layout->setContentsMargins(0, 0, 0, 0);
    layout->addWidget(m_qgsCanvas);
    setLayout(layout);

    // 平移工具
    m_panTool = new QgsMapToolPan(m_qgsCanvas);
    m_qgsCanvas->setMapTool(m_panTool);
    m_panTool->setCursor(Qt::OpenHandCursor);

    // ====================== 画布目标CRS固定为WGS 84 ======================
    QgsCoordinateReferenceSystem wgs84("EPSG:4326");
    if (wgs84.isValid()) {
        m_qgsCanvas->setDestinationCrs(wgs84);
        qDebug() << "MapCanvas destination CRS permanently set to WGS 84.";
    }
    else {
        qDebug() << "CRITICAL: Failed to create WGS 84 for MapCanvas destination CRS.";
    }
    // ========================================================

    // 连接比例尺信号
    connect(m_qgsCanvas, &QgsMapCanvas::scaleChanged, this, &MapCanvas::onCanvasScaleChanged);
    onCanvasScaleChanged(m_qgsCanvas->scale());
}

MapCanvas::~MapCanvas()
{
}

QgsMapCanvas* MapCanvas::getCanvas() const
{
    return m_qgsCanvas;
}

// 获取平移工具的实现
QgsMapToolPan* MapCanvas::getPanTool() const
{
    return m_panTool;
}

void MapCanvas::zoomToLayer(QgsMapLayer* layer)
{
    if (layer && layer->isValid()) {
        m_qgsCanvas->setExtent(layer->extent());
        m_qgsCanvas->refresh();
        // 注意：setExtent会自动改变比例尺，从而触发scaleChanged信号，所以这里无需额外操作
    }
}

// --- 新增接口的实现 ---

void MapCanvas::zoomIn()
{
    if (m_qgsCanvas) {
        m_qgsCanvas->zoomIn(); // 将调用传递给QGIS画布
    }
}

void MapCanvas::zoomOut()
{
    if (m_qgsCanvas) {
        m_qgsCanvas->zoomOut(); // 将调用传递给QGIS画布
    }
}

// --- 新增私有槽的实现 ---

void MapCanvas::onCanvasScaleChanged(double newScale)
{
    // 将double类型的比例尺分母格式化为 "1:XXXXX" 的字符串
    QString formattedScale = QString("比例尺 1:%1").arg(static_cast<int>(newScale));

    // 发射我们自己的、携带格式化字符串的信号
    emit scaleChanged(formattedScale);
    qDebug() << "Scale changed to:" << formattedScale;
}
正在处理文件: OutputWidget.cpp
(OutputWidget.cpp)
#include "Output_Manager.h"
#include <OutputWidget.h>
#include <QTextEdit>
#include <QVBoxLayout>
#include <QDateTime>
#include <QString>

OutputWidget::OutputWidget(QWidget* parent)
	: QWidget(parent)
{
    // 输出控制台
    m_outputConsole = new QTextEdit();
    m_outputConsole->setReadOnly(true);
    m_outputConsole->setWordWrapMode(QTextOption::WordWrap);

    // 添加布局
    QVBoxLayout* layout = new QVBoxLayout(this);
    layout->addWidget(m_outputConsole);
    setLayout(layout);

    connect(OutputManager::instance(), &OutputManager::messageLogged, this, &OutputWidget::displayMessage);
}

void OutputWidget::displayMessage(const QString& message,const QString& type) {
    QString formattedMessage = QString("[%1] [%2] %3").arg(QDateTime::currentDateTime().toString("yyyy-MM-ddhh:mm:ss")).arg(type).arg(message);
    m_outputConsole->append(formattedMessage);
}

OutputWidget::~OutputWidget() {

}
正在处理文件: Output_Manager.cpp
(Output_Manager.cpp)
#include "Output_Manager.h"
#include <QDebug>

OutputManager* OutputManager::m_instance = nullptr;


OutputManager::OutputManager(QObject* parent)
	:	QObject(parent) 
{
	qDebug() << "OutputManager instance created.";
}

OutputManager* OutputManager::instance()
{
	if (!m_instance) {
		m_instance = new OutputManager();
	}
	return m_instance;
}

void OutputManager::logMessage(const QString& message) {
	emit messageLogged(message, "INFO");
}

void OutputManager::logWarning(const QString& message) {
	emit messageLogged(message, "WARNING");
}

void OutputManager::logError(const QString& message) {
	emit messageLogged(message, "ERROR");
}


正在处理文件: QGIS_dev.cpp
(QGIS_dev.cpp)
#include "QGIS_dev.h"
#include "Output_Manager.h"
#include "MapCanvas.h"
#include "OutputWidget.h"
#include "CustomLayerTreeView.h"
#include "FeatureSelectionTool.h"
#include "AnalysisToolboxWidget.h"

#include <QDesktopServices>
#include <QDockWidget>
#include <QMenu>
#include <QMenuBar>
#include <QAction>
#include <QToolBar>
#include <QFileInfo>
#include <QDebug>
#include <QFileDialog> // 用于文件对话框
#include <QDir>        // 用于获取默认路径
#include <QMessageBox>
#include <QLabel>
#include <QStatusBar>
#include <QPushButton> // 添加此行以包含 QPushButton 的完整定义
#include <QProcess>
#include <QUrl>
#include <QUrlQuery>
#include <qgsvectorlayer.h>
#include <qgsrasterlayer.h> // 需要包含栅格图层头文件
#include <qgslayertree.h>
#include <qgsproject.h>
#include <qgsmaptoolpan.h>
#include <qgsMapLayer.h>
#include <qgsapplication.h> // 添加此行以包含 QgsApplication 的完整定义
#include <qgsprojectionselectiondialog.h>

const int LayerPtrRole = Qt::UserRole + 1;


QGIS_dev::QGIS_dev(QWidget *parent)
    : QMainWindow(parent), m_isProjectDirty(false),m_currentLayer(nullptr) // 初始化项目状态
{
    // 调用辅助函数来创建和设置UI
    setupUI();
    setupActions();
    setupToolBar();

    // 默认激活平移工具
    m_panAction->setChecked(true);
    onActivatePanTool(); // 确保程序启动时，平移工具是激活状态

    // 连接 CustomLayerTreeView 的修改信号，以更新“脏”状态
    // (这需要在 CustomLayerTreeView 中添加一个信号)
    connect(m_customLayerTreeView, &CustomLayerTreeView::modelChanged, this, &QGIS_dev::onProjectDirty);

    // 在 QGIS_dev 构造函数中

    connect(QgsProject::instance(), &QgsProject::layersAdded, this, &QGIS_dev::onProjectDirty);
    connect(QgsProject::instance(), &QgsProject::layersAdded, this, [this](const QList<QgsMapLayer*>& layers) {
        for (QgsMapLayer* layer : layers) {
            // 在rebuildLayerTreeFromProject中已经有这个逻辑了，
            // layersAdded 信号应该只用来触发UI更新，而不是直接添加
            m_customLayerTreeView->addLayer(layer);
        }
        // 关键修改：添加图层后，手动更新一次画布，确保显示
        m_customLayerTreeView->updateMapCanvasLayers();
        });
    connect(QgsProject::instance(), QOverload<const QStringList&>::of(&QgsProject::layersWillBeRemoved), this, [this]() {
        this->onProjectDirty();
        });

    // 关键：连接地图画布的信号到新槽函数
    QgsMapCanvas* canvas = m_mapCanvas->getCanvas();
    connect(m_mapCanvas->getCanvas(), &QgsMapCanvas::scaleChanged, this, &QGIS_dev::updateScale);
    connect(canvas, &QgsMapCanvas::xyCoordinates, this, &QGIS_dev::updateCoordinates);
    connect(canvas, &QgsMapCanvas::scaleChanged, this, &QGIS_dev::updateScale);

    // +++ 将图层树的选中事件连接到主窗口的槽 +++
    connect(m_customLayerTreeView, &CustomLayerTreeView::currentLayerChanged,
        this, &QGIS_dev::onCurrentLayerChanged);

    // ====================== 核心修改：项目CRS固定为WGS 84 ======================
    QgsCoordinateReferenceSystem wgs84("EPSG:4326");
    if (wgs84.isValid()) {
        QgsProject::instance()->setCrs(wgs84); // 程序启动时就设定项目CRS
        OutputManager::instance()->logMessage("Project CRS permanently set to WGS 84 (EPSG:4326).");
    }
    else {
        OutputManager::instance()->logError("CRITICAL: Failed to create WGS 84 CRS. Projections will likely fail.");
    }
    // 不再连接 QgsProject::crsChanged，因为不希望它改变
    // connect(QgsProject::instance(), &QgsProject::crsChanged, this, &QGIS_dev::updateProjectCrs);

    updateProjectCrs(); // 手动调用一次以设置标签文本
    // =========================================================================

    updateWindowTitle();

    updateScale(m_mapCanvas->getCanvas()->scale());
}

QGIS_dev::~QGIS_dev()
{
}

// ---在此设置所有窗口UI---
void QGIS_dev::setupUI()
{
    // 创建核心组件
    m_mapCanvas = new MapCanvas(this); // MapCanvas保持不变

    // 将地图画布的指针传递给它
    m_customLayerTreeView = new CustomLayerTreeView(m_mapCanvas->getCanvas(), this);
    m_customLayerTreeView->setMinimumWidth(300);

    m_outputWidget = new OutputWidget(this);

    setCentralWidget(m_mapCanvas);

    // 将customLayerTreeView 放入DockWidget
    m_layerTreeDock = new QDockWidget("图层 (自定义)", this);
    m_layerTreeDock->setWidget(m_customLayerTreeView);
    addDockWidget(Qt::LeftDockWidgetArea, m_layerTreeDock);

    // 创建两个右侧Dock
    // a. 创建“空间分析”Dock，并放入自定义Widget
    m_analysisToolsWidget = new AnalysisToolboxWidget(this);

    m_analysisDock = new QDockWidget("空间分析工具", this);
    m_analysisDock->setWidget(m_analysisToolsWidget);

    // 创建“输出”Dock
    m_outputDock = new QDockWidget("输出", this);
    m_outputDock->setWidget(m_outputWidget);

    // 先添加上面的（分析），再添加下面的（输出）
    addDockWidget(Qt::RightDockWidgetArea, m_analysisDock);
    addDockWidget(Qt::RightDockWidgetArea, m_outputDock);

    // 将它们垂直排列
    splitDockWidget(m_analysisDock, m_outputDock, Qt::Vertical);

    m_analysisDock->setMinimumWidth(350);
    m_outputDock->setMinimumWidth(350);

    // 创建菜单栏
    m_fileMenu = menuBar()->addMenu("文件(&F)"); // &F 设置快捷键 Alt+F
    m_checkMenu = menuBar()->addMenu("查看(&C)");

    // 创建工具栏
    m_toolBar = new QToolBar(this);
    addToolBar(Qt::TopToolBarArea, m_toolBar);
    m_toolBar->setFloatable(false);       // 设置是否浮动
    m_toolBar->setMovable(false);         // 设置工具栏不允许移动

    // 新增：设置状态栏 
    QStatusBar* sb = statusBar(); // 获取主窗口的状态栏

    // 创建坐标标签
    m_coordsLabel = new QLabel("坐标: (移动鼠标查看)", this);
    m_coordsLabel->setMinimumWidth(250); // 设置一个最小宽度，防止跳动
    m_coordsLabel->setFrameShape(QFrame::StyledPanel);
    m_coordsLabel->setFrameShadow(QFrame::Sunken);

    // 创建比例尺标签
    m_scaleLabel = new QLabel("比例尺: N/A", this);
    m_scaleLabel->setMinimumWidth(150);
    m_scaleLabel->setFrameShape(QFrame::StyledPanel);
    m_scaleLabel->setFrameShadow(QFrame::Sunken);

    // 将标签作为永久部件添加到状态栏（这样它们就不会被临时消息覆盖）
    sb->addPermanentWidget(m_coordsLabel);
    sb->addPermanentWidget(m_scaleLabel);

    // ====================== 核心修改：CRS显示为固定标签 ======================
    m_crsLabel = new QLabel("EPSG:4326", this); // 直接显示固定文本
    m_crsLabel->setToolTip("项目坐标参考系固定为 WGS 84 (EPSG:4326)");
    m_crsLabel->setMinimumWidth(120); // 根据需要调整宽度
    m_crsLabel->setFrameShape(QFrame::StyledPanel);
    m_crsLabel->setFrameShadow(QFrame::Sunken);
    // 不再需要 connect clicked 信号
    sb->addPermanentWidget(m_crsLabel);
    // =======================================================================
}

// ---在此设置所有的菜单栏---
void QGIS_dev::setupActions()
{
    // 创建“添加矢量图层”动作
    m_addVectorAction = new QAction("添加矢量图层", this);
    m_addVectorAction->setStatusTip("从文件加载一个矢量图层 (如: .shp)");
    connect(m_addVectorAction, &QAction::triggered, this, &QGIS_dev::onAddVectorLayer);

    // 创建“添加栅格图层”动作
    m_addRasterAction = new QAction("添加栅格图层", this);
    m_addRasterAction->setStatusTip("从文件加载一个栅格图层 (如: .tif)");
    connect(m_addRasterAction, &QAction::triggered, this, &QGIS_dev::onAddRasterLayer);

    // ====================== 新增动作 ======================
   // 创建“添加分隔符文本图层”动作
    m_addDelimitedTextLayerAction = new QAction("添加分隔符文本图层...", this);
    m_addDelimitedTextLayerAction->setStatusTip("从CSV或其他文本文件加载点图层");
    connect(m_addDelimitedTextLayerAction, &QAction::triggered, this, &QGIS_dev::onAddDelimitedTextLayer);
    // ======================================================

    // 新建项目动作
    m_newAction = new QAction("新建项目", this);
    m_newAction->setShortcut(QKeySequence::New);
    connect(m_newAction, &QAction::triggered, this, &QGIS_dev::onNewProject);

    // 打开项目动作
    m_openAction = new QAction("打开项目...", this);
    m_openAction->setShortcut(QKeySequence::Open);
    connect(m_openAction, &QAction::triggered, this, &QGIS_dev::onOpenProject);

    // 保存项目动作
    m_saveAction = new QAction("保存项目", this);
    m_saveAction->setShortcut(QKeySequence::Save);
    connect(m_saveAction, &QAction::triggered, this, &QGIS_dev::onSaveProject);

    // 另存为动作
    m_saveAsAction = new QAction("项目另存为...", this);
    m_saveAsAction->setShortcut(QKeySequence::SaveAs);
    connect(m_saveAsAction, &QAction::triggered, this, &QGIS_dev::onSaveProjectAs);

    // 将新动作添加到菜单栏
    m_fileMenu->addAction(m_newAction);
    m_fileMenu->addAction(m_openAction);
    m_fileMenu->addAction(m_saveAction);
    m_fileMenu->addAction(m_saveAsAction);
    m_fileMenu->addSeparator();
    m_fileMenu->addAction(m_addVectorAction);
    m_fileMenu->addAction(m_addRasterAction);
    m_fileMenu->addAction(m_addDelimitedTextLayerAction);

    m_checkLogsAction = new QAction("日志", this);
    connect(m_checkLogsAction, &QAction::triggered, this, &QGIS_dev::onOpenLogFolder);
    m_checkMenu->addAction(m_checkLogsAction); // 假设你想加到“查看”菜单

    // === 新增视图菜单 ===
    QMenu* viewMenu = menuBar()->addMenu("视图(&V)");

    m_viewLayerManagerAction = new QAction("图层管理器", this);
    m_viewLayerManagerAction->setCheckable(true);
    m_viewLayerManagerAction->setChecked(m_layerTreeDock->isVisible());
    connect(m_viewLayerManagerAction, &QAction::toggled, this, [this](bool checked) {
        m_layerTreeDock->setVisible(checked);
        });

    m_viewToolBarAction = new QAction("工具栏", this);
    m_viewToolBarAction->setCheckable(true);
    m_viewToolBarAction->setChecked(m_toolBar->isVisible());
    connect(m_viewToolBarAction, &QAction::toggled, this, [this](bool checked) {
        m_toolBar->setVisible(checked);
        });

    m_viewOutputDockAction = new QAction("输出栏", this);
    m_viewOutputDockAction->setCheckable(true);
    m_viewOutputDockAction->setChecked(m_outputDock->isVisible());
    connect(m_viewOutputDockAction, &QAction::toggled, this, [this](bool checked) {
        m_outputDock->setVisible(checked);
        });

    m_viewAnalysisDockAction = new QAction("空间分析工具", this);
    m_viewAnalysisDockAction->setCheckable(true);
    m_viewAnalysisDockAction->setChecked(m_analysisDock->isVisible());
    connect(m_viewAnalysisDockAction, &QAction::toggled, this, [this](bool checked) {
        m_analysisDock->setVisible(checked);
        });

    viewMenu->addAction(m_viewToolBarAction);
    viewMenu->addAction(m_viewLayerManagerAction);
    viewMenu->addAction(m_viewOutputDockAction);
    viewMenu->addAction(m_viewAnalysisDockAction);

    // 监听dock/toolbar关闭事件，自动更新Action的勾选状态
    connect(m_analysisDock, &QDockWidget::visibilityChanged, this, [this](bool visible) {
        if (!this->isMinimized()) // 只在主窗口不是最小化时同步
            m_viewAnalysisDockAction->setChecked(visible);
        });
    connect(m_layerTreeDock, &QDockWidget::visibilityChanged, this, [this](bool visible) {
        if (!this->isMinimized())
            m_viewLayerManagerAction->setChecked(visible);
        });
    connect(m_outputDock, &QDockWidget::visibilityChanged, this, [this](bool visible) {
        if (!this->isMinimized())
            m_viewOutputDockAction->setChecked(visible);
        });
    connect(m_toolBar, &QToolBar::visibilityChanged, this, [this](bool visible) {
        if (!this->isMinimized())
            m_viewToolBarAction->setChecked(visible);
        });


    QMenu* helpMenu = menuBar()->addMenu("帮助(&H)");

    QAction* qgisApiAction = new QAction("QGIS API", this);
    connect(qgisApiAction, &QAction::triggered, this, []() {
        QDesktopServices::openUrl(QUrl("https://docs.qgis.org/3.40/en/docs/index.html"));
        });

    QAction* qt5Action = new QAction("Qt5", this);
    connect(qt5Action, &QAction::triggered, this, []() {
        QDesktopServices::openUrl(QUrl("https://doc.qt.io/archives/qt-5.15/qtassistant-index.html"));
        });

    helpMenu->addAction(qgisApiAction);
    helpMenu->addAction(qt5Action);

}

// ---- 新的项目管理槽函数 ----

// **修改 onNewProject 函数**
// QgsProject::clear() 也会发出 crsChanged 信号，所以也无需手动调用
void QGIS_dev::onNewProject()
{
    if (maybeSave()) {
        QgsProject::instance()->clear();

        QgsCoordinateReferenceSystem defaultCrs("EPSG:4326");
        if (defaultCrs.isValid()) {
            QgsProject::instance()->setCrs(defaultCrs);
        }

        m_customLayerTreeView->clear();
        m_projectFilePath.clear();
        m_isProjectDirty = false;
        updateWindowTitle();
        updateProjectCrs();
        OutputManager::instance()->logMessage("新项目已创建，项目CRS为WGS 84。");
    }
}

void QGIS_dev::onOpenProject()
{
    if (maybeSave()) {
        QString filePath = QFileDialog::getOpenFileName(this, "打开QGIS项目", QDir::homePath(), "QGIS Projects (*.qgz *.qgs)");
        if (filePath.isEmpty()) return;

        QgsProject::instance()->clear();
        m_customLayerTreeView->clear();

        if (QgsProject::instance()->read(filePath)) {
            m_projectFilePath = filePath;

            // **项目加载后，强制将项目CRS设回WGS 84**
            QgsCoordinateReferenceSystem wgs84("EPSG:4326");
            if (wgs84.isValid()) {
                QgsProject::instance()->setCrs(wgs84);
                OutputManager::instance()->logMessage("项目已打开，并将项目CRS设置为WGS 84。");
            }
            else {
                OutputManager::instance()->logError("打开项目后无法设置WGS 84 CRS。");
            }

            rebuildLayerTreeFromProject();
            m_isProjectDirty = false;
            updateWindowTitle();
            updateProjectCrs(); // 更新UI标签
        }
        else {
            QMessageBox::critical(this, "错误", "无法读取项目文件: " + filePath);
            m_projectFilePath.clear();
            updateWindowTitle();
        }
    }
}

bool QGIS_dev::onSaveProject()
{
    if (m_projectFilePath.isEmpty()) {
        return onSaveProjectAs();
    }
    else {
        // 设置项目路径，以便QGIS保存相对路径
        QgsProject::instance()->setFileName(QFileInfo(m_projectFilePath).path());
        if (QgsProject::instance()->write(m_projectFilePath)) {
            m_isProjectDirty = false;
            updateWindowTitle();
            OutputManager::instance()->logMessage("项目已保存: " + m_projectFilePath);
            return true;
        }
        else {
            QMessageBox::critical(this, "错误", "项目保存失败！");
            return false;
        }
    }
}

bool QGIS_dev::onSaveProjectAs()
{
    QString filePath = QFileDialog::getSaveFileName(this, "项目另存为", m_projectFilePath.isEmpty() ? QDir::homePath() : m_projectFilePath, "QGIS Projects (*.qgz)");
    if (filePath.isEmpty()) return false;

    // 如果没有.qgz后缀，则添加
    if (!filePath.endsWith(".qgz", Qt::CaseInsensitive)) {
        filePath += ".qgz";
    }

    m_projectFilePath = filePath;
    return onSaveProject();
}

void QGIS_dev::onOpenLogFolder()
{
    // 获取可执行文件所在目录
    QDir exeDir = QCoreApplication::applicationDirPath(); // 修改为 QDir 类型  

    QString logDir = exeDir.filePath("logs");

    QDir dir(logDir);
    if (!dir.exists()) {
        QMessageBox::warning(this, "提示", "日志文件夹不存在: " + logDir);
        return;
    }
#if defined(Q_OS_WIN)
    QProcess::startDetached("explorer.exe", { QDir::toNativeSeparators(logDir) });
#elif defined(Q_OS_MAC)
    QProcess::startDetached("open", { logDir });
#else // Linux/Unix
    QProcess::startDetached("xdg-open", { logDir });
#endif
}

// --- 在此设置所有的工具栏 ---
void QGIS_dev::setupToolBar() 
{   
    m_saveProjectAction = new QAction("保存", this);
    m_saveProjectAction->setStatusTip("保存");
    m_saveProjectAction->setIcon(QIcon(":/QGIS_dev/resource/images/保存.png"));
    connect(m_saveProjectAction, &QAction::triggered, this, &QGIS_dev::onSaveProject);  
    
    m_openProjectAction = new QAction("打开文件", this);
    m_openProjectAction->setStatusTip("打开文件");
    m_openProjectAction->setIcon(QIcon(":/QGIS_dev/resource/images/打开文件.png"));
    connect(m_openProjectAction, &QAction::triggered, this, &QGIS_dev::onOpenProject);

    addVectorTool = new QAction("矢量", this);
    addVectorTool->setStatusTip("添加矢量数据");
    addVectorTool->setIcon(QIcon(":/QGIS_dev/resource/images/矢量数据集.png"));
    connect(addVectorTool, &QAction::triggered, this, &QGIS_dev::onAddVectorLayer);    
    
    addRasterTool = new QAction("栅格", this);
    addRasterTool->setStatusTip("添加栅格数据");
    addRasterTool->setIcon(QIcon(":/QGIS_dev/resource/images/栅格影像.png"));
    connect(addRasterTool, &QAction::triggered, this, &QGIS_dev::onAddRasterLayer);



    //--- 放大缩小工具---
    m_zoomInAction = new QAction("放大", this);
    m_zoomInAction->setStatusTip("放大");
    m_zoomInAction->setIcon(QIcon(":/QGIS_dev/resource/images/放大.png"));
    connect(m_zoomInAction, &QAction::triggered, m_mapCanvas, &MapCanvas::zoomIn);

    m_zoomOutAction = new QAction("缩小", this);
    m_zoomOutAction->setStatusTip("缩小");
    m_zoomOutAction->setIcon(QIcon(":/QGIS_dev/resource/images/缩小.png"));
    connect(m_zoomOutAction, &QAction::triggered, m_mapCanvas, &MapCanvas::zoomOut);

    // --- 地图工具 ---
    m_selectionTool = new FeatureSelectionTool(m_mapCanvas->getCanvas());

    m_panAction = new QAction("平移", this);
    m_panAction->setIcon(QIcon(":/QGIS_dev/resource/images/平移.png"));
    m_panAction->setCheckable(true); // 工具按钮是状态性的，所以设为可选中
    m_panAction->setStatusTip("平移地图");
    connect(m_panAction, &QAction::triggered, this, &QGIS_dev::onActivatePanTool);

    m_selectAction = new QAction("选择要素", this);
    m_selectAction->setIcon(QIcon(":/QGIS_dev/resource/images/选择.png"));
    m_selectAction->setCheckable(true);
    m_selectAction->setStatusTip("点击以选择要素并查看信息");
    connect(m_selectAction, &QAction::triggered, this, &QGIS_dev::onActivateSelectTool);

    // 3. 使用 QActionGroup 确保同一时间只有一个工具被激活
    m_toolActionGroup = new QActionGroup(this);
    m_toolActionGroup->addAction(m_panAction);
    m_toolActionGroup->addAction(m_selectAction);


    m_toolBar->addAction(m_saveProjectAction);
    m_toolBar->addAction(m_openProjectAction);
    m_toolBar->addSeparator();
    m_toolBar->addAction(addVectorTool);
    m_toolBar->addAction(addRasterTool);
    m_toolBar->addSeparator();
    m_toolBar->addAction(m_zoomInAction);
    m_toolBar->addAction(m_zoomOutAction);
    m_toolBar->addSeparator();
    m_toolBar->addAction(m_panAction);
    m_toolBar->addAction(m_selectAction);
}

// --- 新增：实现激活工具的槽函数 ---
void QGIS_dev::onActivatePanTool()
{
    m_mapCanvas->getCanvas()->setMapTool(m_mapCanvas->getPanTool());
}

void QGIS_dev::onActivateSelectTool()
{
    m_mapCanvas->getCanvas()->setMapTool(m_selectionTool);
}

// QGIS_dev.cpp

void QGIS_dev::onAddVectorLayer()
{
    // ... (前面的项目保存检查逻辑不变) ...
    if (m_projectFilePath.isEmpty()) {
        QMessageBox::information(this, "提示", "请先保存您的项目，然后才能添加图层。");
        if (!onSaveProjectAs()) {
            return;
        }
    }

    QString filter = "Shapefile (*.shp);;GeoPackage (*.gpkg);;All files (*.*)";
    QString sourceFilePath = QFileDialog::getOpenFileName(this, "选择一个矢量文件", QDir::homePath(), filter);

    if (sourceFilePath.isEmpty()) return;

    QString copiedFileRelativePath;
    // 复制文件到项目文件夹
    if (!copyLayerDataToProject(sourceFilePath, copiedFileRelativePath)) {
        OutputManager::instance()->logError("复制图层数据失败！");
        return;
    }

    // ================== 关键修改 ==================
    // 1. 获取复制后文件的【绝对路径】
    QDir projectDir(QFileInfo(m_projectFilePath).path());
    QString copiedFileAbsolutePath = projectDir.absoluteFilePath(copiedFileRelativePath);

    // 2. 使用【绝对路径】加载图层
    QString layerName = QFileInfo(copiedFileAbsolutePath).baseName();
    QgsVectorLayer* vectorLayer = new QgsVectorLayer(copiedFileAbsolutePath, layerName, "ogr");
    // ===============================================

    if (vectorLayer->isValid()) {
        if (vectorLayer->isValid()) {
            QgsProject::instance()->addMapLayer(vectorLayer);
            //updateProjectCrs();
            //m_mapCanvas->zoomToLayer(vectorLayer);
            m_mapCanvas->getCanvas()->zoomToFullExtent();
            OutputManager::instance()->logMessage("成功加载矢量图层: " + copiedFileAbsolutePath);
        }
        else {
            // ================== 关键修改 ==================
            // 添加错误处理，这样才能看到失败的原因
            QString errorMsg = "加载矢量图层失败: " + copiedFileAbsolutePath;
            OutputManager::instance()->logError(errorMsg);
            OutputManager::instance()->logError("错误详情: " + vectorLayer->error().message());
            delete vectorLayer; // 释放内存
            // ===============================================
        }
    }
}

void QGIS_dev::onAddRasterLayer()
{
    if (m_projectFilePath.isEmpty()) {
        QMessageBox::information(this, "提示", "请先保存您的项目，然后才能添加图层。");
        if (!onSaveProjectAs()) return;
    }

    QString filter = "GeoTIFF (*.tif *.tiff);;Erdas Imagine (*.img);;All files (*.*)";
    QString sourceFilePath = QFileDialog::getOpenFileName(this, "选择一个栅格文件", QDir::homePath(), filter);

    if (sourceFilePath.isEmpty()) return;

    QString copiedFileRelativePath;
    if (!copyLayerDataToProject(sourceFilePath, copiedFileRelativePath)) {
        QString errorString = QFile().errorString(); // 获取静态方法的返回值
        OutputManager::instance()->logError(
            QString("复制文件失败: %1 -> %2, 错误: %3")
            .arg(sourceFilePath)
            .arg(copiedFileRelativePath)
            .arg(errorString)
        );
        return;
    }

    // ================== 关键修改 ==================
    // 1. 获取复制后文件的【绝对路径】
    QDir projectDir(QFileInfo(m_projectFilePath).path());
    QString copiedFileAbsolutePath = projectDir.absoluteFilePath(copiedFileRelativePath);

    // 2. 使用【绝对路径】加载图层
    QString layerName = QFileInfo(copiedFileAbsolutePath).baseName();
    // 注意: QGIS 3.x 推荐用 "gdal" provider for rasters
    QgsRasterLayer* rasterLayer = new QgsRasterLayer(copiedFileAbsolutePath, layerName, "gdal");
    // ===============================================

    if (rasterLayer->isValid()) {
        QgsProject::instance()->addMapLayer(rasterLayer);
        updateProjectCrs();
        //m_mapCanvas->zoomToLayer(rasterLayer);
        m_mapCanvas->getCanvas()->zoomToFullExtent();
        OutputManager::instance()->logMessage("成功加载栅格图层: " + copiedFileAbsolutePath);
    }
    else {
        // ================== 关键修改 ==================
        // 添加错误处理
        QString errorMsg = "加载栅格图层失败: " + copiedFileAbsolutePath;
        OutputManager::instance()->logError(errorMsg);
        OutputManager::instance()->logError("错误详情: " + rasterLayer->error().message());
        delete rasterLayer;
        // ===============================================
    }
}

// ---- 辅助函数实现 ----

void QGIS_dev::onProjectDirty() {
    m_isProjectDirty = true;
    updateWindowTitle();
}

void QGIS_dev::updateWindowTitle() {
    QString title = m_projectFilePath.isEmpty() ? "未命名项目" : QFileInfo(m_projectFilePath).fileName();
    if (m_isProjectDirty) {
        title += "*";
    }
    title += " - My GIS App";
    setWindowTitle(title);
}

// 检查并提示保存
bool QGIS_dev::maybeSave() {
    if (!m_isProjectDirty) return true;

    const QMessageBox::StandardButton ret = QMessageBox::warning(this, "未保存的更改",
        "当前项目有未保存的更改，您想保存吗？",
        QMessageBox::Save | QMessageBox::Discard | QMessageBox::Cancel);

    if (ret == QMessageBox::Save) {
        return onSaveProject();
    }
    else if (ret == QMessageBox::Cancel) {
        return false;
    }
    return true; // Discard
}

// 关闭事件
void QGIS_dev::closeEvent(QCloseEvent* event) {
    if (maybeSave()) {
        event->accept();
    }
    else {
        event->ignore();
    }
}

// 重新构建图层树
void QGIS_dev::rebuildLayerTreeFromProject() {
    m_customLayerTreeView->clear();
    // QgsProject::mapLayers() 返回的是一个 map，值是图层指针
    // 我们需要按照图层树的顺序来添加
    QgsLayerTree* layerTree = QgsProject::instance()->layerTreeRoot();
    for (QgsLayerTreeNode* node : layerTree->children()) {
        if (node->nodeType() == QgsLayerTreeNode::NodeLayer) {
            QgsLayerTreeLayer* layerNode = static_cast<QgsLayerTreeLayer*>(node);
            m_customLayerTreeView->addLayer(layerNode->layer());
        }
    }
    // 确保画布也更新
    m_customLayerTreeView->updateMapCanvasLayers();
}

// 复制数据文件到项目目录
bool QGIS_dev::copyLayerDataToProject(const QString& sourceFilePath, QString& newRelativePath) {
    OutputManager::instance()->logMessage(QString("Attempting to copy layer data from: %1").arg(sourceFilePath));

    // 1. 检查源文件是否存在且可读
    QFileInfo sourceInfo(sourceFilePath);
    if (!sourceInfo.exists()) {
        OutputManager::instance()->logError("Source file does not exist: " + sourceFilePath);
        return false;
    }
    if (!sourceInfo.isReadable()) {
        OutputManager::instance()->logError("Source file is not readable: " + sourceFilePath);
        return false;
    }

    // 2. 构建目标目录路径
    QDir projectDir(QFileInfo(m_projectFilePath).path());
    OutputManager::instance()->logMessage("Project base directory: " + projectDir.absolutePath());

    if (!projectDir.exists("data")) {
        OutputManager::instance()->logMessage("Data directory does not exist, attempting to create...");
        if (projectDir.mkdir("data")) {
            OutputManager::instance()->logMessage("Data directory created successfully: " + projectDir.filePath("data"));
        }
        else {
            OutputManager::instance()->logError("Failed to create data directory: " + projectDir.filePath("data"));
            return false;
        }
    }
    QDir dataDir(projectDir.filePath("data"));
    if (!dataDir.exists()) { // 双重检查
        OutputManager::instance()->logError("Data directory still does not exist after attempting creation: " + dataDir.absolutePath());
        return false;
    }
    OutputManager::instance()->logMessage("Target data directory: " + dataDir.absolutePath());


    // 3. 构建目标文件路径
    QString fileName = sourceInfo.fileName();
    QString destFilePath = dataDir.filePath(fileName);
    OutputManager::instance()->logMessage(QString("Target destination file path: %1").arg(destFilePath));

    // 4. 如果目标文件已存在，先尝试删除（或者您可以选择不覆盖，直接返回错误/成功）
    if (QFile::exists(destFilePath)) {
        OutputManager::instance()->logWarning("Destination file already exists: " + destFilePath + ". Attempting to remove it.");
        if (!QFile::remove(destFilePath)) {
            OutputManager::instance()->logError("Failed to remove existing destination file: " + destFilePath + ". QFile::copy might fail.");
            // 根据您的策略，这里可以选择返回false，或者继续尝试覆盖
            // return false; 
        }
        else {
            OutputManager::instance()->logMessage("Successfully removed existing destination file.");
        }
    }

    // 5. 执行复制
    bool copySuccess = false;
    if (sourceFilePath.endsWith(".shp", Qt::CaseInsensitive)) {
        // 对于Shapefile，文件名参数应该是新的文件名（不含路径）
        QString justFileNameForShapefile = fileName;
        copySuccess = copyShapefile(sourceFilePath, dataDir.path(), justFileNameForShapefile);
        if (copySuccess) fileName = justFileNameForShapefile; // 如果copyShapefile可能修改了文件名
    }
    else {
        OutputManager::instance()->logMessage(QString("Attempting QFile::copy from '%1' to '%2'").arg(sourceFilePath).arg(destFilePath));
        if (QFile::copy(sourceFilePath, destFilePath)) {
            copySuccess = true;
            OutputManager::instance()->logMessage("QFile::copy successful.");
        }
        else {
            // 获取更详细的错误信息
            QFile tempFile(sourceFilePath); // 用一个临时QFile对象来访问errorString
            OutputManager::instance()->logError(QString("QFile::copy FAILED. Source: '%1', Dest: '%2'. Error: %3 (Code: %4)")
                .arg(sourceFilePath).arg(destFilePath)
                .arg(tempFile.errorString()).arg(tempFile.error()));
        }
    }

    if (copySuccess) {
        newRelativePath = "data/" + fileName; // 相对路径是相对于项目文件的
        OutputManager::instance()->logMessage("File copy successful. New relative path: " + newRelativePath);
        return true;
    }
    else {
        OutputManager::instance()->logError("File copy failed for: " + sourceFilePath);
        return false;
    }
}

// 专门用来复制Shapefile及其所有组件的函数
bool QGIS_dev::copyShapefile(const QString& sourceShpPath, const QString& destDir, QString& newFileName) {
    QString baseName = QFileInfo(sourceShpPath).completeBaseName();
    QDir sourceDir = QFileInfo(sourceShpPath).dir();

    QStringList extensions = { ".shp", ".shx", ".dbf", ".prj", ".cpg", ".sbn", ".sbx" };
    for (const QString& ext : extensions) {
        QString sourceFile = sourceDir.filePath(baseName + ext);
        if (QFile::exists(sourceFile)) {
            QString destFile = QDir(destDir).filePath(QFileInfo(sourceFile).fileName());
            if (QFile::exists(destFile)) QFile::remove(destFile); // 先删除以防万一
            if (!QFile::copy(sourceFile, destFile)) {
                OutputManager::instance()->logError("无法复制文件: " + sourceFile);
                return false;
            }
        }
    }
    newFileName = QFileInfo(sourceShpPath).fileName();
    return true;
}

void QGIS_dev::onCurrentLayerChanged(QgsMapLayer* layer)
{
    m_currentLayer = layer;
    // 不再需要在这里更新任何状态栏的标签。
    // 状态栏的更新应该由它们各自的事件驱动。
    // 比如坐标由鼠标移动事件驱动，比例尺由画布缩放事件驱动，CRS由项目CRS改变事件驱动。
}


// 修正 updateCoordinates，去掉对 m_currentLayer 的依赖
void QGIS_dev::updateCoordinates(const QgsPointXY& point)
{
    // 这个函数之前的版本已经是正确的了，我们保持它
    try {
        const QgsCoordinateReferenceSystem destCrs = m_mapCanvas->getCanvas()->mapSettings().destinationCrs();

        if (!destCrs.isValid()) {
            m_coordsLabel->setText("坐标: (未知坐标系)");
            return;
        }

        m_coordsLabel->setText(QString::asprintf("坐标: %.4f, %.4f", point.x(), point.y()));
    }
    catch (const std::exception& e) {
        // ... (异常处理不变) ...
    }
}


// **核心修正：彻底解耦 updateScale 与 m_currentLayer**
void QGIS_dev::updateScale(double scale)
{
    // **删除 if (!m_currentLayer) 的判断**

    if (scale <= 0) {
        m_scaleLabel->setText("比例尺: N/A");
        return;
    }

    // 直接更新比例尺标签
    m_scaleLabel->setText(QString("比例尺 1:%1").arg(static_cast<long>(scale)));
}


// updateProjectCrs 函数实现修改
void QGIS_dev::updateProjectCrs()
{
    // 项目CRS永远是WGS 84
    QgsCoordinateReferenceSystem wgs84("EPSG:4326");
    if (m_crsLabel && wgs84.isValid()) { // 确保m_crsLabel已创建
        m_crsLabel->setText(wgs84.authid()); // 例如 "EPSG:4326"
        m_crsLabel->setToolTip(QString("项目坐标参考系: %1").arg(wgs84.description()));
    }
    else if (m_crsLabel) {
        m_crsLabel->setText("CRS错误");
        m_crsLabel->setToolTip("无法设置WGS 84作为项目CRS。");
    }
}



void QGIS_dev::onAddDelimitedTextLayer()
{
    QString filePath = QFileDialog::getOpenFileName(this,
        "选择一个分隔符文本文件",
        QDir::homePath(),
        "CSV (逗号分隔) (*.csv);;文本文件 (*.txt);;所有文件 (*.*)");

    if (filePath.isEmpty()) {
        return;
    }

    // ====================== 核心加固 ======================

    // 1. 确保文件路径使用正斜杠
    QString forwardSlashPath = filePath;
    forwardSlashPath.replace('\\', '/');

    // 2. 使用 QUrl 来安全地构造URI，它会自动处理特殊字符和协议前缀
    QUrl fileUrl = QUrl::fromLocalFile(forwardSlashPath);

    // 3. 构建参数部分
    QUrlQuery query;
    query.addQueryItem("encoding", "UTF-8");
    query.addQueryItem("delimiter", ",");
    query.addQueryItem("xField", "lon");
    query.addQueryItem("yField", "lat");
    query.addQueryItem("crs", "epsg:4326");
    query.addQueryItem("spatialIndex", "yes");
    query.addQueryItem("subsetIndex", "no");
    query.addQueryItem("watchFile", "no");

    // 4. 将参数附加到URL上
    fileUrl.setQuery(query);

    // 5. 从 QUrl 获取最终的、格式正确的URI字符串
    QString uri = fileUrl.toString();

    OutputManager::instance()->logMessage("构造的URI: " + uri); // 打印URI到日志，方便调试
    // =======================================================

    QString layerName = QFileInfo(filePath).baseName();
    QgsVectorLayer* layer = new QgsVectorLayer(uri, layerName, "delimitedtext");

    if (!layer || !layer->isValid()) {
        // ... (错误信息对话框不变) ...
        // +++ 增加更详细的错误日志 +++
        OutputManager::instance()->logError("加载分隔符文本图层失败。");
        OutputManager::instance()->logError("Provider 错误: " + layer->error().message());
        delete layer;
        return;
    }

    QgsProject::instance()->addMapLayer(layer);
    m_mapCanvas->getCanvas()->zoomToFullExtent();
    OutputManager::instance()->logMessage("成功加载分隔符文本图层: " + filePath);
}
正在处理文件: RasterClipDialog.cpp
(RasterClipDialog.cpp)
// RasterClipDialog.cpp
#include "RasterClipDialog.h"
#include <QVBoxLayout>
#include <QHBoxLayout>
#include <QGridLayout>
#include <QLabel>
#include <QComboBox>
#include <QPushButton>
#include <QLineEdit>
#include <QFileDialog>
#include <QMessageBox>
#include <QStandardPaths>
#include <QFileInfo>
#include <QProcess> // +++ 用于执行命令行 +++

#include <qgsproject.h>
#include <qgsrasterlayer.h>
#include <qgsvectorlayer.h>
#include <QgsApplication.h>
#include "Output_Manager.h"
#include <QDebug>

// GDAL (可能不需要直接包含，因为我们用命令行)
// #include "gdal_priv.h"

RasterClipDialog::RasterClipDialog(QWidget* parent)
    : QDialog(parent)
{
    setWindowTitle("栅格裁剪 (按矢量边界)");
    setMinimumWidth(550);
    setupUI();
    populateInputRasterComboBox();
    populateClipFeatureComboBox();
}

RasterClipDialog::~RasterClipDialog()
{
}

void RasterClipDialog::setupUI()
{
    QVBoxLayout* mainLayout = new QVBoxLayout(this);
    QGridLayout* gridLayout = new QGridLayout();

    // 1. 输入栅格
    gridLayout->addWidget(new QLabel("输入栅格图层:", this), 0, 0);
    m_inputRasterCombo = new QComboBox(this);
    gridLayout->addWidget(m_inputRasterCombo, 0, 1);
    m_btnSelectInputRasterFile = new QPushButton("从文件...", this);
    gridLayout->addWidget(m_btnSelectInputRasterFile, 0, 2);
    m_lblSelectedRasterInfo = new QLabel("当前选择: 无", this);
    gridLayout->addWidget(m_lblSelectedRasterInfo, 1, 0, 1, 3);

    // 2. 裁剪矢量边界
    gridLayout->addWidget(new QLabel("裁剪边界 (矢量面):", this), 2, 0);
    m_clipFeatureCombo = new QComboBox(this);
    gridLayout->addWidget(m_clipFeatureCombo, 2, 1);
    m_btnSelectClipFeatureFile = new QPushButton("从文件...", this);
    gridLayout->addWidget(m_btnSelectClipFeatureFile, 2, 2);
    m_lblSelectedClipFeatureInfo = new QLabel("当前选择: 无", this);
    gridLayout->addWidget(m_lblSelectedClipFeatureInfo, 3, 0, 1, 3);

    // 3. 输出栅格路径
    gridLayout->addWidget(new QLabel("输出裁剪后栅格:", this), 4, 0);
    m_editOutputRasterPath = new QLineEdit(this);
    m_editOutputRasterPath->setPlaceholderText("选择输出文件路径...");
    gridLayout->addWidget(m_editOutputRasterPath, 4, 1);
    m_btnSelectOutputRaster = new QPushButton("浏览...", this);
    gridLayout->addWidget(m_btnSelectOutputRaster, 4, 2);

    // ====================== 新增NoData处理选项 ======================
    m_lblOutputNoDataHandling = new QLabel("边界外区域处理:", this);
    gridLayout->addWidget(m_lblOutputNoDataHandling, 5, 0); // 行号调整为5

    m_comboNoDataHandling = new QComboBox(this);
    m_comboNoDataHandling->addItem("填充为黑色 (NoData=0)", "black"); // "black" 是我们内部用的标识
    m_comboNoDataHandling->addItem("设为透明 (Alpha波段)", "alpha");
    gridLayout->addWidget(m_comboNoDataHandling, 5, 1, 1, 2);
    // ===============================================================

    mainLayout->addLayout(gridLayout);
    mainLayout->addStretch();

    // 4. 按钮
    QHBoxLayout* buttonLayout = new QHBoxLayout();
    buttonLayout->addStretch();
    m_btnOk = new QPushButton("确定", this);
    m_btnCancel = new QPushButton("取消", this);
    buttonLayout->addWidget(m_btnOk);
    buttonLayout->addWidget(m_btnCancel);
    mainLayout->addLayout(buttonLayout);

    setLayout(mainLayout);

    // 连接信号
    connect(m_inputRasterCombo, QOverload<int>::of(&QComboBox::currentIndexChanged), this, [this](int index) {
        m_currentInputRasterPath.clear(); // 清除文件路径选择
        if (index > 0) {
            QVariant data = m_inputRasterCombo->itemData(index);
            QgsRasterLayer* layer = qvariant_cast<QgsRasterLayer*>(data);
            if (layer && QgsProject::instance()->mapLayer(layer->id())) {
                m_currentInputRasterPath = layer->source();
                m_lblSelectedRasterInfo->setText(QString("当前选择: %1 (项目)").arg(layer->name()));
            }
        }
        else {
            m_lblSelectedRasterInfo->setText("当前选择: 无");
        }
        // (可以添加更新默认输出名的逻辑)
        });
    connect(m_btnSelectInputRasterFile, &QPushButton::clicked, this, &RasterClipDialog::onSelectInputRasterClicked);

    connect(m_clipFeatureCombo, QOverload<int>::of(&QComboBox::currentIndexChanged), this, [this](int index) {
        m_currentClipFeaturePath.clear();
        if (index > 0) {
            QVariant data = m_clipFeatureCombo->itemData(index);
            QgsVectorLayer* layer = qvariant_cast<QgsVectorLayer*>(data);
            if (layer && QgsProject::instance()->mapLayer(layer->id())) {
                m_currentClipFeaturePath = layer->source();
                m_lblSelectedClipFeatureInfo->setText(QString("当前选择: %1 (项目)").arg(layer->name()));
            }
        }
        else {
            m_lblSelectedClipFeatureInfo->setText("当前选择: 无");
        }
        // (更新默认输出名)
        });
    connect(m_btnSelectClipFeatureFile, &QPushButton::clicked, this, &RasterClipDialog::onSelectClipFeatureClicked);
    connect(m_btnSelectOutputRaster, &QPushButton::clicked, this, &RasterClipDialog::onSelectOutputRasterClicked);
    connect(m_btnOk, &QPushButton::clicked, this, &RasterClipDialog::onOkClicked);
    connect(m_btnCancel, &QPushButton::clicked, this, &QDialog::reject);
}

void RasterClipDialog::populateInputRasterComboBox()
{
    m_inputRasterCombo->clear();
    m_inputRasterCombo->addItem("--- 从项目中选择栅格 ---", QVariant());
    QList<QgsMapLayer*> layers = QgsProject::instance()->mapLayers().values();
    for (QgsMapLayer* layer : layers) {
            if (auto rasterLayer = qobject_cast<QgsRasterLayer*>(layer)) {
                m_inputRasterCombo->addItem(rasterLayer->name(), QVariant::fromValue(rasterLayer));
            }
    }
}

void RasterClipDialog::populateClipFeatureComboBox()
{
    m_clipFeatureCombo->clear();
    m_clipFeatureCombo->addItem("--- 从项目中选择矢量面 ---", QVariant());
    QList<QgsMapLayer*> layers = QgsProject::instance()->mapLayers().values();
    for (QgsMapLayer* layer : layers) {
            if (auto vectorLayer = qobject_cast<QgsVectorLayer*>(layer)) {
                if (vectorLayer->geometryType() == Qgis::GeometryType::Polygon) { // 只显示面图层
                    m_clipFeatureCombo->addItem(vectorLayer->name(), QVariant::fromValue(vectorLayer));
                }
            }
    }
}

void RasterClipDialog::onSelectInputRasterClicked()
{
    QString filePath = QFileDialog::getOpenFileName(this, "选择输入栅格文件",
        QStandardPaths::writableLocation(QStandardPaths::HomeLocation),
        "栅格文件 (*.tif *.tiff *.img);;所有文件 (*.*)");
    if (!filePath.isEmpty()) {
        m_currentInputRasterPath = filePath;
        m_lblSelectedRasterInfo->setText(QString("当前选择: %1 (文件)").arg(QFileInfo(filePath).fileName()));
        m_inputRasterCombo->setCurrentIndex(0);
    }
}

void RasterClipDialog::onSelectClipFeatureClicked()
{
    QString filePath = QFileDialog::getOpenFileName(this, "选择裁剪边界矢量文件",
        QStandardPaths::writableLocation(QStandardPaths::HomeLocation),
        "Shapefile (*.shp);;GeoPackage (*.gpkg);;所有矢量文件 (*.*)");
    if (!filePath.isEmpty()) {
        m_currentClipFeaturePath = filePath;
        m_lblSelectedClipFeatureInfo->setText(QString("当前选择: %1 (文件)").arg(QFileInfo(filePath).fileName()));
        m_clipFeatureCombo->setCurrentIndex(0);
    }
}

void RasterClipDialog::onSelectOutputRasterClicked()
{
    QString defaultPath = QStandardPaths::writableLocation(QStandardPaths::HomeLocation);
    if (!m_currentInputRasterPath.isEmpty()) {
        QFileInfo fi(m_currentInputRasterPath);
        defaultPath = QDir(fi.absolutePath()).filePath(fi.completeBaseName() + "_clipped.tif");
    }

    QString filePath = QFileDialog::getSaveFileName(this, "选择输出裁剪后栅格路径",
        defaultPath,
        "GeoTIFF (*.tif *.tiff)");
    if (!filePath.isEmpty()) {
        if (QFileInfo(filePath).suffix().compare("tif", Qt::CaseInsensitive) != 0 &&
            QFileInfo(filePath).suffix().compare("tiff", Qt::CaseInsensitive) != 0) {
            filePath += ".tif";
        }
        m_editOutputRasterPath->setText(filePath);
    }
}

void RasterClipDialog::onOkClicked()
{
    QString inputRaster = m_currentInputRasterPath;
    QString clipFeatures = m_currentClipFeaturePath;
    QString outputRaster = m_editOutputRasterPath->text();

    if (inputRaster.isEmpty()) { QMessageBox::warning(this, "输入错误", "请选择输入栅格图层。"); return; }
    if (clipFeatures.isEmpty()) { QMessageBox::warning(this, "输入错误", "请选择裁剪边界矢量图层。"); return; }
    if (outputRaster.isEmpty()) { QMessageBox::warning(this, "输入错误", "请输入输出栅格路径。"); return; }

    qDebug() << "Starting raster clip operation:";
    qDebug() << "  Input Raster:" << inputRaster;
    qDebug() << "  Clip Features:" << clipFeatures;
    qDebug() << "  Output Raster:" << outputRaster;

    // ====================== 执行GDAL Warp命令行 ======================
    QStringList arguments;
    arguments << "-cutline" << clipFeatures; // 指定裁剪矢量
    arguments << "-crop_to_cutline";         // 选项：输出范围严格按照cutline的范围

    // ====================== 根据用户选择添加NoData处理参数 ======================
    QString noDataHandling = m_comboNoDataHandling->currentData().toString();
    qDebug() << "  NoData Handling selection:" << noDataHandling;

    if (noDataHandling == "alpha") {
        arguments << "-dstalpha"; // 创建alpha波段使边界外透明
        // 当使用 -dstalpha 时，通常不需要再明确设置 -dstnodata，
        // 因为透明区域自然就是没有数据。
        // 如果原始栅格有NoData值，gdalwarp会尝试保留它们。
        // 如果想强制所有非裁剪区都是一个特定的NoData值（除了透明），可以考虑：
        // arguments << "-srcnodata" << " profiled_nodata_value_from_source "; // 如果源有明确NoData
        // arguments << "-dstnodata" << "0"; // 并将输出的NoData设为0 (但会被alpha覆盖)
    }
    else if (noDataHandling == "black") {
        // 填充为黑色，意味着我们将NoData值设为0
        // 我们需要告诉gdalwarp，输出栅格的NoData值是0。
        // 如果源栅格有不同的NoData值，我们可能需要先用-srcnodata告诉gdalwarp源的NoData是什么，
        // 然后用-dstnodata指定输出的NoData。
        // 为了简单起见，我们直接设置输出的NoData为0。
        // 如果源栅格本身有些区域是0，并且0不是它的NoData值，那么这些区域会被保留为0。
        // 裁剪边界之外的区域，gdalwarp在-crop_to_cutline时会用目标NoData值填充。
        arguments << "-dstnodata" << "0";
        // arguments << "-srcnodata" << " profiled_nodata_value_from_source "; // 可选，如果需要更精确控制
    }
    // =======================================================================


    // arguments << "-of" << "GTiff";        // 可选：指定输出格式 (gdalwarp通常能从输出文件名推断)
    // arguments << "-co" << "COMPRESS=LZW"; // 可选：创建选项
    // arguments << "-co" << "TILED=YES";

    arguments << inputRaster;                // 输入栅格文件
    arguments << outputRaster;               // 输出栅格文件

    // 找到 gdalwarp.exe 的路径
    // 理想情况下，这个路径应该通过环境变量或配置获得
    // 为了简单，我们假设它在应用程序的prefixPath的bin目录下（OSGeo4W环境）
    QString gdalwarpPath = QDir(QgsApplication::prefixPath()).filePath("bin/gdalwarp.exe");
    if (!QFile::exists(gdalwarpPath)) {
        // 尝试直接调用，希望它在系统PATH中
        gdalwarpPath = "gdalwarp";
        qWarning() << "gdalwarp.exe not found in prefix/bin, trying system PATH.";
    }

    QProcess process;
    qDebug() << "Executing:" << gdalwarpPath << arguments;
    process.start(gdalwarpPath, arguments);

    // 等待完成 (可以设置超时)
    if (!process.waitForFinished(-1)) { // -1 表示无限等待
        QMessageBox::critical(this, "错误", "gdalwarp进程执行失败: " + process.errorString());
        OutputManager::instance()->logError("gdalwarp error: " + process.readAllStandardError());
        return;
    }

    if (process.exitCode() != 0) {
        QMessageBox::critical(this, "裁剪失败", "gdalwarp操作返回错误码: " + QString::number(process.exitCode()) +
            "\n\n错误输出:\n" + process.readAllStandardError() +
            "\n\n标准输出:\n" + process.readAllStandardOutput());
        return;
    }
    // =================================================================

    QMessageBox::information(this, "成功", "栅格裁剪完成！\n输出文件: " + outputRaster);

    // 自动加载结果图层到项目中
    QgsRasterLayer* newLayer = new QgsRasterLayer(outputRaster, QFileInfo(outputRaster).baseName());
    if (newLayer->isValid()) {
        QgsProject::instance()->addMapLayer(newLayer);
        // 可以让主窗口的地图缩放到新图层
        // emit operationCompletedAndLayerAdded(newLayer); // 如果需要通知主窗口
    }
    else {
        QMessageBox::warning(this, "警告", "裁剪结果已生成，但加载到地图失败。\n" + newLayer->error().message());
        delete newLayer;
    }
    accept();
}
正在处理文件: RasterLayerPropertiesDialog.cpp
(RasterLayerPropertiesDialog.cpp)
// RasterLayerPropertiesDialog.cpp
#include "RasterLayerPropertiesDialog.h"
#include <qgsrasterlayer.h>
#include <qgscoordinatereferencesystem.h>
#include <qgsrectangle.h>
#include <qgsrasterbandstats.h>
#include "gdal_priv.h"
#include "cpl_conv.h"
#include <QVBoxLayout>
#include <QLabel>
#include <QTableWidget>
#include <QTextEdit>
#include <QHeaderView>
#include <QGroupBox>
#include <QDebug>
#include <QPushButton>
#include <QFile>

RasterLayerPropertiesDialog::RasterLayerPropertiesDialog(QgsRasterLayer* layer, QWidget* parent)
    : QDialog(parent), m_rasterLayer(layer)
{
    if (!m_rasterLayer || !m_rasterLayer->isValid()) {
        qWarning() << "RasterLayerPropertiesDialog created with invalid layer.";
        // 如果在构造时就出错，最好不要继续执行setupUI，可以简单地reject
        // QTimer::singleShot(0, this, &QDialog::reject); // 异步关闭，避免在构造中直接reject可能的问题
        return; // 或者直接返回，让调用者检查并处理
    }

    setWindowTitle(QString("栅格图层属性 - %1").arg(m_rasterLayer->name()));
    resize(700, 650); // 尝试一个更大的尺寸
    setupUI();
    populateGeneralInfo();
    populateAllBandStatistics(); // 初始化时就显示所有波段统计
}

RasterLayerPropertiesDialog::~RasterLayerPropertiesDialog()
{
}

void RasterLayerPropertiesDialog::setupUI()
{
    QVBoxLayout* mainLayout = new QVBoxLayout(this);

    // --- 1. 基本信息组 ---
    QGroupBox* infoGroup = new QGroupBox("基本信息", this);
    QVBoxLayout* infoLayout = new QVBoxLayout(infoGroup);
    m_infoTableWidget = new QTableWidget(this);
    m_infoTableWidget->setColumnCount(2);
    m_infoTableWidget->setHorizontalHeaderLabels({ "属性", "值" });

    m_infoTableWidget->horizontalHeader()->setSectionResizeMode(0, QHeaderView::ResizeToContents); // “属性”列根据内容自动调整
    m_infoTableWidget->horizontalHeader()->setSectionResizeMode(1, QHeaderView::Stretch);       // “值”列自动拉伸填充

    m_infoTableWidget->horizontalHeader()->setStretchLastSection(true);
    m_infoTableWidget->verticalHeader()->setVisible(false);
    m_infoTableWidget->setEditTriggers(QAbstractItemView::NoEditTriggers);
    m_infoTableWidget->setSelectionMode(QAbstractItemView::NoSelection);
    infoLayout->addWidget(m_infoTableWidget);
    infoGroup->setLayout(infoLayout);
    mainLayout->addWidget(infoGroup);

    // --- 2. 所有波段统计信息组 ---
    QGroupBox* allStatsGroup = new QGroupBox("所有波段统计", this);
    QVBoxLayout* allStatsLayout = new QVBoxLayout(allStatsGroup);
    m_allBandStatsTextEdit = new QTextEdit(this);
    m_allBandStatsTextEdit->setReadOnly(true);

    // 调整字体
    QFont statsFont("Courier", 9); // 使用Courier字体（等宽），字号设为9
    m_allBandStatsTextEdit->setFont(statsFont);
    // 或者只改变字号:
    // QFont currentFont = m_allBandStatsTextEdit->font();
    // currentFont.setPointSize(9); // 设置一个较小的字号
    // m_allBandStatsTextEdit->setFont(currentFont);

    allStatsLayout->addWidget(m_allBandStatsTextEdit);
    allStatsGroup->setLayout(allStatsLayout);
    mainLayout->addWidget(allStatsGroup);

    mainLayout->addStretch(); // 确保内容靠上

    // (可选) 添加一个关闭按钮
    QHBoxLayout* buttonLayout = new QHBoxLayout();
    buttonLayout->addStretch();
    QPushButton* closeButton = new QPushButton("关闭", this);
    connect(closeButton, &QPushButton::clicked, this, &QDialog::accept);
    buttonLayout->addWidget(closeButton);
    mainLayout->addLayout(buttonLayout);

    setLayout(mainLayout);
}

void RasterLayerPropertiesDialog::populateGeneralInfo()
{
    if (!m_rasterLayer) return;

    m_infoTableWidget->setRowCount(0); // 清空旧内容

    auto addInfoRow = [&](const QString& label, const QString& value) {
        int row = m_infoTableWidget->rowCount();
        m_infoTableWidget->insertRow(row);
        m_infoTableWidget->setItem(row, 0, new QTableWidgetItem(label));
        m_infoTableWidget->setItem(row, 1, new QTableWidgetItem(value));
        };

    addInfoRow("名称:", m_rasterLayer->name());
    addInfoRow("路径:", m_rasterLayer->source());
    addInfoRow("宽度 (列):", QString::number(m_rasterLayer->width()));
    addInfoRow("高度 (行):", QString::number(m_rasterLayer->height()));
    addInfoRow("波段数量:", QString::number(m_rasterLayer->bandCount()));

    QgsCoordinateReferenceSystem crs = m_rasterLayer->crs();
    if (crs.isValid()) {
        addInfoRow("坐标参考系:", QString("%1 (%2)").arg(crs.description()).arg(crs.authid()));
    }
    else {
        addInfoRow("坐标参考系:", "未知");
    }

    QgsRectangle extent = m_rasterLayer->extent();
    if (!extent.isEmpty()) {
        addInfoRow("范围 (XMin):", QString::number(extent.xMinimum()));
        addInfoRow("范围 (YMin):", QString::number(extent.yMinimum()));
        addInfoRow("范围 (XMax):", QString::number(extent.xMaximum()));
        addInfoRow("范围 (YMax):", QString::number(extent.yMaximum()));
    }
    else {
        addInfoRow("范围:", "未知");
    }
    m_infoTableWidget->resizeColumnsToContents();
}

void RasterLayerPropertiesDialog::populateAllBandStatistics()
{
    if (!m_rasterLayer) return;

    m_allBandStatsTextEdit->clear();
    QString statsTextAccumulator; // 用于累积所有波段的文本

    // 获取栅格文件的完整路径
    QString rasterFilePath = m_rasterLayer->source();
    if (rasterFilePath.isEmpty() || !QFile::exists(rasterFilePath)) {
        statsTextAccumulator = "错误：无法获取有效的栅格文件路径。";
        m_allBandStatsTextEdit->setText(statsTextAccumulator);
        return;
    }

    qDebug() << "Populating all band statistics using GDAL for:" << rasterFilePath;

    // 注册所有GDAL驱动 (通常在QgsApplication::initQgis()中已完成，但再次调用无害)
    GDALAllRegister();

    // 打开栅格数据集
    GDALDataset* poDataset = (GDALDataset*)GDALOpen(rasterFilePath.toUtf8().constData(), GA_ReadOnly);
    if (poDataset == nullptr) {
        statsTextAccumulator = QString("GDAL错误：无法打开栅格文件。\n%1").arg(CPLGetLastErrorMsg());
        m_allBandStatsTextEdit->setText(statsTextAccumulator);
        return;
    }

    int numBands = poDataset->GetRasterCount();
    if (numBands == 0) {
        statsTextAccumulator = "错误：栅格文件不包含任何波段。";
        m_allBandStatsTextEdit->setText(statsTextAccumulator);
        GDALClose(poDataset);
        return;
    }

    // 遍历所有波段
    for (int i = 1; i <= numBands; ++i) {
        statsTextAccumulator += QString("--- 波段 %1 ---\n").arg(i);

        GDALRasterBand* poBand = poDataset->GetRasterBand(i);
        if (poBand == nullptr) {
            statsTextAccumulator += QString("  错误：无法获取波段 %1 的数据。\n\n").arg(i);
            continue; // 继续下一个波段
        }

        // 尝试获取元数据中的统计值，或进行近似计算
        double dfMin = 0.0, dfMax = 0.0, dfMean = 0.0, dfStdDev = 0.0;
        int bSuccessMin, bSuccessMax;

        dfMin = poBand->GetMinimum(&bSuccessMin);
        dfMax = poBand->GetMaximum(&bSuccessMax);

        // 如果元数据中没有Min/Max，或者获取失败，则计算近似值
        if (!bSuccessMin || !bSuccessMax) {
            qDebug() << "Band" << i << ": No Min/Max in metadata, computing (approximate)...";
            // ComputeRasterMinMax的第二个参数是输出数组，第一个是Min，第二个是Max
            double adfMinMax[2];
            if (poBand->ComputeRasterMinMax(TRUE, adfMinMax) == CE_None) { // TRUE for ApproxOK
                dfMin = adfMinMax[0];
                dfMax = adfMinMax[1];
            }
            else {
                qDebug() << "GDAL ComputeRasterMinMax for band" << i << "FAILED:" << CPLGetLastErrorMsg();
            }
        }

        // 尝试获取均值和标准差 (GetStatistics会尝试从元数据读取，如果不存在则计算)
        // 第一个参数 bApproxOK 设为 TRUE
        if (poBand->GetStatistics(TRUE, TRUE, &dfMin, &dfMax, &dfMean, &dfStdDev) == CE_Failure) {
            qDebug() << "GDAL GetStatistics for band" << i << "FAILED: " << CPLGetLastErrorMsg();
            // 作为后备，再尝试一次 ComputeStatistics (近似)
            if (poBand->ComputeStatistics(TRUE, &dfMean, &dfStdDev, nullptr, nullptr, nullptr, nullptr) == CE_Failure) {
                qDebug() << "GDAL ComputeStatistics (fallback) for band" << i << "FAILED: " << CPLGetLastErrorMsg();
            }
        }

        // 获取NoData值
        int bGotNoData;
        double nodataValue = poBand->GetNoDataValue(&bGotNoData);

        statsTextAccumulator += QString("  最小值: %1\n").arg(dfMin);
        statsTextAccumulator += QString("  最大值: %1\n").arg(dfMax);
        statsTextAccumulator += QString("  平均值: %1\n").arg(dfMean);
        statsTextAccumulator += QString("  标准差: %1\n").arg(dfStdDev);
        if (bGotNoData) {
            statsTextAccumulator += QString("  NoData值: %1\n").arg(nodataValue);
        }
        statsTextAccumulator += "\n";
    }

    GDALClose(poDataset); // 关闭数据集
    m_allBandStatsTextEdit->setText(statsTextAccumulator);
}
正在处理文件: ReprojectRasterDialog.cpp
(ReprojectRasterDialog.cpp)
#include "ReprojectRasterDialog.h"
#include <QVBoxLayout>
#include <QHBoxLayout>
#include <QGridLayout>
#include <QLabel>
#include <QComboBox>
#include <QPushButton>
#include <QLineEdit>
#include <QFileDialog>
#include <QMessageBox>
#include <QStandardPaths>
#include <QFileInfo>

#include <qgsproject.h>
#include <qgsrasterlayer.h>
#include "Output_Manager.h"
#include <QDebug>

// GDAL
#include "gdal_priv.h"
#include "gdalwarper.h"
#include "cpl_conv.h"
#include "cpl_string.h"
#include "ogr_spatialref.h"


ReprojectRasterDialog::ReprojectRasterDialog(QWidget* parent)
    : QDialog(parent),
    // +++ 明确初始化所有指针成员为 nullptr +++
    m_inputRasterCombo(nullptr),
    m_btnSelectInputRasterFile(nullptr),
    m_lblSelectedRasterInfo(nullptr),
    m_lblCurrentCrsInfo(nullptr),
    m_lblTargetCrs(nullptr),
    m_targetCrsCombo(nullptr),
    m_editOutputRasterPath(nullptr),
    m_btnSelectOutputRaster(nullptr),
    m_btnOk(nullptr),
    m_btnCancel(nullptr)
    // m_currentTargetCrs 会被默认构造
{
    setWindowTitle("栅格投影转换");
    setMinimumWidth(550);

    setupUI(); // 创建并布局所有UI控件

    populateInputRasterComboBox();
    populateTargetCrsComboBox();

    // --- 将所有 connect 语句集中到构造函数的末尾 ---
    // 确保此时所有UI控件都已创建完毕
    if (m_inputRasterCombo) { // 防御性检查
        connect(m_inputRasterCombo, QOverload<int>::of(&QComboBox::currentIndexChanged), this, &ReprojectRasterDialog::onInputRasterChanged);
    }
    if (m_targetCrsCombo) { // 防御性检查
        connect(m_targetCrsCombo, QOverload<int>::of(&QComboBox::currentIndexChanged), this, &ReprojectRasterDialog::onTargetCrsComboChanged);
    }
    if (m_btnSelectInputRasterFile) { // 防御性检查
        connect(m_btnSelectInputRasterFile, &QPushButton::clicked, this, &ReprojectRasterDialog::onSelectInputRasterClicked);
    }
    if (m_btnSelectOutputRaster) { // 防御性检查
        connect(m_btnSelectOutputRaster, &QPushButton::clicked, this, &ReprojectRasterDialog::onSelectOutputRasterClicked);
    }
    if (m_btnOk) { // 防御性检查
        connect(m_btnOk, &QPushButton::clicked, this, &ReprojectRasterDialog::onOkClicked);
    }
    if (m_btnCancel) { // 防御性检查
        connect(m_btnCancel, &QPushButton::clicked, this, &QDialog::reject);
    }
}

ReprojectRasterDialog::~ReprojectRasterDialog()
{
    // 如果有资源需要释放，可以在这里添加代码
}

void ReprojectRasterDialog::setupUI()
{
    // === 1. 创建布局 ===
    QVBoxLayout* mainLayout = new QVBoxLayout(this);
    QGridLayout* gridLayout = new QGridLayout();

    // === 2. 创建所有UI控件 (严格按照先new再使用的顺序) ===
    // 输入栅格
    QLabel* lblInputRaster = new QLabel("输入栅格图层:", this);
    m_inputRasterCombo = new QComboBox(this);
    m_btnSelectInputRasterFile = new QPushButton("从文件...", this);
    m_lblSelectedRasterInfo = new QLabel("当前选择: 无", this);
    m_lblCurrentCrsInfo = new QLabel("源CRS: 未知", this);

    // 目标CRS选择
    m_lblTargetCrs = new QLabel("选择目标CRS:", this);
    m_targetCrsCombo = new QComboBox(this);

    // 输出栅格路径
    QLabel* lblOutputPath = new QLabel("输出栅格路径:", this);
    m_editOutputRasterPath = new QLineEdit(this);
    m_editOutputRasterPath->setPlaceholderText("选择输出文件路径...");
    m_btnSelectOutputRaster = new QPushButton("浏览...", this);

    // 确定和取消按钮
    m_btnOk = new QPushButton("确定", this);
    m_btnCancel = new QPushButton("取消", this);

    // === 3. 将控件添加到布局中 ===
    gridLayout->addWidget(lblInputRaster, 0, 0);
    gridLayout->addWidget(m_inputRasterCombo, 0, 1);
    gridLayout->addWidget(m_btnSelectInputRasterFile, 0, 2);
    gridLayout->addWidget(m_lblSelectedRasterInfo, 1, 0, 1, 3);
    gridLayout->addWidget(m_lblCurrentCrsInfo, 2, 0, 1, 3);

    gridLayout->addWidget(m_lblTargetCrs, 3, 0);
    gridLayout->addWidget(m_targetCrsCombo, 3, 1, 1, 2);

    gridLayout->addWidget(lblOutputPath, 4, 0);
    gridLayout->addWidget(m_editOutputRasterPath, 4, 1);
    gridLayout->addWidget(m_btnSelectOutputRaster, 4, 2);

    mainLayout->addLayout(gridLayout);
    mainLayout->addStretch();

    QHBoxLayout* buttonLayout = new QHBoxLayout();
    buttonLayout->addStretch();
    buttonLayout->addWidget(m_btnOk);
    buttonLayout->addWidget(m_btnCancel);
    mainLayout->addLayout(buttonLayout);

    setLayout(mainLayout);

    // **注意：将connect语句移到构造函数的末尾，在所有控件创建之后**
}

void ReprojectRasterDialog::populateInputRasterComboBox()
{
    m_inputRasterCombo->clear();
    m_inputRasterCombo->addItem("--- 从项目中选择栅格 ---", QVariant());
    QList<QgsMapLayer*> layers = QgsProject::instance()->mapLayers().values();
    for (QgsMapLayer* layer : layers) {
            if (auto rasterLayer = qobject_cast<QgsRasterLayer*>(layer)) {
                m_inputRasterCombo->addItem(rasterLayer->name() + QString(" (%1)").arg(rasterLayer->crs().authid().isEmpty() ? "未知CRS" : rasterLayer->crs().authid()),
                    QVariant::fromValue(rasterLayer));
            }
    }
    onInputRasterChanged(0); // 更新初始状态
}


// +++ 新增：填充目标CRS下拉框的函数 +++
void ReprojectRasterDialog::populateTargetCrsComboBox()
{
    m_targetCrsCombo->clear();
    // 添加一些常见的CRS
    // 格式: 显示名称, QVariant(EPSG字符串)
    m_targetCrsCombo->addItem("WGS 84 (EPSG:4326)", "EPSG:4326");
    m_targetCrsCombo->addItem("Web Mercator (EPSG:3857)", "EPSG:3857");
    m_targetCrsCombo->addItem("CGCS2000 (EPSG:4490)", "EPSG:4490");
    m_targetCrsCombo->addItem("UTM Zone 48N (WGS84, EPSG:32648)", "EPSG:32648");
    m_targetCrsCombo->addItem("UTM Zone 49N (WGS84, EPSG:32649)", "EPSG:32649");
    m_targetCrsCombo->addItem("UTM Zone 50N (WGS84, EPSG:32650)", "EPSG:32650");
    m_targetCrsCombo->addItem("UTM Zone 51N (WGS84, EPSG:32651)", "EPSG:32651");
    // 可以根据需要添加更多

    // 默认选中第一个，并更新成员变量
    if (m_targetCrsCombo->count() > 0) {
        onTargetCrsComboChanged(0); // 触发更新 m_currentTargetCrs 和默认输出路径
    }
}


void ReprojectRasterDialog::onSelectInputRasterClicked()
{
    QString filePath = QFileDialog::getOpenFileName(this, "选择输入栅格文件",
        QStandardPaths::writableLocation(QStandardPaths::HomeLocation),
        "栅格文件 (*.tif *.tiff *.img);;所有文件 (*.*)");
    if (!filePath.isEmpty()) {
        m_currentInputRasterPath = filePath;
        m_lblSelectedRasterInfo->setText(QString("当前选择: %1 (文件)").arg(QFileInfo(filePath).fileName()));
        m_inputRasterCombo->setCurrentIndex(0);

        // 尝试读取文件CRS
        QgsRasterLayer tempLayer(filePath);
        if (tempLayer.isValid()) {
            QgsCoordinateReferenceSystem crs = tempLayer.crs();
            m_lblCurrentCrsInfo->setText(QString("源CRS: %1").arg(crs.isValid() ? crs.description() : "未知/无法读取"));
        }
        else {
            m_lblCurrentCrsInfo->setText("源CRS: 无法读取");
        }
        updateDefaultOutputPath();
    }
}

void ReprojectRasterDialog::onInputRasterChanged(int index)
{
    if (index > 0) { // 从项目中选择
        QVariant data = m_inputRasterCombo->itemData(index);
        QgsRasterLayer* layer = qvariant_cast<QgsRasterLayer*>(data);
        if (layer && QgsProject::instance()->mapLayer(layer->id())) {
            m_currentInputRasterPath = layer->source();
            m_lblSelectedRasterInfo->setText(QString("当前选择: %1 (项目)").arg(layer->name()));
            QgsCoordinateReferenceSystem crs = layer->crs();
            m_lblCurrentCrsInfo->setText(QString("源CRS: %1").arg(crs.isValid() ? crs.description() : "未知"));
        }
    }
    else {
        // 如果选择了 "---选择---" 但之前文件路径有值，保留文件路径的信息
        if (m_currentInputRasterPath.isEmpty() || !m_lblSelectedRasterInfo->text().contains("(文件)")) {
            m_currentInputRasterPath.clear();
            m_lblSelectedRasterInfo->setText("当前选择: 无");
            m_lblCurrentCrsInfo->setText("源CRS: 未知");
        }
    }
    updateDefaultOutputPath();
}


// +++ 新增：当目标CRS下拉框选项改变时 +++
void ReprojectRasterDialog::onTargetCrsComboChanged(int index)
{
    if (index >= 0) {
        QString epsgString = m_targetCrsCombo->itemData(index).toString();
        m_currentTargetCrs.createFromString(epsgString); // 更新成员变量
        if (!m_currentTargetCrs.isValid()) {
            qWarning() << "Failed to create target CRS from string:" << epsgString;
        }
    }
    else {
        m_currentTargetCrs = QgsCoordinateReferenceSystem(); // 设为无效
    }
    updateDefaultOutputPath(); // 目标CRS变了，默认输出名也可能要变
}


void ReprojectRasterDialog::updateDefaultOutputPath()
{
    if (m_currentInputRasterPath.isEmpty()) {
        m_editOutputRasterPath->clear();
        return;
    }

    QFileInfo fi(m_currentInputRasterPath);
    QString baseName = fi.completeBaseName();
    QString dirPath = fi.absolutePath();
    QString suffix = fi.suffix();

    QString crsSuffix = "reprojected";
    if (m_currentTargetCrs.isValid() && !m_currentTargetCrs.authid().isEmpty()) {
        crsSuffix = m_currentTargetCrs.authid().replace(":", "_");
    }
    else if (m_currentTargetCrs.isValid()) {
        // 如果没有authid但有效，可以用描述的一部分（需要处理特殊字符）
        QString desc = m_currentTargetCrs.description().simplified().replace(" ", "_").remove(QRegExp("[^a-zA-Z0-9_]"));
        crsSuffix = desc.left(15); // 取前15个字符
    }


    QString defaultOutputName = QString("%1_%2.%3").arg(baseName).arg(crsSuffix).arg(suffix.isEmpty() ? "tif" : suffix);
    m_editOutputRasterPath->setText(QDir(dirPath).filePath(defaultOutputName));
}

void ReprojectRasterDialog::onSelectOutputRasterClicked()
{
    // ... (与ResampleDialog中的实现类似，确保有默认后缀) ...
    QString defaultPath = m_editOutputRasterPath->text();
    // ... (获取并设置路径) ...
    QString filePath = QFileDialog::getSaveFileName(this, "选择输出栅格文件路径",
        defaultPath.isEmpty() ? QStandardPaths::writableLocation(QStandardPaths::HomeLocation) : defaultPath,
        "GeoTIFF (*.tif *.tiff);;Erdas Imagine (*.img);;所有文件 (*.*)");
    if (!filePath.isEmpty()) {
        if (QFileInfo(filePath).suffix().isEmpty()) {
            if (!filePath.endsWith(".")) filePath += ".";
            filePath += "tif";
        }
        m_editOutputRasterPath->setText(filePath);
    }
}

void ReprojectRasterDialog::onOkClicked()
{
    QString inputPath = m_currentInputRasterPath;
    // === 修改：从QComboBox获取目标CRS ===
    QgsCoordinateReferenceSystem targetCrs = m_currentTargetCrs;
    // ==================================
    QString outputPath = m_editOutputRasterPath->text();

    // --- 参数验证 ---
    if (inputPath.isEmpty()) { /* ... */ return; }
    if (!targetCrs.isValid()) { QMessageBox::warning(this, "输入错误", "请选择一个有效的目标坐标参考系。"); return; }
    if (outputPath.isEmpty()) { /* ... */ return; }

    qDebug() << "Reprojecting Raster (using GDALCreateAndReprojectImage):";
    qDebug() << "  Input:" << inputPath;
    qDebug() << "  Target CRS AuthID:" << targetCrs.authid() << "Desc:" << targetCrs.description();
    qDebug() << "  Output:" << outputPath;

    GDALAllRegister();
    GDALDatasetH hSrcDS = GDALOpen(inputPath.toUtf8().constData(), GA_ReadOnly);
    if (!hSrcDS) { /* ... */ return; }

    const char* pszSrcWKT = GDALGetProjectionRef(hSrcDS);
    if (pszSrcWKT == nullptr || strlen(pszSrcWKT) == 0) { /* ...警告并返回... */ GDALClose(hSrcDS); return; }

    // --- 获取目标WKT (从QgsCoordinateReferenceSystem对象) ---
    std::string targetWktStdString = targetCrs.toWkt().toStdString();
    // 或者 QgsCoordinateReferenceSystem::Wkt वन (更兼容旧GDAL)
    // std::string targetWktStdString = targetCrs.toWkt().toStdString(); 

    const char* pszDstWKT = targetWktStdString.c_str();
    // ----------------------------------------------------

    if (strlen(pszDstWKT) == 0) { /* ...错误并返回... */ GDALClose(hSrcDS); return; }
    qDebug() << "Source WKT:" << pszSrcWKT;
    qDebug() << "Target WKT:" << pszDstWKT;

    GDALResampleAlg eResampleAlg = GRA_Bilinear;
    GDALDriverH hDstDriver = GDALGetDriverByName("GTiff");
    if (!hDstDriver) { /* ... */ GDALClose(hSrcDS); return; }
    char** papszCreateOptions = nullptr;
    papszCreateOptions = CSLSetNameValue(papszCreateOptions, "TILED", "YES");
    papszCreateOptions = CSLSetNameValue(papszCreateOptions, "COMPRESS", "LZW");

    GDALWarpOptions* psOptions = GDALCreateWarpOptions(); // 仍然创建它，因为 GDALCreateAndReprojectImage 会用到

    CPLErr eErr = GDALCreateAndReprojectImage(
        hSrcDS, pszSrcWKT,
        outputPath.toUtf8().constData(), pszDstWKT,
        hDstDriver, papszCreateOptions,
        eResampleAlg,
        0.0, 0.125,
        GDALTermProgress, nullptr,
        psOptions
    );

    CSLDestroy(papszCreateOptions);
    GDALDestroyWarpOptions(psOptions);
    GDALClose(hSrcDS);

    if (eErr == CE_None) {
        QMessageBox::information(this, "成功",
            QString("栅格投影转换完成！\n输出文件已保存到:\n%1").arg(outputPath));
        // =====================================================================

        // (可选) 如果转换成功，自动将新生成的图层添加到项目中
         //QgsRasterLayer* newLayer = new QgsRasterLayer(outputPath, QFileInfo(outputPath).baseName());
         //if (newLayer->isValid()) {
         //    QgsProject::instance()->addMapLayer(newLayer);
         //    // 也可以在这里让主窗口的图层树刷新，或者缩放到新图层
         //} else {
         //    qWarning() << "Failed to load reprojected layer:" << outputPath << newLayer->error().message();
         //    delete newLayer;
         //}

        accept(); // 关闭对话框
    }
    else { QMessageBox::critical(this, "投影转换失败", "GDAL操作失败: " + QString(CPLGetLastErrorMsg())); }
}
正在处理文件: ResampleDialog.cpp
(ResampleDialog.cpp)
// ResampleDialog.cpp
#include "ResampleDialog.h"
#include <QVBoxLayout>
#include <QHBoxLayout>
#include <QGridLayout>
#include <QLabel>
#include <QComboBox>
#include <QPushButton>
#include <QLineEdit>
#include <QFileDialog>
#include <QMessageBox>
#include <QStandardPaths>
#include <QFileInfo>
#include <QDoubleSpinBox>

#include <qgsproject.h>
#include <qgsrasterlayer.h>
#include <qgsapplication.h> // For QgsApplication::messageBar() if needed
#include "Output_Manager.h" // 用于日志输出
#include <QDebug>
#include <qgsunittypes.h>

// GDAL for resampling (gdalwarp functionality)
#include "gdal_priv.h"
#include "gdalwarper.h"
#include "cpl_conv.h"
#include "gdal_alg.h"
#include "cpl_string.h"
#include "ogr_spatialref.h" // 如果涉及投影字符串

ResampleDialog::ResampleDialog(QWidget* parent)
    : QDialog(parent)
{
    setWindowTitle("栅格重采样");
    setMinimumWidth(550);
    setupUI();
    populateInputRasterComboBox();
    connect(m_inputRasterCombo, QOverload<int>::of(&QComboBox::currentIndexChanged), this, &ResampleDialog::onInputLayerOrMethodChanged);
    connect(m_resampleMethodCombo, QOverload<int>::of(&QComboBox::currentIndexChanged), this, &ResampleDialog::onInputLayerOrMethodChanged);

}

ResampleDialog::~ResampleDialog()
{
}

void ResampleDialog::setupUI()
{
    QVBoxLayout* mainLayout = new QVBoxLayout(this);
    QGridLayout* gridLayout = new QGridLayout();

    // 1. 输入栅格
    gridLayout->addWidget(new QLabel("输入栅格图层:", this), 0, 0);
    m_inputRasterCombo = new QComboBox(this);
    gridLayout->addWidget(m_inputRasterCombo, 0, 1);
    m_btnSelectInputRasterFile = new QPushButton("从文件...", this);
    gridLayout->addWidget(m_btnSelectInputRasterFile, 0, 2);
    m_lblSelectedRasterInfo = new QLabel("当前选择: 无", this);
    gridLayout->addWidget(m_lblSelectedRasterInfo, 1, 0, 1, 3);

    // 2. 重采样方法
    gridLayout->addWidget(new QLabel("重采样方法:", this), 2, 0);
    m_resampleMethodCombo = new QComboBox(this);
    m_resampleMethodCombo->addItem("最近邻 (Nearest Neighbour)", static_cast<int>(GRA_NearestNeighbour));
    m_resampleMethodCombo->addItem("双线性插值 (Bilinear)", static_cast<int>(GRA_Bilinear));
    m_resampleMethodCombo->addItem("立方卷积 (Cubic Convolution)", static_cast<int>(GRA_Cubic));
    // m_resampleMethodCombo->addItem("三次样条 (Cubic Spline)", static_cast<int>(GRA_CubicSpline));
    // m_resampleMethodCombo->addItem("Lanczos", static_cast<int>(GRA_Lanczos));
    gridLayout->addWidget(m_resampleMethodCombo, 2, 1, 1, 2);

    // 3. 输出像元大小 (可选)
    gridLayout->addWidget(new QLabel("输出像元大小 X:", this), 3, 0);
    m_spinOutputPixelSizeX = new QDoubleSpinBox(this);
    m_spinOutputPixelSizeX->setDecimals(6); // 允许更高精度
    m_spinOutputPixelSizeX->setMinimum(0);  // 0 表示使用源分辨率
    m_spinOutputPixelSizeX->setSuffix(" (地图单位)");
    m_spinOutputPixelSizeX->setSpecialValueText("使用源分辨率"); // 当值为0时显示
    gridLayout->addWidget(m_spinOutputPixelSizeX, 3, 1);

    gridLayout->addWidget(new QLabel("输出像元大小 Y:", this), 4, 0);
    m_spinOutputPixelSizeY = new QDoubleSpinBox(this);
    m_spinOutputPixelSizeY->setDecimals(6);
    m_spinOutputPixelSizeY->setMinimum(0);
    m_spinOutputPixelSizeY->setSuffix(" (地图单位)");
    m_spinOutputPixelSizeY->setSpecialValueText("使用源分辨率");
    gridLayout->addWidget(m_spinOutputPixelSizeY, 4, 1);

    m_lblPixelSizeHint = new QLabel("提示: X和Y都设为0或留空，则保持原始分辨率。", this);
    m_lblPixelSizeHint->setStyleSheet("font-style: italic; color: gray;");
    gridLayout->addWidget(m_lblPixelSizeHint, 5, 0, 1, 3);


    // 4. 输出栅格路径
    gridLayout->addWidget(new QLabel("输出栅格路径:", this), 6, 0);
    m_editOutputRasterPath = new QLineEdit(this);
    m_editOutputRasterPath->setPlaceholderText("选择输出文件路径...");
    gridLayout->addWidget(m_editOutputRasterPath, 6, 1);
    m_btnSelectOutputRaster = new QPushButton("浏览...", this);
    gridLayout->addWidget(m_btnSelectOutputRaster, 6, 2);

    mainLayout->addLayout(gridLayout);
    mainLayout->addStretch();

    // 5. 按钮
    QHBoxLayout* buttonLayout = new QHBoxLayout();
    buttonLayout->addStretch();
    m_btnOk = new QPushButton("确定", this);
    m_btnCancel = new QPushButton("取消", this);
    buttonLayout->addWidget(m_btnOk);
    buttonLayout->addWidget(m_btnCancel);
    mainLayout->addLayout(buttonLayout);

    setLayout(mainLayout);

    // 连接信号
    connect(m_inputRasterCombo, QOverload<int>::of(&QComboBox::currentIndexChanged), this, [this](int index) {
        QString unitSuffix = " (未知单位)";
        if (index > 0) {
            QVariant data = m_inputRasterCombo->itemData(index);
            QgsRasterLayer* layer = qvariant_cast<QgsRasterLayer*>(data);
            if (layer && QgsProject::instance()->mapLayer(layer->id())) {
                m_currentInputRasterPath = layer->source();
                m_lblSelectedRasterInfo->setText(QString("当前选择: %1 (项目)").arg(layer->name()));
                if (layer->crs().isGeographic()) {
                    unitSuffix = " (度)";
                }
                else {
                    unitSuffix = QString(" (%1)").arg(QgsUnitTypes::toString(layer->crs().mapUnits()));
                }
            }
        }
        else {
            if (m_currentInputRasterPath.isEmpty() || !m_lblSelectedRasterInfo->text().contains("(文件)")) {
                // ... (之前的逻辑)
            }
            else { // 如果是从文件选择的路径
                QgsRasterLayer tempLayer(m_currentInputRasterPath);
                if (tempLayer.isValid() && tempLayer.crs().isValid()) {
                    if (tempLayer.crs().isGeographic()) {
                        unitSuffix = " (度)";
                    }
                    else {
                        unitSuffix = QString(" (%1)").arg(QgsUnitTypes::toString(tempLayer.crs().mapUnits()));
                    }
                }
            }
        }
        m_spinOutputPixelSizeX->setSuffix(unitSuffix);
        m_spinOutputPixelSizeY->setSuffix(unitSuffix);
        updateDefaultOutputPath();
        });
    connect(m_btnSelectInputRasterFile, &QPushButton::clicked, this, &ResampleDialog::onSelectInputRasterClicked);
    connect(m_resampleMethodCombo, QOverload<int>::of(&QComboBox::currentIndexChanged), this, &ResampleDialog::onInputLayerOrMethodChanged);
    connect(m_btnSelectOutputRaster, &QPushButton::clicked, this, &ResampleDialog::onSelectOutputRasterClicked);
    connect(m_btnOk, &QPushButton::clicked, this, &ResampleDialog::onOkClicked);
    connect(m_btnCancel, &QPushButton::clicked, this, &QDialog::reject);
}

void ResampleDialog::populateInputRasterComboBox()
{
    m_inputRasterCombo->clear();
    m_inputRasterCombo->addItem("--- 从项目中选择栅格 ---", QVariant());
    QList<QgsMapLayer*> layers = QgsProject::instance()->mapLayers().values();
    for (QgsMapLayer* layer : layers) {
            if (auto rasterLayer = qobject_cast<QgsRasterLayer*>(layer)) {
                m_inputRasterCombo->addItem(rasterLayer->name(), QVariant::fromValue(rasterLayer));
            }
    }
}

void ResampleDialog::onSelectInputRasterClicked()
{
    QString filePath = QFileDialog::getOpenFileName(this, "选择输入栅格文件",
        QStandardPaths::writableLocation(QStandardPaths::HomeLocation),
        "栅格文件 (*.tif *.tiff *.img);;所有文件 (*.*)");
    if (!filePath.isEmpty()) {
        m_currentInputRasterPath = filePath;
        m_lblSelectedRasterInfo->setText(QString("当前选择: %1 (文件)").arg(QFileInfo(filePath).fileName()));
        m_inputRasterCombo->setCurrentIndex(0); // 清除下拉框选择
        updateDefaultOutputPath();
    }
}

void ResampleDialog::onInputLayerOrMethodChanged()
{
    updateDefaultOutputPath();
}

void ResampleDialog::updateDefaultOutputPath()
{
    if (m_currentInputRasterPath.isEmpty()) {
        m_editOutputRasterPath->clear();
        return;
    }

    QFileInfo fi(m_currentInputRasterPath);
    QString baseName = fi.completeBaseName();
    QString dirPath = fi.absolutePath();
    QString suffix = fi.suffix(); // 保留原始后缀

    QString methodSuffix;
    GDALResampleAlg alg = static_cast<GDALResampleAlg>(m_resampleMethodCombo->currentData().toInt());
    switch (alg) {
    case GRA_NearestNeighbour: methodSuffix = "nn"; break;
    case GRA_Bilinear:         methodSuffix = "bilinear"; break;
    case GRA_Cubic:            methodSuffix = "cubic"; break;
        // case GRA_CubicSpline:      methodSuffix = "cubicspline"; break;
        // case GRA_Lanczos:          methodSuffix = "lanczos"; break;
    default:                   methodSuffix = "res"; break;
    }

    QString defaultOutputName = QString("%1_resampled_%2.%3").arg(baseName).arg(methodSuffix).arg(suffix);
    m_editOutputRasterPath->setText(QDir(dirPath).filePath(defaultOutputName));
}


void ResampleDialog::onSelectOutputRasterClicked()
{
    QString defaultPath = m_editOutputRasterPath->text();
    if (defaultPath.isEmpty() && !m_currentInputRasterPath.isEmpty()) {
        // 尝试基于输入路径生成一个默认的保存路径
        QFileInfo fi(m_currentInputRasterPath);
        defaultPath = fi.absolutePath();
    }
    else if (defaultPath.isEmpty()) {
        defaultPath = QStandardPaths::writableLocation(QStandardPaths::HomeLocation);
    }

    QString filePath = QFileDialog::getSaveFileName(this, "选择输出栅格文件路径",
        defaultPath,
        "GeoTIFF (*.tif *.tiff);;Erdas Imagine (*.img);;所有文件 (*.*)");
    if (!filePath.isEmpty()) {
        // 确保有后缀
        if (QFileInfo(filePath).suffix().isEmpty()) {
            if (!filePath.endsWith(".")) filePath += ".";
            filePath += "tif"; // 默认tif
        }
        m_editOutputRasterPath->setText(filePath);
    }
}

// 公共接口实现
QString ResampleDialog::selectedInputRasterPath() const {
    return m_currentInputRasterPath;
}

Qgis::RasterResamplingMethod ResampleDialog::selectedResamplingMethod() const {
    // GDALResampleAlg 与 Qgis::RasterResamplingMethod 的值是对应的
    return static_cast<Qgis::RasterResamplingMethod>(m_resampleMethodCombo->currentData().toInt());
}

QString ResampleDialog::outputRasterPath() const {
    return m_editOutputRasterPath->text();
}

double ResampleDialog::outputPixelSizeX() const {
    double val = m_spinOutputPixelSizeX->value();
    return (val <= 0) ? -1.0 : val; // 0或负数表示使用源分辨率
}
double ResampleDialog::outputPixelSizeY() const {
    double val = m_spinOutputPixelSizeY->value();
    return (val <= 0) ? -1.0 : val;
}


// ResampleDialog.cpp

void ResampleDialog::onOkClicked()
{
    // --- 步骤 0: 获取所有输入参数 ---
    QString inputPath = selectedInputRasterPath();
    GDALResampleAlg resampleAlg = static_cast<GDALResampleAlg>(m_resampleMethodCombo->currentData().toInt());
    QString outputPath = outputRasterPath();
    double targetPixelSizeX = outputPixelSizeX(); // -1.0 或 0.0 表示使用源分辨率
    double targetPixelSizeY = outputPixelSizeY(); // -1.0 或 0.0 表示使用源分辨率

    // --- 参数检查 ---
    if (inputPath.isEmpty()) { QMessageBox::warning(this, "输入错误", "请选择输入栅格图层。"); return; }
    if (outputPath.isEmpty()) { QMessageBox::warning(this, "输入错误", "请输入输出栅格路径。"); return; }

    qDebug() << "\n====== 开始重采样操作 (直接WarpOperation) ======";
    qDebug() << "GDAL版本:" << GDALVersionInfo("RELEASE_NAME");
    qDebug() << "输入文件:" << inputPath;
    qDebug() << "输出文件:" << outputPath;
    qDebug() << "重采样算法 (int):" << static_cast<int>(resampleAlg);
    qDebug() << "目标像元大小 X:" << targetPixelSizeX << " Y:" << targetPixelSizeY;

    GDALAllRegister();

    // --- 步骤 1: 打开输入数据集 ---
    GDALDatasetH hSrcDS = GDALOpen(inputPath.toUtf8().constData(), GA_ReadOnly);
    if (!hSrcDS) {
        QMessageBox::critical(this, "GDAL错误", "无法打开输入栅格: " + inputPath + "\n" + CPLGetLastErrorMsg());
        return;
    }

    // --- 步骤 2: 获取输入参数，计算输出几何参数 ---
    const int srcWidth = GDALGetRasterXSize(hSrcDS);
    const int srcHeight = GDALGetRasterYSize(hSrcDS);
    const int bandCount = GDALGetRasterCount(hSrcDS);
    if (bandCount == 0) {
        QMessageBox::critical(this, "GDAL错误", "输入栅格不包含任何波段。");
        GDALClose(hSrcDS);
        return;
    }
    const GDALDataType dataType = GDALGetRasterDataType(GDALGetRasterBand(hSrcDS, 1));
    double adfSrcGeoTransform[6];
    if (GDALGetGeoTransform(hSrcDS, adfSrcGeoTransform) != CE_None) {
        QMessageBox::critical(this, "GDAL错误", "无法获取输入栅格的地理变换参数。");
        GDALClose(hSrcDS);
        return;
    }
    const char* pszSrcProjection = GDALGetProjectionRef(hSrcDS);

    int dstWidth = srcWidth;
    int dstHeight = srcHeight;
    double adfDstGeoTransform[6];
    memcpy(adfDstGeoTransform, adfSrcGeoTransform, sizeof(double) * 6); // 初始化目标地理变换

    // 用户指定了目标分辨率
    if (targetPixelSizeX > 0 && targetPixelSizeY > 0) {
        double dfSrcXMin = adfSrcGeoTransform[0];
        double dfSrcYMax = adfSrcGeoTransform[3];
        double dfSrcXMax = dfSrcXMin + adfSrcGeoTransform[1] * srcWidth;
        double dfSrcYMin = dfSrcYMax + adfSrcGeoTransform[5] * srcHeight;

        qDebug() << "  源X范围:" << dfSrcXMin << "to" << dfSrcXMax << "(宽度:" << (dfSrcXMax - dfSrcXMin) << ")";
        qDebug() << "  源Y范围:" << dfSrcYMin << "to" << dfSrcYMax << "(高度:" << (dfSrcYMax - dfSrcYMin) << ")";
        qDebug() << "  目标像元X:" << targetPixelSizeX << "目标像元Y:" << targetPixelSizeY;

        // 确保除数不为0，并且是有意义的正值
        if (targetPixelSizeX <= 0 || targetPixelSizeY <= 0) {
            QMessageBox::critical(this, "参数错误", "目标像元大小必须为正数。");
            GDALClose(hSrcDS);
            return;
        }

        double extentWidth = std::abs(dfSrcXMax - dfSrcXMin);
        double extentHeight = std::abs(dfSrcYMax - dfSrcYMin);

        // 如果源数据的地理范围本身非常小（例如，接近0），则不应进行基于分辨率的尺寸计算
        if (extentWidth < 1e-9 || extentHeight < 1e-9) { // 1e-9 是一个很小的阈值
            qWarning() << "源数据地理范围过小，无法根据目标分辨率计算尺寸。将使用源尺寸。";
            // 保持 dstWidth = srcWidth, dstHeight = srcHeight
        }
        else {
            dstWidth = static_cast<int>(extentWidth / targetPixelSizeX + 0.5);
            dstHeight = static_cast<int>(extentHeight / std::abs(targetPixelSizeY) + 0.5); // Y像元大小通常用绝对值
        }

        // 保持原始栅格左上角坐标和像元大小符号
        adfDstGeoTransform[0] = adfSrcGeoTransform[0];
        adfDstGeoTransform[1] = targetPixelSizeX;
        adfDstGeoTransform[2] = adfSrcGeoTransform[2]; // 保留旋转参数
        adfDstGeoTransform[3] = adfSrcGeoTransform[3];
        adfDstGeoTransform[4] = adfSrcGeoTransform[4]; // 保留旋转参数
        adfDstGeoTransform[5] = (adfSrcGeoTransform[5] < 0) ? -std::abs(targetPixelSizeY) : std::abs(targetPixelSizeY);
    }

    qDebug() << "计算出的目标尺寸:" << dstWidth << "x" << dstHeight;
    if (dstWidth <= 0 || dstHeight <= 0) {
        QMessageBox::critical(this, "参数错误",
            QString("计算出的目标栅格尺寸为 %1x%2，这是一个无效尺寸。\n\n"
                "这通常意味着您设定的“目标像元大小”相对于源栅格的地理范围过大。\n\n"
                "源栅格宽度（地理单位）: %3\n"
                "源栅格高度（地理单位）: %4\n"
                "您设定的目标像元大小 X: %5, Y: %6 (单位与源栅格一致)")
            .arg(dstWidth).arg(dstHeight)
            .arg(std::abs(adfSrcGeoTransform[1] * srcWidth)) // 源地理宽度
            .arg(std::abs(adfSrcGeoTransform[5] * srcHeight)) // 源地理高度
            .arg(targetPixelSizeX).arg(targetPixelSizeY)
        );
        GDALClose(hSrcDS);
        return;
    }

    // --- 步骤 3: 创建输出数据集 ---
    GDALDriverH hDriver = GDALGetDriverByName("GTiff");
    if (!hDriver) {
        QMessageBox::critical(this, "GDAL错误", "无法获取GTiff驱动。");
        GDALClose(hSrcDS);
        return;
    }
    char** papszCreateOptions = nullptr;
    papszCreateOptions = CSLSetNameValue(papszCreateOptions, "TILED", "YES");
    papszCreateOptions = CSLSetNameValue(papszCreateOptions, "COMPRESS", "LZW");

    GDALDatasetH hDstDS = GDALCreate(hDriver, outputPath.toUtf8().constData(),
        dstWidth, dstHeight, bandCount, dataType, papszCreateOptions);
    CSLDestroy(papszCreateOptions);

    if (!hDstDS) {
        QMessageBox::critical(this, "GDAL错误", "无法创建输出文件: " + outputPath + "\n" + CPLGetLastErrorMsg());
        GDALClose(hSrcDS);
        return;
    }

    // 设置输出数据集的地理转换和投影
    GDALSetGeoTransform(hDstDS, adfDstGeoTransform);
    if (pszSrcProjection != nullptr && strlen(pszSrcProjection) > 0) {
        GDALSetProjection(hDstDS, pszSrcProjection);
    }
    qDebug() << "输出数据集已创建。";

    // --- 步骤 4: 配置并执行 GDALWarpOperation ---
    GDALWarpOptions* psWarpOptions = GDALCreateWarpOptions();
    psWarpOptions->eResampleAlg = resampleAlg;

    // 关键：将源和已创建的目标数据集都提供给WarpOptions
    psWarpOptions->hSrcDS = hSrcDS;
    psWarpOptions->hDstDS = hDstDS;

    psWarpOptions->nBandCount = bandCount;
    psWarpOptions->panSrcBands = (int*)CPLMalloc(sizeof(int) * bandCount);
    psWarpOptions->panDstBands = (int*)CPLMalloc(sizeof(int) * bandCount);
    for (int i = 0; i < bandCount; i++) {
        psWarpOptions->panSrcBands[i] = i + 1;
        psWarpOptions->panDstBands[i] = i + 1;
    }

    // 创建转换器，此时源和目标数据集的投影和地理变换都已确定
    // 如果源和目标投影不同，GDALCreateGenImgProjTransformer2会处理重投影
    // 如果相同，它主要处理地理变换之间的映射
    psWarpOptions->pTransformerArg = GDALCreateGenImgProjTransformer2(hSrcDS, hDstDS, nullptr); // 第三个参数可传NULL或创建选项
    psWarpOptions->pfnTransformer = GDALGenImgProjTransform;

    if (!psWarpOptions->pTransformerArg) {
        QMessageBox::critical(this, "GDAL错误", "创建坐标转换器失败:\n" + QString(CPLGetLastErrorMsg()));
        CPLFree(psWarpOptions->panSrcBands); CPLFree(psWarpOptions->panDstBands);
        GDALDestroyWarpOptions(psWarpOptions);
        GDALClose(hDstDS); GDALClose(hSrcDS);
        return;
    }
    qDebug() << "WarpOptions配置完毕，转换器已创建。";

    GDALWarpOperation oWarper;
    CPLErr eErr = oWarper.Initialize(psWarpOptions);

    if (eErr == CE_None) {
        qDebug() << "WarpOperation初始化成功，开始ChunkAndWarpImage...";
        // 目标尺寸从hDstDS获取
        eErr = oWarper.ChunkAndWarpImage(0, 0, GDALGetRasterXSize(hDstDS), GDALGetRasterYSize(hDstDS));
        if (eErr != CE_None) {
            QMessageBox::critical(this, "重采样失败", "GDAL ChunkAndWarpImage 操作失败: " + QString(CPLGetLastErrorMsg()));
        }
    }
    else {
        QMessageBox::critical(this, "GDAL错误", "初始化Warp操作失败: " + QString(CPLGetLastErrorMsg()));
    }

    // --- 步骤 5: 清理资源 ---
    if (psWarpOptions != nullptr) {
        if (psWarpOptions->pTransformerArg != nullptr) {
            GDALDestroyTransformer(psWarpOptions->pTransformerArg);
            psWarpOptions->pTransformerArg = nullptr;
        }
        if (psWarpOptions->panSrcBands) { // 检查是否为nullptr，以防之前分配失败
            CPLFree(psWarpOptions->panSrcBands); psWarpOptions->panSrcBands = nullptr;
        }
        if (psWarpOptions->panDstBands) {
            CPLFree(psWarpOptions->panDstBands); psWarpOptions->panDstBands = nullptr;
        }
        GDALDestroyWarpOptions(psWarpOptions); psWarpOptions = nullptr;
    }

    // **确保目标数据集在所有操作完成后，并且在尝试用QGIS加载它之前被关闭**
    if (hDstDS != nullptr) {
        qDebug() << "Closing destination dataset (hDstDS) before attempting to load with QGIS.";
        GDALClose(hDstDS);
        hDstDS = nullptr; // 设为nullptr，避免后续意外关闭
    }
    if (hSrcDS != nullptr) {
        qDebug() << "Closing source dataset (hSrcDS).";
        GDALClose(hSrcDS);
        hSrcDS = nullptr;
    }

    // --- 步骤 6: 结果反馈和加载到QGIS ---
    if (eErr == CE_None) { // 只有当 GDAL Warp 操作没有报告错误时才继续
        QMessageBox::information(this, "成功", "栅格重采样完成！\n输出文件: " + outputPath);

        // ====================== 加载结果图层并进行详细错误检查 ======================
        OutputManager::instance()->logMessage("Attempting to load resampled raster: " + outputPath);
        QgsRasterLayer* newLayer = new QgsRasterLayer(outputPath, QFileInfo(outputPath).baseName(), "gdal");

        if (newLayer->isValid()) {
            OutputManager::instance()->logMessage("Resampled raster layer loaded successfully: " + newLayer->name());
            QgsProject::instance()->addMapLayer(newLayer);
            // (可选) 主窗口缩放到新图层
            // 例如，可以发射一个信号，让主窗口去处理
            // emit resampleSucceededAndLayerAdded(newLayer); 
        }
        else {
            QString errorMsg = "加载重采样后的栅格图层失败: " + outputPath;
            if (newLayer) { // 确保newLayer不是nullptr才调用error()
                errorMsg += "\nQGIS Layer Error: " + newLayer->error().message();
                delete newLayer; // 清理无效图层对象
                newLayer = nullptr;
            }
            else {
                errorMsg += "\nQGIS Layer Error: Layer object creation failed (returned nullptr).";
            }

            const char* gdalLastError = CPLGetLastErrorMsg();
            if (gdalLastError && strlen(gdalLastError) > 0 && strcmp(gdalLastError, "None") != 0) { // 检查是否真的有GDAL错误
                errorMsg += "\nLast GDAL Error (after attempting QGIS load): " + QString::fromUtf8(gdalLastError);
            }

            OutputManager::instance()->logError(errorMsg);
            QMessageBox::warning(this, "加载失败", errorMsg);
        }
        // =======================================================================
        accept(); // 关闭对话框
    }
    else {
        // 如果 eErr != CE_None，说明GDAL Warp操作本身就失败了
        // QMessageBox::critical 已经在之前的错误判断中显示过了，这里可以不再重复
        // 或者，如果之前的QMessageBox只针对特定步骤，这里可以加一个总的失败提示
        OutputManager::instance()->logError("GDAL Warp operation failed with error code: " + QString::number(eErr));
    }
}
正在处理文件: SpatialJoinDialog.cpp
(SpatialJoinDialog.cpp)
// SpatialJoinDialog.cpp
#include "SpatialJoinDialog.h"
#include <QVBoxLayout>
#include <QHBoxLayout>
#include <QGridLayout>
#include <QLabel>
#include <QComboBox>
#include <QPushButton>
#include <QLineEdit>
#include <QFileDialog>
#include <QMessageBox>
#include <QStandardPaths>
#include <QFileInfo>

#include <qgsproject.h>
#include <qgsvectorlayer.h>
#include <qgsfields.h>
#include <qgsapplication.h>
#include <qgsprocessingregistry.h>
#include <qgsprocessingalgorithm.h>
#include <qgsprocessingcontext.h>
#include <qgsprocessingfeedback.h>
#include "Output_Manager.h"
#include <QDebug>
#include <memory> // For std::unique_ptr

#include "gdal_priv.h"
#include "ogrsf_frmts.h"
#include "ogr_geometry.h"
#include "ogr_spatialref.h"
#include "cpl_conv.h"
#include "cpl_string.h"

SpatialJoinDialog::SpatialJoinDialog(QWidget* parent)
    : QDialog(parent), m_currentTargetLayer(nullptr), m_currentJoinLayer(nullptr)
{
    setWindowTitle("空间连接 (点落入面)");
    setMinimumWidth(550);
    setupUI();
    populateTargetLayerComboBox();
    populateJoinLayerComboBox();

    // 连接信号
    connect(m_targetLayerCombo, QOverload<int>::of(&QComboBox::currentIndexChanged), this, &SpatialJoinDialog::onTargetLayerChanged);
    connect(m_joinLayerCombo, QOverload<int>::of(&QComboBox::currentIndexChanged), this, &SpatialJoinDialog::onJoinLayerChanged);
}

SpatialJoinDialog::~SpatialJoinDialog()
{
}

void SpatialJoinDialog::setupUI()
{
    QVBoxLayout* mainLayout = new QVBoxLayout(this);
    QGridLayout* gridLayout = new QGridLayout();

    int row = 0;
    // 1. 目标图层 (面)
    gridLayout->addWidget(new QLabel("目标图层 (面，如地块):", this), row, 0);
    m_targetLayerCombo = new QComboBox(this);
    gridLayout->addWidget(m_targetLayerCombo, row, 1);
    // m_btnSelectTargetLayerFile = new QPushButton("从文件...", this); // 暂不实现文件选择
    // gridLayout->addWidget(m_btnSelectTargetLayerFile, row, 2);
    row++;
    m_lblSelectedTargetLayerInfo = new QLabel("当前选择: 无", this);
    gridLayout->addWidget(m_lblSelectedTargetLayerInfo, row, 0, 1, 3);

    row++;
    // 2. 连接图层 (点，如POI)
    gridLayout->addWidget(new QLabel("连接图层 (点，如POI):", this), row, 0);
    m_joinLayerCombo = new QComboBox(this);
    gridLayout->addWidget(m_joinLayerCombo, row, 1);
    // m_btnSelectJoinLayerFile = new QPushButton("从文件...", this); // 暂不实现
    // gridLayout->addWidget(m_btnSelectJoinLayerFile, row, 2);
    row++;
    m_lblSelectedJoinLayerInfo = new QLabel("当前选择: 无", this);
    gridLayout->addWidget(m_lblSelectedJoinLayerInfo, row, 0, 1, 3);

    row++;
    // 3. POI ID 来源字段
    m_lblPoiIdSourceField = new QLabel("选择POI的ID字段:", this);
    gridLayout->addWidget(m_lblPoiIdSourceField, row, 0);
    m_poiIdSourceFieldCombo = new QComboBox(this);
    m_poiIdSourceFieldCombo->setToolTip("选择连接图层中哪个字段的值将赋给目标图层的新PoiId字段");
    gridLayout->addWidget(m_poiIdSourceFieldCombo, row, 1, 1, 2);

    row++;
    // 4. 输出图层中新字段的名称
    m_lblOutputPoiIdFieldName = new QLabel("输出图层PoiId字段名:", this);
    gridLayout->addWidget(m_lblOutputPoiIdFieldName, row, 0);
    m_editOutputPoiIdFieldName = new QLineEdit("PoiId", this); // 默认字段名
    gridLayout->addWidget(m_editOutputPoiIdFieldName, row, 1, 1, 2);

    row++;
    // 5. 输出图层路径
    gridLayout->addWidget(new QLabel("输出图层路径:", this), row, 0);
    m_editOutputLayerPath = new QLineEdit(this);
    m_editOutputLayerPath->setPlaceholderText("选择输出文件路径...");
    gridLayout->addWidget(m_editOutputLayerPath, row, 1);
    m_btnSelectOutputLayer = new QPushButton("浏览...", this);
    gridLayout->addWidget(m_btnSelectOutputLayer, row, 2);

    mainLayout->addLayout(gridLayout);
    mainLayout->addStretch();

    // 6. 按钮
    QHBoxLayout* buttonLayout = new QHBoxLayout();
    buttonLayout->addStretch();
    m_btnOk = new QPushButton("确定", this);
    m_btnCancel = new QPushButton("取消", this);
    buttonLayout->addWidget(m_btnOk);
    buttonLayout->addWidget(m_btnCancel);
    mainLayout->addLayout(buttonLayout);

    setLayout(mainLayout);

    // 连接信号
    // connect(m_btnSelectTargetLayerFile, &QPushButton::clicked, this, &SpatialJoinDialog::onSelectTargetLayerClicked);
    // connect(m_btnSelectJoinLayerFile, &QPushButton::clicked, this, &SpatialJoinDialog::onSelectJoinLayerClicked);
    connect(m_btnSelectOutputLayer, &QPushButton::clicked, this, &SpatialJoinDialog::onSelectOutputLayerClicked);
    connect(m_btnOk, &QPushButton::clicked, this, &SpatialJoinDialog::onOkClicked);
    connect(m_btnCancel, &QPushButton::clicked, this, &QDialog::reject);
}

void SpatialJoinDialog::populateTargetLayerComboBox()
{
    m_targetLayerCombo->clear();
    m_targetLayerCombo->addItem("--- 选择目标面图层 ---", QVariant());
    QList<QgsMapLayer*> layers = QgsProject::instance()->mapLayers().values();
    for (QgsMapLayer* layer : layers) {
            if (auto vlayer = qobject_cast<QgsVectorLayer*>(layer)) {
                Qgis::WkbType wkbType = vlayer->wkbType(); // 获取图层的WKB类型
                Qgis::GeometryType geomType = QgsWkbTypes::geometryType(wkbType); // 解析几何大类

                if (geomType == Qgis::GeometryType::Polygon) { // 只显示面图层
                    m_targetLayerCombo->addItem(vlayer->name(), QVariant::fromValue(vlayer));
                }
            }
    }
    onTargetLayerChanged();
}

void SpatialJoinDialog::populateJoinLayerComboBox()
{
    m_joinLayerCombo->clear();
    m_joinLayerCombo->addItem("--- 选择连接点图层 ---", QVariant());
    QList<QgsMapLayer*> layers = QgsProject::instance()->mapLayers().values();
    for (QgsMapLayer* layer : layers) {
            if (auto vlayer = qobject_cast<QgsVectorLayer*>(layer)) {
                Qgis::WkbType wkbType = vlayer->wkbType(); // 获取图层的WKB类型
                Qgis::GeometryType geomType = QgsWkbTypes::geometryType(wkbType); // 解析几何大类
                if (geomType == Qgis::GeometryType::Point) { // 只显示点图层
                    m_joinLayerCombo->addItem(vlayer->name(), QVariant::fromValue(vlayer));
                }
            }
    }
    onJoinLayerChanged();
}

void SpatialJoinDialog::populatePoiIdFieldComboBox()
{
    m_poiIdSourceFieldCombo->clear();
    m_poiIdSourceFieldCombo->addItem("--- (自动ID或不选择) ---", QString()); // 空字符串表示不使用特定字段
    if (m_currentJoinLayer) {
        const QgsFields fields = m_currentJoinLayer->fields();
        for (int i = 0; i < fields.count(); ++i) {
            // 通常ID字段是整数或长整型，但也允许文本
            m_poiIdSourceFieldCombo->addItem(fields.field(i).name(), fields.field(i).name());
        }
    }
}


void SpatialJoinDialog::onSelectTargetLayerClicked() { /* ...暂不实现文件选择... */ }
void SpatialJoinDialog::onSelectJoinLayerClicked() { /* ...暂不实现文件选择... */ }

void SpatialJoinDialog::onTargetLayerChanged()
{
    m_currentTargetLayer = nullptr;
    if (m_targetLayerCombo->currentIndex() > 0) {
        QVariant data = m_targetLayerCombo->itemData(m_targetLayerCombo->currentIndex());
        QgsVectorLayer* layer = qvariant_cast<QgsVectorLayer*>(data);
        if (layer && QgsProject::instance()->mapLayer(layer->id())) {
            m_currentTargetLayer = layer;
            m_lblSelectedTargetLayerInfo->setText(QString("当前目标: %1").arg(layer->name()));
        }
    }
    else {
        m_lblSelectedTargetLayerInfo->setText("当前目标: 无");
    }
    // (可以加更新默认输出名逻辑)
}

void SpatialJoinDialog::onJoinLayerChanged()
{
    m_currentJoinLayer = nullptr;
    if (m_joinLayerCombo->currentIndex() > 0) {
        QVariant data = m_joinLayerCombo->itemData(m_joinLayerCombo->currentIndex());
        QgsVectorLayer* layer = qvariant_cast<QgsVectorLayer*>(data);
        if (layer && QgsProject::instance()->mapLayer(layer->id())) {
            m_currentJoinLayer = layer;
            m_lblSelectedJoinLayerInfo->setText(QString("当前连接: %1").arg(layer->name()));
        }
    }
    else {
        m_lblSelectedJoinLayerInfo->setText("当前连接: 无");
    }
    populatePoiIdFieldComboBox(); // 连接图层变了，可选的ID字段也要变
    // (可以加更新默认输出名逻辑)
}

void SpatialJoinDialog::onSelectOutputLayerClicked()
{
    QString currentPath = m_editOutputLayerPath->text();
    QString defaultDir;

    if (!currentPath.isEmpty() && QFileInfo(currentPath).exists()) {
        defaultDir = QFileInfo(currentPath).absolutePath();
    }
    else if (m_currentTargetLayer && m_currentTargetLayer->isValid() && !m_currentTargetLayer->source().isEmpty()) {
        // 如果当前路径为空，尝试使用目标图层的目录作为默认目录
        defaultDir = QFileInfo(m_currentTargetLayer->source()).absolutePath();
    }
    else {
        defaultDir = QStandardPaths::writableLocation(QStandardPaths::DocumentsLocation);
    }

    // 建议的文件名（可以基于目标图层和连接图层生成）
    QString suggestedName;
    if (m_currentTargetLayer && m_currentJoinLayer) {
        suggestedName = QString("%1_joined_with_%2.shp")
            .arg(QFileInfo(m_currentTargetLayer->name()).completeBaseName())
            .arg(QFileInfo(m_currentJoinLayer->name()).completeBaseName());
    }
    else if (m_currentTargetLayer) {
        suggestedName = QString("%1_joined.shp")
            .arg(QFileInfo(m_currentTargetLayer->name()).completeBaseName());
    }
    else {
        suggestedName = "spatial_join_output.shp";
    }
    QString defaultFilePath = QDir(defaultDir).filePath(suggestedName);


    QString filter = "ESRI Shapefiles (*.shp);;GeoPackage (*.gpkg);;All files (*.*)";
    QString selectedFilePath = QFileDialog::getSaveFileName(this,
        "选择输出图层文件路径",
        defaultFilePath, // 使用包含建议文件名的完整路径
        filter);

    if (!selectedFilePath.isEmpty()) {
        // 检查并添加默认后缀 (如果用户选择的过滤器是 "All files" 且没有输入后缀)
        QFileInfo fi(selectedFilePath);
        if (fi.suffix().isEmpty()) {
            // 从选择的过滤器中提取第一个支持的后缀
            QStringList filters = filter.split(";;");
            if (!filters.isEmpty()) {
                QString firstFilter = filters.first(); // e.g., "ESRI Shapefiles (*.shp)"
                if (firstFilter.contains("(*.") && firstFilter.endsWith(")")) {
                    int startIndex = firstFilter.indexOf("(*.") + 3;
                    int endIndex = firstFilter.lastIndexOf(")");
                    QString defaultSuffix = firstFilter.mid(startIndex, endIndex - startIndex);
                    if (defaultSuffix.contains(" ")) { // 如 "shp gpkg"
                        defaultSuffix = defaultSuffix.split(" ").first();
                    }
                    if (!defaultSuffix.isEmpty()) {
                        selectedFilePath += "." + defaultSuffix;
                    }
                    else {
                        selectedFilePath += ".shp"; // 最终回退
                    }
                }
                else {
                    selectedFilePath += ".shp"; // 最终回退
                }
            }
            else {
                selectedFilePath += ".shp"; // 绝对回退
            }
        }
        m_editOutputLayerPath->setText(selectedFilePath);
    }
}


void SpatialJoinDialog::onOkClicked()
{
    // --- 1. 获取参数 ---
    QString targetLayerPath = "";
    if (m_currentTargetLayer) targetLayerPath = m_currentTargetLayer->source();
    // (如果允许从文件选择，这里需要更完善的逻辑来获取路径)

    QString joinLayerPath = "";
    if (m_currentJoinLayer) joinLayerPath = m_currentJoinLayer->source();

    QString outputPath = m_editOutputLayerPath->text();
    QString outputPoiIdFieldName = m_editOutputPoiIdFieldName->text().trimmed();
    QString sourcePoiIdFieldFromJoinLayer = m_poiIdSourceFieldCombo->currentData().toString();

    // --- 参数验证 ---
    if (targetLayerPath.isEmpty()) { QMessageBox::warning(this, "输入错误", "请选择目标图层 (面)。"); return; }
    if (joinLayerPath.isEmpty()) { QMessageBox::warning(this, "输入错误", "请选择连接图层 (点)。"); return; }
    if (outputPath.isEmpty()) { QMessageBox::warning(this, "输入错误", "请输入输出图层路径。"); return; }
    if (outputPoiIdFieldName.isEmpty()) { QMessageBox::warning(this, "输入错误", "请输入输出图层中PoiId字段的名称。"); return; }
    if (sourcePoiIdFieldFromJoinLayer.isEmpty() && m_poiIdSourceFieldCombo->currentIndex() > 0) {
        // 用户选择了一个具体的字段，但我们没获取到名字（理论上不应发生）
        QMessageBox::warning(this, "输入错误", "选择的POI ID来源字段无效。"); return;
    }
    if (m_poiIdSourceFieldCombo->currentIndex() == 0) { // 用户选择了“自动ID或不选择”
        // 对于精简版，我们强制要求用户选择一个来源字段
        QMessageBox::warning(this, "输入错误", "请从POI图层中选择一个字段作为PoiId的来源。");
        return;
    }


    qDebug() << "\n====== 开始GDAL空间连接 (点落入面) ======";
    // ... (其他qDebug输出) ...

    GDALAllRegister();
    OGRRegisterAll();

    CPLSetConfigOption("SHAPE_ENCODING", "CP936"); // 或者 "GBK"

    // --- 2. 打开输入数据集 ---
    GDALDataset* poTargetDS = (GDALDataset*)GDALOpenEx(targetLayerPath.toUtf8().constData(), GDAL_OF_VECTOR | GDAL_OF_READONLY, nullptr, nullptr, nullptr);
    if (!poTargetDS) { QMessageBox::critical(this, "GDAL错误", "无法打开目标图层: " + targetLayerPath); return; }
    OGRLayer* poTargetLayer = poTargetDS->GetLayer(0);
    if (!poTargetLayer) { QMessageBox::critical(this, "GDAL错误", "无法从目标文件获取图层。"); GDALClose(poTargetDS); return; }

    GDALDataset* poJoinDS = (GDALDataset*)GDALOpenEx(joinLayerPath.toUtf8().constData(), GDAL_OF_VECTOR | GDAL_OF_READONLY, nullptr, nullptr, nullptr);
    if (!poJoinDS) { QMessageBox::critical(this, "GDAL错误", "无法打开连接图层: " + joinLayerPath); GDALClose(poTargetDS); return; }
    OGRLayer* poJoinLayer = poJoinDS->GetLayer(0);
    if (!poJoinLayer) { QMessageBox::critical(this, "GDAL错误", "无法从连接文件获取图层。"); GDALClose(poJoinDS); GDALClose(poTargetDS); return; }

    // --- 3. 创建输出数据集和图层 ---
    const char* pszDriverName = "ESRI Shapefile"; // 默认Shapefile
    if (outputPath.endsWith(".gpkg", Qt::CaseInsensitive)) pszDriverName = "GPKG";
    // (可以添加更多格式判断)

    GDALDriver* poDriver = GetGDALDriverManager()->GetDriverByName(pszDriverName);
    if (!poDriver) { QMessageBox::critical(this, "GDAL错误", QString("无法获取驱动: %1").arg(pszDriverName)); /*清理*/ return; }

    if (QFile::exists(outputPath)) {
        if (poDriver->Delete(outputPath.toUtf8().constData()) != OGRERR_NONE) {
            qDebug() << "Could not delete existing output file:" << outputPath << ". Attempting to overwrite if driver supports.";
        }
    }

    GDALDataset* poDstDS = poDriver->Create(outputPath.toUtf8().constData(), 0, 0, 0, GDT_Unknown, nullptr /*papszCreateOptions*/);
    if (!poDstDS) { QMessageBox::critical(this, "GDAL错误", "无法创建输出文件: " + outputPath + "\n" + CPLGetLastErrorMsg()); /*清理*/ return; }

    char** papszLayerCreationOptions = nullptr;
    if (strcmp(pszDriverName, "ESRI Shapefile") == 0) {
        papszLayerCreationOptions = CSLAddString(papszLayerCreationOptions, "ENCODING=GBK");
    }
    OGRLayer* poDstLayer = poDstDS->CreateLayer(QFileInfo(outputPath).completeBaseName().toUtf8().constData(),
        poTargetLayer->GetSpatialRef(),
        poTargetLayer->GetGeomType(),
        papszLayerCreationOptions); // 传递编码参数

    if (!poDstLayer) { QMessageBox::critical(this, "GDAL错误", "无法创建输出图层。"); /*清理*/ return; }

    // a. 复制目标图层的原始字段
    OGRFeatureDefn* poTargetFDefn = poTargetLayer->GetLayerDefn();
    for (int iField = 0; iField < poTargetFDefn->GetFieldCount(); iField++) {
        if (poDstLayer->CreateField(poTargetFDefn->GetFieldDefn(iField)) != OGRERR_NONE) {
            qWarning() << "Could not create field (from target):" << poTargetFDefn->GetFieldDefn(iField)->GetNameRef();
        }
    }
    // b. 添加新的 PoiId 字段
    //    我们需要确定 PoiId 字段的类型。最好与源POI ID字段的类型一致。
    OGRFieldDefn oPoiIdField(outputPoiIdFieldName.toUtf8().constData(), OFTString); // 默认为字符串
    int sourcePoiIdFieldIndex = poJoinLayer->GetLayerDefn()->GetFieldIndex(sourcePoiIdFieldFromJoinLayer.toUtf8().constData());
    if (sourcePoiIdFieldIndex != -1) {
        oPoiIdField.SetType(poJoinLayer->GetLayerDefn()->GetFieldDefn(sourcePoiIdFieldIndex)->GetType());
        // 可以根据需要设置宽度和精度
        // oPoiIdField.SetWidth(poJoinLayer->GetLayerDefn()->GetFieldDefn(sourcePoiIdFieldIndex)->GetWidth());
        // oPoiIdField.SetPrecision(poJoinLayer->GetLayerDefn()->GetFieldDefn(sourcePoiIdFieldIndex)->GetPrecision());
    }
    if (poDstLayer->CreateField(&oPoiIdField) != OGRERR_NONE) {
        QMessageBox::critical(this, "GDAL错误", "无法创建新的PoiId字段到输出图层。");
        /*清理*/ return;
    }

    // --- 4. 执行空间连接 ---
    OGRFeature* poTargetFeature;
    OGRFeature* poJoinFeature;
    poTargetLayer->ResetReading();

    OutputManager::instance()->logMessage("开始执行空间连接...");
    int joinCount = 0;

    while ((poTargetFeature = poTargetLayer->GetNextFeature()) != nullptr) {
        OGRGeometry* poTargetGeom = poTargetFeature->GetGeometryRef();
        QString poiIdValueToSet; // 用于存储找到的第一个匹配POI的ID值
        bool foundMatch = false;

        if (poTargetGeom != nullptr && !poTargetGeom->IsEmpty()) {
            poJoinLayer->ResetReading(); // 对每个目标要素，都重新从头遍历连接要素
            // (可选) 设置空间过滤器以提高效率，只遍历与当前目标要素范围相交的连接要素
            // poJoinLayer->SetSpatialFilter(poTargetGeom); 

            while ((poJoinFeature = poJoinLayer->GetNextFeature()) != nullptr) {
                OGRGeometry* poJoinGeom = poJoinFeature->GetGeometryRef();
                if (poJoinGeom != nullptr && !poJoinGeom->IsEmpty()) {
                    // 执行空间判断：点是否落入（或相交）面
                    if (poTargetGeom->Intersects(poJoinGeom)) {
                        // 或者用 Contains: if (poTargetGeom->Contains(poJoinGeom))

                            // 找到了一个匹配的POI
                        if (sourcePoiIdFieldIndex != -1) {
                            poiIdValueToSet = QString::fromUtf8(poJoinFeature->GetFieldAsString(sourcePoiIdFieldIndex));
                        }
                        else {
                            poiIdValueToSet = QString::number(poJoinFeature->GetFID()); // 备用：使用要素的FID
                        }
                        foundMatch = true;
                        joinCount++;
                        OGRFeature::DestroyFeature(poJoinFeature); // 销毁连接要素
                        break; // 找到了第一个匹配就跳出内层循环 (one-to-one)
                    }
                }
                OGRFeature::DestroyFeature(poJoinFeature);
            }
            // poJoinLayer->SetSpatialFilter(nullptr); // 清除空间过滤器
        }

        // 创建输出要素
        OGRFeature* poDstFeature = OGRFeature::CreateFeature(poDstLayer->GetLayerDefn());
        poDstFeature->SetFrom(poTargetFeature, TRUE); // 复制几何和所有匹配的原始属性
        if (foundMatch) {
            poDstFeature->SetField(outputPoiIdFieldName.toUtf8().constData(), poiIdValueToSet.toUtf8().constData());
        }
        else {
            // 如果没有匹配的POI，PoiId字段可以留空或设置一个特定值
            // poDstFeature->SetFieldNull(outputPoiIdFieldName.toUtf8().constData());
        }

        if (poDstLayer->CreateFeature(poDstFeature) != OGRERR_NONE) {
            qWarning() << "Failed to create feature in output layer for target FID:" << poTargetFeature->GetFID();
        }
        OGRFeature::DestroyFeature(poDstFeature);
        OGRFeature::DestroyFeature(poTargetFeature); // 销毁目标要素
    }
    OutputManager::instance()->logMessage(QString("空间连接完成，共连接 %1 个目标要素。").arg(joinCount));

    // --- 5. 清理和关闭 ---
    GDALClose(poDstDS);
    GDALClose(poJoinDS);
    GDALClose(poTargetDS);

    // --- 6. 加载结果到QGIS ---

    QString layerProviderOptions;
    if (strcmp(pszDriverName, "ESRI Shapefile") == 0) {
        // 告诉QGIS，这个Shapefile是用UTF-8编码的
        layerProviderOptions = " réelcodage=UTF-8";
    }

    QgsVectorLayer* newLayer = new QgsVectorLayer(outputPath, QFileInfo(outputPath).baseName(), "ogr");
    if (newLayer->isValid()) {
        QgsProject::instance()->addMapLayer(newLayer);
        QMessageBox::information(this, "成功", "空间连接完成！\n输出文件: " + outputPath);
        accept();
    }
    else {
        QMessageBox::critical(this, "加载错误", "空间连接结果已生成，但加载到地图失败: " + outputPath + "\n" + newLayer->error().message());
        if (newLayer) delete newLayer;
    }

    CPLSetConfigOption("SHAPE_ENCODING", nullptr); // 恢复默认，避免影响程序其他部分
}
正在处理文件: ZonalStatisticsDialog.cpp
(ZonalStatisticsDialog.cpp)
// ZonalStatisticsDialog.cpp
#include "ZonalStatisticsDialog.h"
#include <algorithm>
#include <limits> // Required for std::numeric_limits
#include <QVBoxLayout>
#include <QHBoxLayout>
#include <QGridLayout>
#include <QLabel>
#include <QComboBox>
#include <QPushButton>
#include <QLineEdit>
#include <QFileDialog>
#include <QMessageBox>
#include <QStandardPaths>
#include <QFileInfo>
#include <QSpinBox>
#include <QProgressBar> // 虽然单线程，但QProgressDialog会用到
#include <QProgressDialog> // 用于单线程的进度反馈
#include <QApplication>    // For QCoreApplication::processEvents()
#include <QDesktopServices> // +++ 用于打开文件或URL +++
#include <QUrl>             // +++ 用于构造本地文件URL +++

#include <qgsproject.h>
#include <qgsvectorlayer.h>
#include <qgsrasterlayer.h>
#include <qgsfeature.h>
#include <qgsgeometry.h>
#include <qgsrectangle.h>
#include <qgsrasterblock.h>
#include <qgsfields.h>
#include <qgscoordinatereferencesystem.h>
#include <qgsunittypes.h>     // For Qgis::DistanceUnit, QgsUnitTypes
#include <qgsdistancearea.h>  // For unit conversion
#include "Output_Manager.h"
#include <QDebug>

// GDAL includes
#include "gdal_priv.h"
#include "ogr_spatialref.h" // For OGRSpatialReference, OGRCoordinateTransformation
#include "ogr_geometry.h"   // For OGRGeometry, OGRPoint etc.
#include "cpl_conv.h"       // For CPLStrdup, CPLFree
#include "cpl_string.h"     // For CSL functions (if used)

// 构造函数
ZonalStatisticsDialog::ZonalStatisticsDialog(QWidget* parent)
    : QDialog(parent),
    m_currentVectorLayer(nullptr),
    m_currentRasterLayer(nullptr)
    // m_taskRunning is removed
{
    setWindowTitle("分区统计");
    setMinimumWidth(600); // 调整宽度以容纳所有控件
    setupUI();
    populateVectorLayerComboBox();
    populateRasterLayerComboBox();
    // populateZoneIdFieldComboBox(); // 由 onVectorLayerChanged 调用

    // 连接核心信号槽
    connect(m_vectorLayerCombo, QOverload<int>::of(&QComboBox::currentIndexChanged), this, &ZonalStatisticsDialog::onVectorLayerChanged);
    connect(m_rasterLayerCombo, QOverload<int>::of(&QComboBox::currentIndexChanged), this, &ZonalStatisticsDialog::onRasterLayerChanged);
    connect(m_btnOk, &QPushButton::clicked, this, &ZonalStatisticsDialog::onOkClicked);
    connect(m_btnCancel, &QPushButton::clicked, this, &QDialog::reject);
    // m_btnCancelTask is removed

    // 文件选择按钮的连接
    connect(m_btnSelectVectorFile, &QPushButton::clicked, this, &ZonalStatisticsDialog::onSelectVectorLayerClicked);
    connect(m_btnSelectRasterFile, &QPushButton::clicked, this, &ZonalStatisticsDialog::onSelectRasterLayerClicked);
    connect(m_btnSelectOutputTable, &QPushButton::clicked, this, &ZonalStatisticsDialog::onSelectOutputTableClicked);
}

ZonalStatisticsDialog::~ZonalStatisticsDialog()
{
}

void ZonalStatisticsDialog::setupUI()
{
    QVBoxLayout* mainLayout = new QVBoxLayout(this);
    QGridLayout* gridLayout = new QGridLayout();
    int gridRow = 0;

    // 1. 输入矢量分区图层
    gridLayout->addWidget(new QLabel("分区图层 (矢量面):", this), gridRow, 0);
    m_vectorLayerCombo = new QComboBox(this);
    gridLayout->addWidget(m_vectorLayerCombo, gridRow, 1);
    m_btnSelectVectorFile = new QPushButton("从文件...", this); // 可以启用
    gridLayout->addWidget(m_btnSelectVectorFile, gridRow, 2);
    gridRow++;
    m_lblSelectedVectorInfo = new QLabel("当前选择: 无", this);
    m_lblSelectedVectorInfo->setWordWrap(true);
    gridLayout->addWidget(m_lblSelectedVectorInfo, gridRow, 0, 1, 3);

    gridRow++;
    // 2. 输入值栅格图层
    gridLayout->addWidget(new QLabel("值栅格图层:", this), gridRow, 0);
    m_rasterLayerCombo = new QComboBox(this);
    gridLayout->addWidget(m_rasterLayerCombo, gridRow, 1);
    m_btnSelectRasterFile = new QPushButton("从文件...", this); // 可以启用
    gridLayout->addWidget(m_btnSelectRasterFile, gridRow, 2);
    gridRow++;
    m_lblSelectedRasterInfo = new QLabel("当前选择: 无", this);
    m_lblSelectedRasterInfo->setWordWrap(true);
    gridLayout->addWidget(m_lblSelectedRasterInfo, gridRow, 0, 1, 3);

    gridRow++;
    // 3. 统计栅格波段
    m_lblRasterBand = new QLabel("统计栅格波段:", this);
    gridLayout->addWidget(m_lblRasterBand, gridRow, 0);
    m_spinRasterBand = new QSpinBox(this);
    m_spinRasterBand->setMinimum(1);
    m_spinRasterBand->setValue(1);
    m_spinRasterBand->setEnabled(false); // 初始禁用
    gridLayout->addWidget(m_spinRasterBand, gridRow, 1, 1, 2);

    gridRow++;
    // 4. 区域标识字段 (可选)
    m_lblZoneIdField = new QLabel("区域标识字段 (可选):", this);
    gridLayout->addWidget(m_lblZoneIdField, gridRow, 0);
    m_zoneIdFieldCombo = new QComboBox(this);
    m_zoneIdFieldCombo->setToolTip("选择分区图层中用于在输出表中唯一标识区域的字段。\n如果未选择，将使用要素的内部FID。");
    gridLayout->addWidget(m_zoneIdFieldCombo, gridRow, 1, 1, 2);

    gridRow++;
    // 5. 输出统计表格路径
    gridLayout->addWidget(new QLabel("输出统计表格:", this), gridRow, 0);
    m_editOutputTablePath = new QLineEdit(this);
    m_editOutputTablePath->setPlaceholderText("例如: C:/output/zonal_stats.csv");
    gridLayout->addWidget(m_editOutputTablePath, gridRow, 1);
    m_btnSelectOutputTable = new QPushButton("浏览...", this);
    gridLayout->addWidget(m_btnSelectOutputTable, gridRow, 2);

    mainLayout->addLayout(gridLayout);
    // 移除进度条和取消任务按钮，因为我们现在是单线程模态操作
    mainLayout->addStretch();

    // 6. OK 和 Cancel 按钮
    QHBoxLayout* buttonLayout = new QHBoxLayout();
    buttonLayout->addStretch();
    m_btnOk = new QPushButton("确定", this);
    m_btnCancel = new QPushButton("取消", this);
    buttonLayout->addWidget(m_btnOk);
    buttonLayout->addWidget(m_btnCancel);
    mainLayout->addLayout(buttonLayout);

    setLayout(mainLayout);
}


void ZonalStatisticsDialog::populateVectorLayerComboBox()
{
    m_vectorLayerCombo->clear();
    m_vectorLayerCombo->addItem("--- 从项目中选择分区图层 ---", QVariant());
    QList<QgsMapLayer*> layers = QgsProject::instance()->mapLayers().values();
    for (QgsMapLayer* layer : layers) {
        if (auto vlayer = qobject_cast<QgsVectorLayer*>(layer)) {
            // 确保是面图层
            Qgis::WkbType wkbType = vlayer->wkbType(); // 获取图层的WKB类型
            Qgis::GeometryType geomType = QgsWkbTypes::geometryType(wkbType); // 解析几何大类

            if (geomType == Qgis::GeometryType::Polygon) { // 只显示面图层
                m_vectorLayerCombo->addItem(vlayer->name(), QVariant::fromValue(vlayer));
            }
        }
    }
    onVectorLayerChanged(); // 更新初始状态
}

void ZonalStatisticsDialog::populateRasterLayerComboBox()
{
    m_rasterLayerCombo->clear();
    m_rasterLayerCombo->addItem("--- 从项目中选择栅格图层 ---", QVariant());
    QList<QgsMapLayer*> layers = QgsProject::instance()->mapLayers().values();
    for (QgsMapLayer* layer : layers) {
        if (auto rlayer = qobject_cast<QgsRasterLayer*>(layer)) {
            m_rasterLayerCombo->addItem(rlayer->name(), QVariant::fromValue(rlayer));
        }
    }
    onRasterLayerChanged(); // 更新初始状态
}

void ZonalStatisticsDialog::populateZoneIdFieldComboBox()
{
    m_zoneIdFieldCombo->clear();
    m_zoneIdFieldCombo->addItem("--- 使用要素FID ---", QString()); // 默认选项
    if (m_currentVectorLayer) {
        const QgsFields fields = m_currentVectorLayer->fields();
        for (int i = 0; i < fields.count(); ++i) {
            m_zoneIdFieldCombo->addItem(fields.field(i).name() + " (" + fields.field(i).typeName() + ")",
                fields.field(i).name());
        }
    }
}

void ZonalStatisticsDialog::onSelectVectorLayerClicked()
{
    QString filePath = QFileDialog::getOpenFileName(this, "选择分区矢量文件",
        QStandardPaths::writableLocation(QStandardPaths::HomeLocation),
        "Shapefile (*.shp);;GeoPackage (*.gpkg);;所有矢量文件 (*.*)");
    if (!filePath.isEmpty()) {
        // 为了简化，我们要求用户从文件选择后，需要手动在下拉框中选择它（如果已加载）
        // 或者，我们可以创建一个临时的QgsVectorLayer来更新UI，并在OK时使用路径
        // 这里我们只更新路径和标签，让onOkClicked处理临时加载（如果需要）
        // m_currentInputLayerPath = filePath; // 如果有这个成员变量
        m_lblSelectedVectorInfo->setText(QString("文件待加载: %1").arg(QFileInfo(filePath).fileName()));
        m_vectorLayerCombo->setCurrentIndex(0); // 清除项目选择
        m_currentVectorLayer = nullptr; // 清除项目图层指针
        populateZoneIdFieldComboBox(); // 清空字段列表
        //  updateDefaultOutputPath();
    }
}

void ZonalStatisticsDialog::onSelectRasterLayerClicked()
{
    QString filePath = QFileDialog::getOpenFileName(this, "选择值栅格文件",
        QStandardPaths::writableLocation(QStandardPaths::HomeLocation),
        "GeoTIFF (*.tif *.tiff);;Erdas Imagine (*.img);;所有文件 (*.*)");
    if (!filePath.isEmpty()) {
        m_lblSelectedRasterInfo->setText(QString("文件待加载: %1").arg(QFileInfo(filePath).fileName()));
        m_rasterLayerCombo->setCurrentIndex(0);
        m_currentRasterLayer = nullptr;
        m_spinRasterBand->setEnabled(false);
        // updateDefaultOutputPath();
    }
}

void ZonalStatisticsDialog::onVectorLayerChanged()
{
    m_currentVectorLayer = nullptr;
    m_currentZoneIdFieldName.clear();
    if (m_vectorLayerCombo->currentIndex() > 0) {
        QVariant data = m_vectorLayerCombo->currentData();
        QgsVectorLayer* layer = qvariant_cast<QgsVectorLayer*>(data);
        if (layer && QgsProject::instance()->mapLayer(layer->id())) {
            m_currentVectorLayer = layer;
            m_lblSelectedVectorInfo->setText(QString("当前选择: %1").arg(layer->name()));
        }
    }
    else {
        // 如果是“文件待加载”，文本已在onSelect...中设置
        if (!m_lblSelectedVectorInfo->text().startsWith("文件待加载:")) {
            m_lblSelectedVectorInfo->setText("当前选择: 无");
        }
    }
    populateZoneIdFieldComboBox();
    // updateDefaultOutputPath();
}

void ZonalStatisticsDialog::onRasterLayerChanged()
{
    m_currentRasterLayer = nullptr;
    m_spinRasterBand->setEnabled(false);
    if (m_rasterLayerCombo->currentIndex() > 0) {
        QVariant data = m_rasterLayerCombo->currentData(); // 修复错误：添加参数  
        QgsRasterLayer* layer = qvariant_cast<QgsRasterLayer*>(data);
        if (layer && QgsProject::instance()->mapLayer(layer->id())) {
            m_currentRasterLayer = layer;
            m_lblSelectedRasterInfo->setText(QString("当前选择: %1").arg(layer->name()));
            m_spinRasterBand->setMaximum(layer->bandCount());
            m_spinRasterBand->setEnabled(true);
        }
    }
    else {
        if (!m_lblSelectedRasterInfo->text().startsWith("文件待加载:")) {
            m_lblSelectedRasterInfo->setText("当前选择: 无");
        }
    }
    // updateDefaultOutputPath();
}


void ZonalStatisticsDialog::onSelectOutputTableClicked()
{
    QString defaultPath = QStandardPaths::writableLocation(QStandardPaths::DocumentsLocation);
    if (m_currentVectorLayer) { // 基于矢量图层名生成默认输出
        defaultPath = QDir(QgsProject::instance()->homePath()).filePath(m_currentVectorLayer->name() + "_zonal_stats.csv");
    }

    QString filePath = QFileDialog::getSaveFileName(this, "选择输出统计表格路径",
        defaultPath,
        "CSV 文件 (*.csv)");
    if (!filePath.isEmpty()) {
        if (QFileInfo(filePath).suffix().compare("csv", Qt::CaseInsensitive) != 0) {
            filePath += ".csv";
        }
        m_editOutputTablePath->setText(filePath);
    }
}

ZonalStatResult ZonalStatisticsDialog::calculateStatsForSingleFeature(
    const QgsGeometry& featureGeomConst,
    const QgsCoordinateReferenceSystem& featureCrs,
    GDALRasterBand* poBand, // 传入已打开的波段 (由调用者管理生命周期)
    const double adfGeoTransform[6], // 传入地理变换参数 (由调用者管理生命周期)
    const QgsCoordinateReferenceSystem& rasterCrs,
    int bandNumForLog,
    QgsFeatureId featureId,
    const QVariant& zoneValue)
{
    ZonalStatResult result;
    result.featureId = featureId;
    result.originalZoneFieldValue = zoneValue;
    result.success = false;

    qDebug().noquote() << QString("[ZonalCalc FID: %1] Start. ZoneValue: %2").arg(featureId).arg(zoneValue.toString());

    char* pszWktFromQgsFeature = nullptr;
    char* pszWktFromQgsRasterCrs = nullptr;

    OGRGeometry* ogrGeom = nullptr;
    OGRCoordinateTransformation* poTransform = nullptr;
    char* pszWktFromQgsFeature_geom = nullptr;
    char* pszWktFromQgsFeature_srs = nullptr;
    char* pszWktFromQgsRaster_srs = nullptr;

    // --- 1. WKT to OGRGeometry ---
    QString wktString = featureGeomConst.asWkt();
    if (wktString.isEmpty()) {
        result.errorMessage = "Feature geometry WKT is empty.";
        qDebug().noquote() << QString("[ZonalCalc FID: %1] ERROR: %2").arg(featureId).arg(result.errorMessage);
        return result; // Early return
    }
    QByteArray wktUtf8 = wktString.toUtf8();
    pszWktFromQgsFeature_geom = CPLStrdup(wktUtf8.constData());
    if (!pszWktFromQgsFeature_geom) {
        result.errorMessage = "CPLStrdup failed for feature WKT.";
        qDebug().noquote() << QString("[ZonalCalc FID: %1] ERROR: %2").arg(featureId).arg(result.errorMessage);
        return result; // Early return
    }

    char* tempWktPtr_geom = pszWktFromQgsFeature_geom; // Create a non-const pointer for OGR
    OGRErr ogrErr = OGRGeometryFactory::createFromWkt(&tempWktPtr_geom, nullptr, &ogrGeom);

    if (ogrErr != OGRERR_NONE || !ogrGeom) {
        result.errorMessage = "OGRGeometryFactory::createFromWkt failed. OGR Err: " + QString::number(ogrErr);
        CPLFree(pszWktFromQgsFeature_geom); // Clean before return
        if (ogrGeom) OGRGeometryFactory::destroyGeometry(ogrGeom); // Should be nullptr if ogrErr != OGRERR_NONE
        return result;
    }
    if (ogrGeom->IsEmpty() || !ogrGeom->IsValid()) {
        result.errorMessage = "Created OGRGeometry is empty or invalid.";
        CPLFree(pszWktFromQgsFeature_geom); // Clean before return
        OGRGeometryFactory::destroyGeometry(ogrGeom);
        return result;
    }
    CPLFree(pszWktFromQgsFeature_geom); pszWktFromQgsFeature_geom = nullptr; // Free as soon as no longer needed
    qDebug().noquote() << QString("[ZonalCalc FID: %1] OGRGeometry created successfully.").arg(featureId);

    // --- 2. CRS Transformation if needed ---
    OGRSpatialReference ogrFeatureSRS, ogrRasterSRS_param;
    QByteArray featureCrsWktUtf8 = featureCrs.toWkt().toUtf8();
    pszWktFromQgsFeature_srs = CPLStrdup(featureCrsWktUtf8.constData());
    QByteArray rasterCrsWktUtf8 = rasterCrs.toWkt().toUtf8();
    pszWktFromQgsRaster_srs = CPLStrdup(rasterCrsWktUtf8.constData());

    if (!pszWktFromQgsFeature_srs || !pszWktFromQgsRaster_srs) {
        result.errorMessage = "CPLStrdup failed for CRS WKTs.";
        if (pszWktFromQgsFeature_srs) CPLFree(pszWktFromQgsFeature_srs);
        if (pszWktFromQgsRaster_srs) CPLFree(pszWktFromQgsRaster_srs);
        OGRGeometryFactory::destroyGeometry(ogrGeom); // Clean previous
        return result;
    }

    char* tempWktPtr_featureSrs = pszWktFromQgsFeature_srs;
    char* tempWktPtr_rasterSrs = pszWktFromQgsRaster_srs;
    if (ogrFeatureSRS.importFromWkt(&tempWktPtr_featureSrs) != OGRERR_NONE ||
        ogrRasterSRS_param.importFromWkt(&tempWktPtr_rasterSrs) != OGRERR_NONE) {
        result.errorMessage = "Import WKT to OGRSpatialReference failed.";
        CPLFree(pszWktFromQgsFeature_srs); CPLFree(pszWktFromQgsRaster_srs);
        OGRGeometryFactory::destroyGeometry(ogrGeom);
        return result;
    }
    CPLFree(pszWktFromQgsFeature_srs); pszWktFromQgsFeature_srs = nullptr;
    CPLFree(pszWktFromQgsRaster_srs);  pszWktFromQgsRaster_srs = nullptr;
    qDebug().noquote() << QString("[ZonalCalc FID: %1] SRS imported successfully.").arg(featureId);

    if (!ogrFeatureSRS.IsSame(&ogrRasterSRS_param)) {
        qDebug().noquote() << QString("[ZonalCalc FID: %1] CRS mismatch. Transforming geometry...").arg(featureId);
        poTransform = OGRCreateCoordinateTransformation(&ogrFeatureSRS, &ogrRasterSRS_param);
        if (!poTransform) {
            result.errorMessage = "OGRCreateCoordinateTransformation failed.";
            OGRGeometryFactory::destroyGeometry(ogrGeom);
            return result;
        }
        if (ogrGeom->transform(poTransform) != OGRERR_NONE) {
            result.errorMessage = "ogrGeom->transform() failed.";
            OGRGeometryFactory::destroyGeometry(ogrGeom);
            OGRCoordinateTransformation::DestroyCT(poTransform);
            return result;
        }
        qDebug().noquote() << QString("[ZonalCalc FID: %1] Geometry transformed successfully.").arg(featureId);
    }
    else { /* ... */ }

    // --- 3. 获取NoData值 (直接使用传入的poBand) ---
    int bGotNoData = 0;
    double noDataValue = poBand->GetNoDataValue(&bGotNoData);
    qDebug().noquote() << QString("[ZonalCalc FID: %1] Band %2 NoData: %3 (Flag: %4)")
        .arg(featureId).arg(bandNumForLog)
        .arg(bGotNoData ? QString::number(noDataValue) : "N/A").arg(bGotNoData);

    // --- 4. Calculate pixel window ---
    double invGeoTransform[6];
    if (!GDALInvGeoTransform(const_cast<double*>(adfGeoTransform), invGeoTransform)) { /* ... error, cleanup, return ... */ }
    // ... (Full pixel window calculation as in your previous version) ...
    // ... (Ensure readXSize, readYSize are correctly calculated and checked) ...
    OGREnvelope ogrEnv; // Declare OGREnvelope
    ogrGeom->getEnvelope(&ogrEnv); // Use it
    // ... (rest of your xOff, yOff, reqXSize, reqYSize, readXOff etc. calculation)
    // Ensure reqXSize and reqYSize are declared before the if/else block that uses them if you split that.
    int xOff, yOff, reqXSize, reqYSize, xEnd, yEnd; // Declare them
    // (Your pixel window calculation logic here - ensure it's correct)
    double ulx, uly, lrx, lry;
    ulx = ogrEnv.MinX; uly = ogrEnv.MaxY;
    lrx = ogrEnv.MaxX; lry = ogrEnv.MinY;

    int pix_ulx = static_cast<int>(std::floor(invGeoTransform[0] + invGeoTransform[1] * ulx + invGeoTransform[2] * uly));
    int pix_uly = static_cast<int>(std::floor(invGeoTransform[3] + invGeoTransform[4] * ulx + invGeoTransform[5] * uly));
    int pix_lrx = static_cast<int>(std::ceil(invGeoTransform[0] + invGeoTransform[1] * lrx + invGeoTransform[2] * lry));
    int pix_lry = static_cast<int>(std::ceil(invGeoTransform[3] + invGeoTransform[4] * lrx + invGeoTransform[5] * lry));

    xOff = std::min(pix_ulx, pix_lrx);
    yOff = std::min(pix_uly, pix_lry);
    reqXSize = std::max(pix_ulx, pix_lrx) - xOff + 1;
    reqYSize = std::max(pix_uly, pix_lry) - yOff + 1;


    int rasterWidth = poBand->GetXSize();
    int rasterHeight = poBand->GetYSize();
    int readXOff = std::max(0, xOff);
    int readYOff = std::max(0, yOff);
    int readXSize = std::min(reqXSize, rasterWidth - readXOff);
    int readYSize = std::min(reqYSize, rasterHeight - readYOff);


    if (readXSize <= 0 || readYSize <= 0) {
        result.errorMessage = "Feature does not effectively overlap raster.";
        result.success = true; result.count = 0;
        OGRGeometryFactory::destroyGeometry(ogrGeom);
        if (poTransform) OGRCoordinateTransformation::DestroyCT(poTransform);
        return result;
    }

    // --- 5. 读取像元数据 ---
    std::vector<float> rasterData(static_cast<size_t>(readXSize) * readYSize);
    CPLErr ioErr = poBand->RasterIO(GF_Read, readXOff, readYOff, readXSize, readYSize,
        rasterData.data(), readXSize, readYSize, GDT_Float32,
        0, 0, nullptr);
    if (ioErr != CE_None) {
        result.errorMessage = "GDAL RasterIO failed. Error: " + QString(CPLGetLastErrorMsg());
    }
    qDebug().noquote() << QString("[ZonalCalc FID: %1] RasterIO successful. Buffer size: %2").arg(featureId).arg(rasterData.size());

    // --- 6. 统计循环 ---
    double minVal = std::numeric_limits<double>::max();
    double maxVal = -std::numeric_limits<double>::max();
    double sum = 0.0;
    long count = 0;

    for (int y = 0; y < readYSize; ++y) {
        for (int x = 0; x < readXSize; ++x) {
            double geoX = adfGeoTransform[0] + (readXOff + x + 0.5) * adfGeoTransform[1] + (readYOff + y + 0.5) * adfGeoTransform[2];
            double geoY = adfGeoTransform[3] + (readXOff + x + 0.5) * adfGeoTransform[4] + (readYOff + y + 0.5) * adfGeoTransform[5];
            OGRPoint pt;
            pt.assignSpatialReference(&ogrRasterSRS_param); // Point is in raster CRS
            pt.setX(geoX);
            pt.setY(geoY);

            if (ogrGeom->Intersects(&pt)) { // ogrGeom is also in raster CRS
                float val = rasterData[static_cast<size_t>(y) * readXSize + x];
                if (bGotNoData && qAbs(static_cast<double>(val) - noDataValue) < 1e-9) {
                    continue;
                }
                if (count == 0) { minVal = maxVal = val; }
                else {
                    if (val < minVal) minVal = val;
                    if (val > maxVal) maxVal = val;
                }
                sum += val;
                ++count;
            }
        }
    }

    result.count = count;
    if (count > 0) {
        result.sum = sum;
        result.min = minVal;
        result.max = maxVal;
        result.mean = sum / count;
    }
    else {
        double nanOrNoData = bGotNoData ? noDataValue : std::numeric_limits<double>::quiet_NaN();
        result.min = result.max = result.sum = result.mean = nanOrNoData;
        result.errorMessage = "No valid raster cells found within the feature zone.";
    }
    result.success = true; // Mark as success if processing finished, even if no cells
    qDebug().noquote() << QString("[ZonalCalc FID: %1] Statistics calculated.").arg(featureId);

cleanup:
    // 统一的清理代码
    if (pszWktFromQgsFeature) CPLFree(pszWktFromQgsFeature);
    if (pszWktFromQgsRasterCrs) CPLFree(pszWktFromQgsRasterCrs);
    // pszWktForOgrFeature 和 pszWktForOgrRasterCrs 只是指向上面两个的指针，不需要单独释放

    if (ogrGeom) OGRGeometryFactory::destroyGeometry(ogrGeom);
    if (poTransform) OGRCoordinateTransformation::DestroyCT(poTransform);
    // poBand 是外部传入的，不由本函数管理

    qDebug().noquote() << QString("[ZonalCalc FID: %1] Finished. Success: %2. Msg: %3")
        .arg(featureId).arg(result.success).arg(result.errorMessage);
    return result;
}

void ZonalStatisticsDialog::onOkClicked()
{
    // 1. 参数获取与验证  
    if (!m_currentVectorLayer || !m_currentRasterLayer) {
        QMessageBox::warning(this, "输入错误", "请选择有效的分区图层和值栅格图层。");
        return;
    }
    QString outputPath = m_editOutputTablePath->text();
    if (outputPath.isEmpty()) {
        QMessageBox::warning(this, "输入错误", "请输入输出统计表格的路径。");
        return;
    }
    int bandNum = m_spinRasterBand->value();
    if (bandNum <= 0 || bandNum > m_currentRasterLayer->bandCount()) {
        QMessageBox::warning(this, "输入错误", QString("选择的波段号(%1)无效。").arg(bandNum));
        return;
    }
    m_currentZoneIdFieldName = m_zoneIdFieldCombo->currentData().toString(); // 如果是空字符串，则用FID  

    // 2. UI准备  
    m_btnOk->setEnabled(false);
    m_btnCancel->setEnabled(false);
    QApplication::setOverrideCursor(Qt::WaitCursor);

    // +++ 创建一个布尔标志来跟踪用户是否真的点击了进度对话框的取消按钮 +++
    bool userManuallyCanceled = false;

    QProgressDialog progressDialog("正在执行分区统计...", "取消", 0, 0, this);
    progressDialog.setWindowModality(Qt::WindowModal);
    progressDialog.setMinimumDuration(0); // 立即显示  
    progressDialog.setAutoClose(false); // **重要：禁止进度条在达到100%时自动关闭**
    progressDialog.setAutoReset(false); // **重要：禁止进度条在达到100%时自动重置**
    // +++ 连接进度对话框的 canceled() 信号 +++
    connect(&progressDialog, &QProgressDialog::canceled, this, [&userManuallyCanceled]() {
        userManuallyCanceled = true;
        OutputManager::instance()->logMessage("用户通过进度对话框点击了取消。");
        });

    // 3. 准备输入数据  
    QgsFeatureIterator iterator = m_currentVectorLayer->getFeatures();
    QgsFeature feature;
    QList<QgsFeature> featuresToProcess;
    while (iterator.nextFeature(feature)) {
        featuresToProcess.append(feature);
    }

    if (featuresToProcess.isEmpty()) {
        QMessageBox::information(this, "提示", "输入矢量图层中没有要素。");
        QApplication::restoreOverrideCursor();
        m_btnOk->setEnabled(true);
        m_btnCancel->setEnabled(true);
        progressDialog.close();
        return;
    }
    progressDialog.setMaximum(featuresToProcess.count());
    progressDialog.setValue(0); // 确保从0开始
    progressDialog.show();
    QCoreApplication::processEvents(); // 确保对话框显示

    OutputManager::instance()->logMessage("开始单线程分区统计...");
    QList<ZonalStatResult> allResults;

    // === 4. 打开GDAL资源 (仅一次) ===  
    GDALAllRegister();
    OGRRegisterAll();

    QString rasterPath = m_currentRasterLayer->source();
    QgsCoordinateReferenceSystem rasterCrs = m_currentRasterLayer->crs();

    GDALDataset* poMainRasterDS = (GDALDataset*)GDALOpen(rasterPath.toUtf8().constData(), GA_ReadOnly);
    if (!poMainRasterDS) {
        QMessageBox::critical(this, "GDAL错误", "无法打开栅格文件进行统计: " + rasterPath + "\n" + CPLGetLastErrorMsg());
        QApplication::restoreOverrideCursor();
        m_btnOk->setEnabled(true);
        m_btnCancel->setEnabled(true);
        progressDialog.close();
        return;
    }
    GDALRasterBand* poMainBand = poMainRasterDS->GetRasterBand(bandNum);
    if (!poMainBand) {
        QMessageBox::critical(this, "GDAL错误", QString("无法从 %1 获取波段 %2").arg(rasterPath).arg(bandNum) + "\n" + CPLGetLastErrorMsg());
        GDALClose(poMainRasterDS);
        QApplication::restoreOverrideCursor();
        m_btnOk->setEnabled(true);
        m_btnCancel->setEnabled(true);
        progressDialog.close();
        return;
    }
    double adfMainGeoTransform[6];
    if (poMainRasterDS->GetGeoTransform(adfMainGeoTransform) != CE_None) {
        QMessageBox::critical(this, "GDAL错误", "无法获取栅格文件的GeoTransform。\n" + QString(CPLGetLastErrorMsg()));
        GDALClose(poMainRasterDS);
        QApplication::restoreOverrideCursor();
        m_btnOk->setEnabled(true);
        m_btnCancel->setEnabled(true);
        progressDialog.close();
        return;
    }
    // ===================================  

    // 5. 单线程循环处理  
    for (int i = 0; i < featuresToProcess.count(); ++i) {
        const QgsFeature& feat = featuresToProcess.at(i);
        if (progressDialog.wasCanceled()) {
            OutputManager::instance()->logMessage("用户取消了分区统计。");
            break;
        }

        QVariant zoneIdVal = m_currentZoneIdFieldName.isEmpty() ? QVariant(feat.id()) : feat.attribute(m_currentZoneIdFieldName);

        const QgsCoordinateReferenceSystem& featureCrs = m_currentVectorLayer->crs();

        ZonalStatResult singleResult = calculateStatsForSingleFeature(
            feat.geometry(),
            featureCrs, // 传递要素的精确CRS  
            poMainBand, // **传递已打开的波段**  
            adfMainGeoTransform, // **传递已获取的地理变换**  
            rasterCrs,  // 传递栅格的CRS  
            bandNum,    // 用于日志  
            feat.id(),
            zoneIdVal
        );
        allResults.append(singleResult);

        progressDialog.setValue(i + 1);
        QCoreApplication::processEvents(); // 允许UI刷新和事件处理
    }

    // 6. 清理GDAL资源  
    if (poMainRasterDS) {
        GDALClose(poMainRasterDS);
    }

    // 7. UI恢复
    // **核心修改：在循环结束后，再判断最终的取消状态**
    bool finalCanceledState = userManuallyCanceled || progressDialog.wasCanceled();
    // 即使循环正常结束，如果progressDialog因为某种原因（例如用户在最后时刻按ESC）
    // 变成了canceled状态，我们也认为是取消。

    if (!progressDialog.isHidden()) { // 如果进度对话框仍然可见
        progressDialog.setValue(progressDialog.maximum()); // 确保满进度
        progressDialog.close(); // 手动关闭它
    }
    QApplication::restoreOverrideCursor();
    m_btnOk->setEnabled(true);
    m_btnCancel->setEnabled(true);

    if (finalCanceledState && allResults.size() < featuresToProcess.count()) { // 确保是真的被中途中断
        QMessageBox::information(this, "操作取消", "分区统计已被用户取消或中断。");
        return;
    }

    // 8. 结果写入CSV  
    bool anyErrors = false;
    for (const auto& res : allResults) {
        if (!res.success && !res.errorMessage.isEmpty()) {
            OutputManager::instance()->logError(QString("FID %1 统计错误: %2").arg(res.featureId).arg(res.errorMessage));
            anyErrors = true;
        }
    }
    if (anyErrors) {
        QMessageBox::warning(this, "统计完成（有错误）", "部分区域统计失败，请查看日志。");
    }

    QFile outputFile(outputPath);
    if (!outputFile.open(QIODevice::WriteOnly | QIODevice::Text)) {
        QMessageBox::critical(this, "文件错误", "无法写入输出文件: " + outputPath);
        return;
    }
    QTextStream outStream(&outputFile);
    outStream.setCodec("UTF-8"); // 确保是UTF-8
    outStream << "FeatureID,ZoneValue,Min,Max,Sum,Mean,Count,Status,ErrorMessage\n";
    for (const ZonalStatResult& res : allResults) {
        outStream << res.featureId << ","
            << res.originalZoneFieldValue.toString().replace(",", ";") << ","
            << res.min << "," << res.max << "," << res.sum << "," << res.mean << "," << res.count << ","
            << (res.success ? "Success" : "Failed") << ","
            << QString(res.errorMessage).replace(",", ";") << "\n";
    }
    outputFile.close();

    // 9.带“打开文件”按钮的成功提示
    QMessageBox successMsgBox(this);
    successMsgBox.setWindowTitle("成功");
    successMsgBox.setIcon(QMessageBox::Information);
    successMsgBox.setText("分区统计已完成！");
    successMsgBox.setInformativeText(QString("结果已保存到:\n%1").arg(outputPath));

    QPushButton* openButton = successMsgBox.addButton("打开文件", QMessageBox::ActionRole);
    successMsgBox.addButton("确定", QMessageBox::AcceptRole); // 或者 OKRole

    successMsgBox.exec();

    if (successMsgBox.clickedButton() == openButton) {
        // 使用 QDesktopServices 打开文件
        // fromLocalFile 会处理好路径中的特殊字符和转换为URL格式
        bool opened = QDesktopServices::openUrl(QUrl::fromLocalFile(outputPath));
        if (!opened) {
            QMessageBox::warning(this, "打开失败", "无法使用默认程序打开文件:\n" + outputPath);
        }
    }
    // =================================================================================


    accept();
}
正在处理文件: AnalysisToolboxWidget.h
(AnalysisToolboxWidget.h)
// AnalysisToolboxWidget.h
#ifndef ANALYSISTOOLBOXWIDGET_H
#define ANALYSISTOOLBOXWIDGET_H

#include <QWidget>
#include <QStandardItemModel> // 我们用QStandardItemModel来构建树

// 前向声明
class QTreeView;
class QStandardItem;
class QModelIndex;

// 定义一个枚举或常量来唯一标识每个工具
enum class AnalysisToolId {
    SpatialJoin,
    Buffer,
    RasterStats,
    RasterClip,
    RasterResample,
    RasterReproject,
    ZonalStats
    // ... 可以继续添加
};
// 将工具ID存储在QStandardItem的UserRole中
const int ToolIdRole = Qt::UserRole + 1;


class AnalysisToolboxWidget : public QWidget
{
    Q_OBJECT

public:
    explicit AnalysisToolboxWidget(QWidget* parent = nullptr);
    ~AnalysisToolboxWidget();

private slots:
    // 当用户双击树中的项时调用
    void onItemDoubleClicked(const QModelIndex& index);

private:
    void setupUI();
    void populateToolTree(); // 填充工具树的内容

    QTreeView* m_toolTreeView;
    QStandardItemModel* m_toolModel;
};

#endif // ANALYSISTOOLBOXWIDGET_H
正在处理文件: AttributeTableDialog.h
(AttributeTableDialog.h)
#include <QDialog>
#include <QItemSelectionModel> // +++ 新增，用于获取选中行

// 前向声明
class QgsVectorLayer;
class QgsMapCanvas;
class QTableView;
class QgsAttributeTableModel;
class QgsAttributeTableFilterModel;
class QComboBox;
class QRadioButton;
class QPushButton;
class QLineEdit;

class AttributeTableDialog : public QDialog
{
    Q_OBJECT

public:
    explicit AttributeTableDialog(QgsVectorLayer* layer, QgsMapCanvas* canvas, QWidget* parent = nullptr);
    ~AttributeTableDialog();

private slots:
    // +++ 新增的槽函数 +++
    void onFieldSelectionChanged(int index);
    void onSortOrderToggle();
    void onSearchButtonClicked();
    void onFilterModeChanged(); // 响应排序/搜索模式的切换

    // +++ 新增槽函数 +++
    void onDeleteSelectedFeatures();

    void synchronizeTableSelectionWithLayer();

    void onInvertSelection();

private:
    void setupUI();
    void populateFieldsComboBox();
    void updateControlsState(); // 一个用于更新控件启用/禁用状态的辅助函数

    // UI 控件
    QTableView* m_tableView;
    QComboBox* m_fieldComboBox;
    QRadioButton* m_sortRadioButton;
    QRadioButton* m_searchRadioButton;
    QPushButton* m_sortOrderButton;
    QLineEdit* m_searchLineEdit;
    QPushButton* m_searchButton;
    QPushButton* m_deleteButton; // +++ 新增删除按钮 +++
    QPushButton* m_invertSelectionButton; // +++ 新增反选按钮 +++

    // 数据模型
    QgsVectorLayer* m_layer;
    QgsMapCanvas* m_canvas;
    QgsAttributeTableModel* m_tableModel;
    QgsAttributeTableFilterModel* m_filterModel;

    // 状态变量
    Qt::SortOrder m_currentSortOrder;

    // +++ 新增状态变量，用于控制删除提示只显示一次 +++
    bool m_deleteWarningShown;
};
正在处理文件: BufferDialog.h
(BufferDialog.h)
// BufferDialog.h
#ifndef BUFFERDIALOG_H
#define BUFFERDIALOG_H

#include <QDialog>
#include <qgis.h> // For Qgis::BufferCapStyle, Qgis::BufferJoinStyle
#include <qgsunittypes.h> // For Qgis::DistanceUnit

// 前向声明
class QComboBox;
class QPushButton;
class QLineEdit;
class QLabel;
class QgsVectorLayer;
class QDoubleSpinBox;
class QSpinBox;     // 用于线段数量 (segments)
class QCheckBox;    // 用于溶解结果
class QgsColorButton; // 用于颜色选择 (QGIS提供)

class BufferDialog : public QDialog
{
    Q_OBJECT

public:
    explicit BufferDialog(QWidget* parent = nullptr);
    ~BufferDialog();

    // 公共接口获取参数
    QgsVectorLayer* selectedInputLayer() const;
    double bufferDistance() const;
    Qgis::DistanceUnit distanceUnits() const;
    int segments() const;
    bool dissolveResult() const;
    QString outputLayerPath() const;
    QColor fillColor() const;       // 获取填充颜色
    double fillOpacity() const;   // 获取填充透明度 (0-1)
    QColor strokeColor() const;     // 获取边界颜色
    double strokeWidth() const;   // 获取边界宽度

private slots:
    void onSelectInputLayerClicked();
    void onSelectOutputLayerClicked();
    void onInputLayerChanged(); // 当输入图层改变时，尝试更新单位
    void onOkClicked();

private:
    void setupUI();
    void populateInputLayerComboBox();
    void populateUnitComboBox();
    void updateDefaultOutputPath();


    // UI 控件
    QComboBox* m_inputLayerCombo;
    QPushButton* m_btnSelectInputLayerFile;
    QLabel* m_lblSelectedInputLayerInfo;

    QDoubleSpinBox* m_spinBufferDistance;
    QComboBox* m_unitCombo;             // 单位选择
    QSpinBox* m_spinSegments;           // 端点平滑度
    QCheckBox* m_chkDissolveResult;     // 是否溶解

    QLineEdit* m_editOutputLayerPath;
    QPushButton* m_btnSelectOutputLayer;

    // 可视化参数
    QLabel* m_lblFillColor;
    QgsColorButton* m_btnFillColor;
    QLabel* m_lblFillOpacity;
    QDoubleSpinBox* m_spinFillOpacity; // 0-1 or 0-100%

    QLabel* m_lblStrokeColor;
    QgsColorButton* m_btnStrokeColor;
    QLabel* m_lblStrokeWidth;
    QDoubleSpinBox* m_spinStrokeWidth;


    QPushButton* m_btnOk;
    QPushButton* m_btnCancel;

    // 数据
    QgsVectorLayer* m_currentInputLayer; // 存储当前选择的输入矢量图层
};

#endif // BUFFERDIALOG_H
正在处理文件: CustomLayerTreeView.h
(CustomLayerTreeView.h)
#include <QWidget>
#include <QPoint>

// 前向声明
class QTreeView;
class QStandardItemModel;
class QStandardItem;
class QgsMapLayer;
class QgsMapCanvas;
class QModelIndex;
class QItemSelection;

class CustomLayerTreeView : public QWidget
{
    Q_OBJECT

public:
    explicit CustomLayerTreeView(QgsMapCanvas* canvas, QWidget* parent = nullptr);
    ~CustomLayerTreeView();
    void updateMapCanvasLayers();

signals:
    void modelChanged(); // 新增信号
    // +++ 新增信号，当选中项改变时发出 +++
    void currentLayerChanged(QgsMapLayer* layer);

public slots:
    void addLayer(QgsMapLayer* layer);
    void clear();

    // +++ 新增槽函数，响应QTreeView自身的选中事件 +++
    void onSelectionChanged(const QItemSelection& selected, const QItemSelection& deselected);

private slots:
    void onItemChanged(QStandardItem* item);
    void onCustomContextMenuRequested(const QPoint& pos);
    void onChangeLayerColor(QgsMapLayer* layer);

    // -- !! 新增的私有槽函数，用于处理排序 !! --
    void onMoveLayerUp(const QModelIndex& index);
    void onMoveLayerDown(const QModelIndex& index);

    // 置于顶层/底层
    void onMoveToTop(const QModelIndex& index);
    void onMoveToBottom(const QModelIndex& index);


private:
    void updateLayerItemIcon(QStandardItem* item, const QColor& color);
    void onRemoveLayer(const QModelIndex& index);

private:
    QTreeView* m_treeView;
    QStandardItemModel* m_model;
    QgsMapCanvas* m_mapCanvas;
};


正在处理文件: FeatureSelectionTool.h
(FeatureSelectionTool.h)
#include <qgsmaptoolidentify.h> // 使用这个基类，它为识别要素提供了便利
#include <qgsmapcanvas.h> // 确保包含QgsMapCanvas相关定义
#include <qgsmapmouseevent.h> // 确保包含QgsMapCanvasMouseEvent相关定义

class QgsMapCanvas;
class QgsVectorLayer;
class QgsFeature;

class FeatureSelectionTool : public QgsMapToolIdentify
{
    Q_OBJECT

public:
    explicit FeatureSelectionTool(QgsMapCanvas* canvas);

    // 重写父类的鼠标事件处理函数
    void canvasMoveEvent(QgsMapMouseEvent* e) override; // 主要逻辑在这里
    void canvasReleaseEvent(QgsMapMouseEvent* e) override;

    // 当工具被激活或停用时调用
    void activate() override;
    void deactivate() override;

private:
    void clearCurrentSelection();

    // 记录当前高亮的要素，避免重复操作
    QgsVectorLayer* m_lastSelectedLayer = nullptr;
    QgsFeatureId m_lastSelectedFeatureId;
};

正在处理文件: FileLogger.h
(FileLogger.h)
#pragma once
#include <QObject>
#include <QFile>
#include <QTextStream>

class FileLogger : public QObject
{
    Q_OBJECT

public:
    // 构造函数接收日志文件的完整路径
    explicit FileLogger(const QString& logFilePath, QObject* parent = nullptr);
    ~FileLogger();

public slots:
    // 这个槽将连接到 OutputManager::messageLogged 信号
    void onMessageLogged(const QString& message, const QString& type);

private:
    QFile m_logFile;
    QTextStream m_logStream;
};
正在处理文件: MapCanvas.h
(MapCanvas.h)
#include <QWidget>

class QgsMapCanvas;
class QgsMapLayer;
class QgsMapToolPan;
class FeatureSelectionTool; // <-- 新增
class QToolBar;             // <-- 新增
class QActionGroup;         // <-- 新增

class MapCanvas : public QWidget
{
    Q_OBJECT // << 必须添加，因为我们使用了信号和槽

public:
    MapCanvas(QWidget* parent = nullptr);
    ~MapCanvas();

    QgsMapCanvas* getCanvas() const;
    QgsMapToolPan* getPanTool() const; // 获取平移工具
    void zoomToLayer(QgsMapLayer* layer);

public slots:
    // --- 新增的公共槽函数 ---
    void zoomIn();  // 放大
    void zoomOut(); // 缩小

signals:
    // 当比例尺变化时，发出此信号，携带格式化好的字符串
    void scaleChanged(const QString& scaleText);

private slots:
    // --- 新增的私有槽函数 ---
    // 用于接收来自 QgsMapCanvas 内部的 scaleChanged 信号
    void onCanvasScaleChanged(double newScale);

private:
    QgsMapCanvas* m_qgsCanvas;
    QgsMapToolPan* m_panTool;
};

正在处理文件: OutputWidget.h
(OutputWidget.h)
#pragma once
#include <QWidget>

// 前向声明
class QTextEdit;

class OutputWidget : public QWidget
{
	Q_OBJECT

public:
	OutputWidget(QWidget* parent = nullptr);
	~OutputWidget();

	void displayMessage(const QString& message,const QString& type);

private:
	QTextEdit* m_outputConsole;
};
正在处理文件: Output_Manager.h
(Output_Manager.h)
#pragma once
#include <QObject>

class OutputManager : public QObject 
{
	Q_OBJECT

private:
	// 私有构造函数，防止外部创建实例
	explicit OutputManager(QObject* parent = nullptr);

	// 静态私有成员，拥有唯一实例
	static OutputManager* m_instance;

public:
	// 公共静态方法，用于记录并发送内容
	static OutputManager* instance();

public slots:
	// 公共槽函数，用于记录发送内容
	void logMessage(const QString& message);
	void logWarning(const QString& message);
	void logError(const QString& message);

signals:
	// 信号，当有新消息时发送
	void messageLogged(const QString& message, const QString& type = "INFO"); // 信号类型，可以是INFO，WARNING，ERROR

};
正在处理文件: QGIS_dev.h
(QGIS_dev.h)
#include <QMainWindow>
#include <QMenu>
#include <QAction>
#include <QDockWidget>
#include <QToolBar>


class MapCanvas;
class CustomLayerTreeView;
class OutputWidget;
class QgsMapTool;
class FeatureSelectionTool; // 我们自定义的选择工具
class QActionGroup;       // 用于确保工具按钮的互斥性
class QLabel;
class QgsPointXY;
class QgsMapLayer;
class QgsCoordinateReferenceSystem;
class QPushButton;

class QGIS_dev : public QMainWindow
{
    Q_OBJECT

public:
    QGIS_dev(QWidget *parent = nullptr);
    ~QGIS_dev();

protected:
    // 添加关闭事件处理，用于检查未保存的更改
    void closeEvent(QCloseEvent* event) override;

private slots:
    // 文件操作
    void onNewProject();
    void onOpenProject();
    bool onSaveProject();
    bool onSaveProjectAs();

    // 查看操作
    void onOpenLogFolder();

    // 内部槽函数，用于标记项目为已修改
    void onProjectDirty();

    // -- 将要实现的槽函数 --
    void onAddVectorLayer();
    void onAddRasterLayer();

    // --- 地图工具激活槽函数 ---
    void onActivatePanTool();
    void onActivateSelectTool();

    // +++ 新增的槽函数，用于更新状态栏 +++
    void updateCoordinates(const QgsPointXY& point);
    void updateScale(double scale);

    // 选择图层发生变化时接收信号
    void onCurrentLayerChanged(QgsMapLayer* layer);

    // +++ 新增槽函数 +++
    void updateProjectCrs(); // 用于更新状态栏的CRS显示


    // +++ 新增槽函数 +++
    void onAddDelimitedTextLayer();

private:
    // 初始化函数
    void setupUI();
    void setupActions();
    void setupToolBar();

    // 构件工程的辅助函数
    void updateWindowTitle();
    void rebuildLayerTreeFromProject(); // 从QgsProject重建图层树
    bool maybeSave(); // 检查是否需要保存，并执行保存逻辑
    bool copyLayerDataToProject(const QString& sourceFilePath, QString& newRelativePath); // 复制数据文件
    bool copyShapefile(const QString& sourceShpPath, const QString& destDir, QString& newFileName); // 专门处理Shapefile

    // UI 组件
    MapCanvas* m_mapCanvas;
    CustomLayerTreeView* m_customLayerTreeView;
    OutputWidget* m_outputWidget;

    // ... Dock 窗口 ...
    QDockWidget* m_layerTreeDock;
    QDockWidget* m_outputDock; // 我们保留输出Dock

    // +++ 新增空间分析工具的Dock和占位符Widget +++
    QDockWidget* m_analysisDock;
    QWidget* m_analysisToolsWidget;


    // 菜单和菜单动作
    QMenu* m_fileMenu;
    QAction* m_addVectorAction;
    QAction* m_addRasterAction;

    QAction* m_addDelimitedTextLayerAction;
    QAction* m_newAction;
    QAction* m_openAction;
    QAction* m_saveAction;
    QAction* m_saveAsAction;

    QMenu* m_checkMenu;
    QAction* m_checkLogsAction;

    QAction* m_viewLayerManagerAction;
    QAction* m_viewToolBarAction;
    QAction* m_viewOutputDockAction;
    QAction* m_viewAnalysisDockAction;

    // --- 工具栏和工具动作 ---
    QToolBar* m_toolBar;

    QAction* m_saveProjectAction;
    QAction* m_openProjectAction;
    QAction* addVectorTool;
    QAction* addRasterTool;

    QAction* m_zoomInAction;
    QAction* m_zoomOutAction;
    QAction* m_panAction;           // 平移动作
    QAction* m_selectAction;        // 选择要素动作
    QActionGroup* m_toolActionGroup; // 工具动作组

    // --- 地图工具实例 ---
    FeatureSelectionTool* m_selectionTool;

    // --- 项目状态 ---
    QString m_projectFilePath;
    bool m_isProjectDirty;

    // +++ 新增的成员变量，用于状态栏显示 +++
    QLabel* m_coordsLabel;
    QLabel* m_scaleLabel;

    QLabel* m_crsLabel; // 不再是 QPushButton
    QgsMapLayer* m_currentLayer;
};

正在处理文件: RasterClipDialog.h
(RasterClipDialog.h)
// RasterClipDialog.h
#ifndef RASTERCLIPDIALOG_H
#define RASTERCLIPDIALOG_H

#include <QDialog>

// 前向声明
class QComboBox;
class QPushButton;
class QLineEdit;
class QLabel;
class QgsRasterLayer;
class QgsVectorLayer;

class RasterClipDialog : public QDialog
{
    Q_OBJECT

public:
    explicit RasterClipDialog(QWidget* parent = nullptr);
    ~RasterClipDialog();

private slots:
    void onSelectInputRasterClicked();
    void onSelectClipFeatureClicked(); // 选择裁剪矢量图层
    void onSelectOutputRasterClicked();
    void onOkClicked();

private:
    void setupUI();
    void populateInputRasterComboBox();
    void populateClipFeatureComboBox(); // 填充项目中已有的矢量面图层

    // UI 控件
    QComboBox* m_inputRasterCombo;
    QPushButton* m_btnSelectInputRasterFile;
    QLabel* m_lblSelectedRasterInfo;

    QComboBox* m_clipFeatureCombo;       // 选择项目中已有的矢量面图层
    QPushButton* m_btnSelectClipFeatureFile; // 从文件选择矢量
    QLabel* m_lblSelectedClipFeatureInfo;

    QLineEdit* m_editOutputRasterPath;
    QPushButton* m_btnSelectOutputRaster;

    // +++ 新增控件 +++
    QLabel* m_lblOutputNoDataHandling;
    QComboBox* m_comboNoDataHandling;

    QPushButton* m_btnOk;
    QPushButton* m_btnCancel;

    // 数据
    QString m_currentInputRasterPath;
    QString m_currentClipFeaturePath; // 存储当前选择的裁剪矢量路径
};

#endif // RASTERCLIPDIALOG_H
正在处理文件: RasterLayerPropertiesDialog.h
(RasterLayerPropertiesDialog.h)
#include <QDialog>

// 前向声明
class QgsRasterLayer;
class QLabel;
class QTableWidget; // 我们仍然用表格来美观地显示信息
class QTextEdit;    // 用于显示多波段统计

class RasterLayerPropertiesDialog : public QDialog
{
    Q_OBJECT

public:
    explicit RasterLayerPropertiesDialog(QgsRasterLayer* layer, QWidget* parent = nullptr);
    ~RasterLayerPropertiesDialog();

private:
    void setupUI();
    void populateGeneralInfo();
    void populateAllBandStatistics(); // 新函数：填充所有波段的统计

    QgsRasterLayer* m_rasterLayer;

    // UI - 基本信息区
    QTableWidget* m_infoTableWidget;

    // UI - 多波段统计区
    QLabel* m_lblBandStatsTitle;
    QTextEdit* m_allBandStatsTextEdit; // 用一个简单的文本框显示所有波段统计
};

正在处理文件: ReprojectRasterDialog.h
(ReprojectRasterDialog.h)
// ReprojectRasterDialog.h
#ifndef REPROJECTRASTERDIALOG_H
#define REPROJECTRASTERDIALOG_H

#include <QDialog>
#include <qgscoordinatereferencesystem.h> // 包含QgsCoordinateReferenceSystem

// 前向声明
class QComboBox;
class QPushButton;
class QLineEdit;
class QLabel;
class QgsRasterLayer;

class ReprojectRasterDialog : public QDialog
{
    Q_OBJECT

public:
    explicit ReprojectRasterDialog(QWidget* parent = nullptr);
    ~ReprojectRasterDialog();

private slots:
    void onSelectInputRasterClicked();
    void onSelectOutputRasterClicked();
    void onInputRasterChanged(int index);
    void onTargetCrsComboChanged(int index); // 当目标CRS下拉框改变时
    void onOkClicked();

private:
    void setupUI();
    void populateInputRasterComboBox();
    void populateTargetCrsComboBox(); // 新函数：填充目标CRS下拉框
    void updateDefaultOutputPath();

    // UI 控件
    QComboBox* m_inputRasterCombo;
    QPushButton* m_btnSelectInputRasterFile;
    QLabel* m_lblSelectedRasterInfo;
    QLabel* m_lblCurrentCrsInfo;

    // === 修改：使用QComboBox替代QgsProjectionSelectionWidget ===
    QLabel* m_lblTargetCrs;
    QComboBox* m_targetCrsCombo;
    // =======================================================

    QLineEdit* m_editOutputRasterPath;
    QPushButton* m_btnSelectOutputRaster;

    QPushButton* m_btnOk;
    QPushButton* m_btnCancel;

    // 数据
    QString m_currentInputRasterPath;
    QgsCoordinateReferenceSystem m_currentTargetCrs; // 存储当前选中的目标CRS
};

#endif // REPROJECTRASTERDIALOG_H
正在处理文件: ResampleDialog.h
(ResampleDialog.h)
#include <QDialog>
#include <qgis.h> // For Qgis::ResamplingMethod

// 前向声明
class QComboBox;
class QPushButton;
class QLineEdit;
class QLabel;
class QgsRasterLayer;
class QDoubleSpinBox;

class ResampleDialog : public QDialog
{
    Q_OBJECT

public:
    explicit ResampleDialog(QWidget* parent = nullptr);
    ~ResampleDialog();

    // 公共接口获取参数
    QString selectedInputRasterPath() const; // 返回输入栅格的路径
    Qgis::RasterResamplingMethod selectedResamplingMethod() const;
    QString outputRasterPath() const;
    double outputPixelSizeX() const; // -1 表示使用源分辨率
    double outputPixelSizeY() const; // -1 表示使用源分辨率

private slots:
    void onSelectInputRasterClicked();
    void onSelectOutputRasterClicked();
    void onInputLayerOrMethodChanged(); // 当输入图层或方法改变时，更新默认输出名
    void onOkClicked();

private:
    void setupUI();
    void populateInputRasterComboBox();
    void updateDefaultOutputPath();

    // UI 控件
    QComboBox* m_inputRasterCombo;
    QPushButton* m_btnSelectInputRasterFile;
    QLabel* m_lblSelectedRasterInfo;

    QComboBox* m_resampleMethodCombo;

    QLabel* m_lblOutputPixelSizeX;
    QDoubleSpinBox* m_spinOutputPixelSizeX;
    QLabel* m_lblOutputPixelSizeY;
    QDoubleSpinBox* m_spinOutputPixelSizeY;
    QLabel* m_lblPixelSizeHint; // 提示用户留空则使用源分辨率


    QLineEdit* m_editOutputRasterPath;
    QPushButton* m_btnSelectOutputRaster;

    QPushButton* m_btnOk;
    QPushButton* m_btnCancel;

    // 数据
    QString m_currentInputRasterPath; // 存储当前选择的输入栅格路径
};

正在处理文件: SpatialJoinDialog.h
(SpatialJoinDialog.h)
// SpatialJoinDialog.h
#ifndef SPATIALJOINDIALOG_H
#define SPATIALJOINDIALOG_H

#include <QDialog>

// 前向声明
class QComboBox;
class QPushButton;
class QLineEdit;
class QLabel;
class QgsVectorLayer;

class SpatialJoinDialog : public QDialog
{
    Q_OBJECT

public:
    explicit SpatialJoinDialog(QWidget* parent = nullptr);
    ~SpatialJoinDialog();

private slots:
    void onSelectTargetLayerClicked(); // 选择目标图层 (面)
    void onSelectJoinLayerClicked();   // 选择连接图层 (点)
    void onSelectOutputLayerClicked();
    void onTargetLayerChanged();       // 更新目标图层信息
    void onJoinLayerChanged();         // 更新连接图层信息，并填充POI ID字段选择
    void onOkClicked();

private:
    void setupUI();
    void populateTargetLayerComboBox(); // 填充项目中已有的面图层
    void populateJoinLayerComboBox();   // 填充项目中已有点图层
    void populatePoiIdFieldComboBox();  // 根据连接图层填充可选的ID字段

    // UI 控件
    QComboBox* m_targetLayerCombo;       // 目标图层 (面)
    QPushButton* m_btnSelectTargetLayerFile;
    QLabel* m_lblSelectedTargetLayerInfo;

    QComboBox* m_joinLayerCombo;         // 连接图层 (点)
    QPushButton* m_btnSelectJoinLayerFile;
    QLabel* m_lblSelectedJoinLayerInfo;

    QLabel* m_lblPoiIdSourceField;       // 提示选择哪个字段作为PoiId的来源
    QComboBox* m_poiIdSourceFieldCombo; // 从连接图层中选择一个字段作为PoiId

    QLabel* m_lblOutputPoiIdFieldName;   // 输出图层中新字段的名称
    QLineEdit* m_editOutputPoiIdFieldName;

    QLineEdit* m_editOutputLayerPath;
    QPushButton* m_btnSelectOutputLayer;

    QPushButton* m_btnOk;
    QPushButton* m_btnCancel;

    // 数据
    QgsVectorLayer* m_currentTargetLayer;
    QgsVectorLayer* m_currentJoinLayer;
};

#endif // SPATIALJOINDIALOG_H
正在处理文件: ZonalStatisticsDialog.h
(ZonalStatisticsDialog.h)
// ZonalStatisticsDialog.h
#ifndef ZONALSTATISTICSDIALOG_H
#define ZONALSTATISTICSDIALOG_H

#include <QDialog>
#include <qgsfeature.h> // 包含QgsFeatureId
#include <QVariant>     // 包含QVariant
#include <qgscoordinatereferencesystem.h> // 包含QgsCoordinateReferenceSystem
#include "gdal_priv.h"


// 前向声明
class QComboBox;
class QPushButton;
class QLineEdit;
class QLabel;
class QSpinBox;
class QgsVectorLayer;
class QgsRasterLayer;

// 结构体用于存储每个分区的统计结果 (保持不变)
struct ZonalStatResult {
    QgsFeatureId featureId;
    QVariant originalZoneFieldValue;
    double min = 0.0;
    double max = 0.0;
    double sum = 0.0;
    double mean = 0.0;
    long count = 0;
    bool success = false;
    QString errorMessage;
};
// Q_DECLARE_METATYPE(ZonalStatResult) // 如果不在信号槽中使用，可以不注册

class ZonalStatisticsDialog : public QDialog
{
    Q_OBJECT

public:
    explicit ZonalStatisticsDialog(QWidget* parent = nullptr);
    ~ZonalStatisticsDialog();

private slots:
    void onSelectVectorLayerClicked();
    void onSelectRasterLayerClicked();
    void onSelectOutputTableClicked();
    void onVectorLayerChanged();
    void onRasterLayerChanged();
    void onOkClicked();
    // --- 移除多线程相关的槽函数 ---
    // void onCancelTaskClicked();
    // void onTaskFinished();
    // void onProgressUpdated(int value);
    // void onFeatureProcessed(const ZonalStatResult &result);

private:
    void setupUI();
    void populateVectorLayerComboBox();
    void populateRasterLayerComboBox();
    void populateZoneIdFieldComboBox();
    // void updateDefaultOutputPath(); // 这个函数可能仍然有用

    // 工作函数，现在直接在 onOkClicked 中调用
    ZonalStatResult calculateStatsForSingleFeature(const QgsGeometry& featureGeomConst, const QgsCoordinateReferenceSystem& featureCrs, GDALRasterBand* poBand, const double* adfGeoTransform, const QgsCoordinateReferenceSystem& rasterCrs, int bandNum, QgsFeatureId featureId, const QVariant& zoneValue);


    // UI 控件
    QComboBox* m_vectorLayerCombo;
    QPushButton* m_btnSelectVectorFile; // 可以保留，但实现会简单些
    QLabel* m_lblSelectedVectorInfo;

    QComboBox* m_rasterLayerCombo;
    QPushButton* m_btnSelectRasterFile; // 可以保留
    QLabel* m_lblSelectedRasterInfo;

    QLabel* m_lblRasterBand;
    QSpinBox* m_spinRasterBand;

    QLabel* m_lblZoneIdField;
    QComboBox* m_zoneIdFieldCombo;

    QLineEdit* m_editOutputTablePath;
    QPushButton* m_btnSelectOutputTable;

    QPushButton* m_btnOk;
    QPushButton* m_btnCancel;
    // --- 移除进度条和任务取消按钮 ---
    // QPushButton* m_btnCancelTask;
    // QProgressBar* m_progressBar;


    // 数据和状态
    QgsVectorLayer* m_currentVectorLayer;
    QgsRasterLayer* m_currentRasterLayer;
    QString m_currentZoneIdFieldName;
    // --- 移除 QFutureWatcher 和结果列表 ---
    // QFutureWatcher<ZonalStatResult> m_futureWatcher;
    // QList<ZonalStatResult> m_allResults;
    // bool m_taskRunning;
};

#endif // ZONALSTATISTICSDIALOG_H
