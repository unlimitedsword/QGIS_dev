正在处理文件: AnalysisToolboxWidget.cpp
(AnalysisToolboxWidget.cpp)
// AnalysisToolboxWidget.cpp
#include "AnalysisToolboxWidget.h"
#include "ResampleDialog.h"
#include "ReprojectRasterDialog.h"

#include <QVBoxLayout>
#include <QTreeView>
#include <QStandardItemModel>
#include <QDebug>

// --- 引入未来会创建的工具对话框的头文件 (占位符) ---
// #include "SpatialJoinDialog.h"
// #include "BufferDialog.h"
// ... 等等

AnalysisToolboxWidget::AnalysisToolboxWidget(QWidget* parent)
    : QWidget(parent)
{
    setupUI();
}

AnalysisToolboxWidget::~AnalysisToolboxWidget()
{
}

void AnalysisToolboxWidget::setupUI()
{
    QVBoxLayout* mainLayout = new QVBoxLayout(this);

    m_toolTreeView = new QTreeView(this);
    m_toolModel = new QStandardItemModel(this);
    m_toolModel->setHorizontalHeaderLabels({ "分析工具" }); // 设置表头
    m_toolTreeView->setModel(m_toolModel);
    m_toolTreeView->setHeaderHidden(false); // 显示表头，让它看起来更像一个工具箱
    m_toolTreeView->setEditTriggers(QAbstractItemView::NoEditTriggers); // 禁止编辑

    populateToolTree(); // 填充工具

    connect(m_toolTreeView, &QTreeView::doubleClicked, this, &AnalysisToolboxWidget::onItemDoubleClicked);

    mainLayout->addWidget(m_toolTreeView);
    setLayout(mainLayout);
}

void AnalysisToolboxWidget::populateToolTree()
{
    // --- 1. 空间分析 ---
    QStandardItem* spatialAnalysisGroup = new QStandardItem("空间分析");
    spatialAnalysisGroup->setEditable(false); // 组节点不可编辑
    // spatialAnalysisGroup->setIcon(QIcon(":/icons/group.png")); // 可选：设置图标
    m_toolModel->appendRow(spatialAnalysisGroup);

    QStandardItem* spatialJoinItem = new QStandardItem("空间连接 (点落入面)");
    spatialJoinItem->setData(static_cast<int>(AnalysisToolId::SpatialJoin), ToolIdRole);
    spatialJoinItem->setEditable(false);
    // spatialJoinItem->setIcon(QIcon(":/icons/spatial_join.png"));
    spatialAnalysisGroup->appendRow(spatialJoinItem);

    QStandardItem* bufferItem = new QStandardItem("缓冲区分析");
    bufferItem->setData(static_cast<int>(AnalysisToolId::Buffer), ToolIdRole);
    bufferItem->setEditable(false);
    spatialAnalysisGroup->appendRow(bufferItem);


    // --- 2. 栅格数据处理 ---
    QStandardItem* rasterGroup = new QStandardItem("栅格数据处理");
    rasterGroup->setEditable(false);
    m_toolModel->appendRow(rasterGroup);

    QStandardItem* rasterStatsItem = new QStandardItem("波段统计");
    rasterStatsItem->setData(static_cast<int>(AnalysisToolId::RasterStats), ToolIdRole);
    rasterStatsItem->setEditable(false);
    rasterGroup->appendRow(rasterStatsItem);

    QStandardItem* rasterClipItem = new QStandardItem("地图裁剪");
    rasterClipItem->setData(static_cast<int>(AnalysisToolId::RasterClip), ToolIdRole);
    rasterClipItem->setEditable(false);
    rasterGroup->appendRow(rasterClipItem);

    QStandardItem* rasterResampleItem = new QStandardItem("重采样");
    rasterResampleItem->setData(static_cast<int>(AnalysisToolId::RasterResample), ToolIdRole);
    rasterResampleItem->setEditable(false);
    rasterGroup->appendRow(rasterResampleItem);

    QStandardItem* rasterReprojectItem = new QStandardItem("投影转换");
    rasterReprojectItem->setData(static_cast<int>(AnalysisToolId::RasterReproject), ToolIdRole);
    rasterReprojectItem->setEditable(false);
    rasterGroup->appendRow(rasterReprojectItem);


    // --- 3. 分区统计 ---
    QStandardItem* zonalStatsGroup = new QStandardItem("分区统计");
    zonalStatsGroup->setEditable(false);
    m_toolModel->appendRow(zonalStatsGroup);

    QStandardItem* zonalStatsItem = new QStandardItem("栅格分区统计");
    zonalStatsItem->setData(static_cast<int>(AnalysisToolId::ZonalStats), ToolIdRole);
    zonalStatsItem->setEditable(false);
    zonalStatsGroup->appendRow(zonalStatsItem);

    // 自动展开所有顶级项
    for (int i = 0; i < m_toolModel->rowCount(); ++i) {
        m_toolTreeView->expand(m_toolModel->index(i, 0));
    }
}

void AnalysisToolboxWidget::onItemDoubleClicked(const QModelIndex& index)
{
    // 检查是否是叶子节点（即具体的工具项，而不是分组项）
    QStandardItem* item = m_toolModel->itemFromIndex(index);
    if (!item || item->hasChildren()) { // 如果是分组项，则不处理
        return;
    }

    AnalysisToolId toolId = static_cast<AnalysisToolId>(item->data(ToolIdRole).toInt());

    qDebug() << "Tool double clicked:" << item->text() << "with ID:" << static_cast<int>(toolId);

    // 根据工具ID，创建并显示对应的对话框
    // 这里是未来实现的核心，现在只是占位符
    switch (toolId)
    {
    case AnalysisToolId::SpatialJoin:
        // SpatialJoinDialog *sjDialog = new SpatialJoinDialog(this);
        // sjDialog->exec();
        qDebug() << "Should open SpatialJoinDialog";
        break;
    case AnalysisToolId::Buffer:
        // BufferDialog *bDialog = new BufferDialog(this);
        // bDialog->exec();
        qDebug() << "Should open BufferDialog";
        break;
    case AnalysisToolId::RasterResample: // 重采样定义的ID
    {
        ResampleDialog* resampleDialog = new ResampleDialog(this);
        resampleDialog->setAttribute(Qt::WA_DeleteOnClose);
        resampleDialog->show();
        qDebug() << "ResampleDialog opened.";
    }
    case AnalysisToolId::RasterReproject: // 假设这是您为投影转换定义的ID
    {
        ReprojectRasterDialog* reprojectDialog = new ReprojectRasterDialog(this);
        reprojectDialog->setAttribute(Qt::WA_DeleteOnClose);
        reprojectDialog->show();
        qDebug() << "ReprojectRasterDialog opened.";
    }
    break;
        break;
        // ... 其他工具的处理 ...
    default:
        qWarning() << "Unknown tool ID:" << static_cast<int>(toolId);
        break;
    }
}
正在处理文件: AttributeTableDialog.cpp
(AttributeTableDialog.cpp)
#include "attributetabledialog.h"
#include "Output_Manager.h"

#include <qgsvectorlayer.h>
#include <qgsvectorlayercache.h>
#include <qgsattributetablemodel.h>
#include <qgsattributetablefiltermodel.h>
#include <qgsmapcanvas.h>
#include <qgsexpression.h>
#include <qgsexpressioncontext.h>
#include <qgsexpressioncontextutils.h> // 包含这个头文件以获取全局上下文
#include <QVariant>
#include <QLabel>
#include <QTableView>
#include <QVBoxLayout>
#include <QHBoxLayout>
#include <QGroupBox>
#include <QComboBox>
#include <QRadioButton>
#include <QPushButton>
#include <QLineEdit>
#include <QHeaderView>
#include <QButtonGroup>
#include <QDebug>
#include <QMessageBox>
#include <QItemSelectionModel>

// ... 构造函数和析构函数保持不变 ...
AttributeTableDialog::AttributeTableDialog(QgsVectorLayer* layer, QgsMapCanvas* canvas, QWidget* parent)
    : QDialog(parent), m_layer(layer), m_canvas(canvas), m_currentSortOrder(Qt::AscendingOrder), m_deleteWarningShown(false)
{
    // ...
    setWindowTitle(QString("属性表 - %1").arg(m_layer->name()));
    resize(1100, 700); // 增大默认尺寸以容纳新控件
    setupUI();
}
AttributeTableDialog::~AttributeTableDialog() {}


void AttributeTableDialog::setupUI()
{
    // --- 主控制面板布局 ---
    QHBoxLayout* controlLayout = new QHBoxLayout();

    // --- 1. 字段选择 (始终显示，最左侧) ---
    controlLayout->addWidget(new QLabel("选择字段:", this));
    m_fieldComboBox = new QComboBox(this);
    controlLayout->addWidget(m_fieldComboBox);

    // --- 2. 操作模式选择 (始终显示，字段选择右侧) ---
    QGroupBox* modeGroupBox = new QGroupBox("操作模式", this);
    QHBoxLayout* modeLayout = new QHBoxLayout();
    m_sortRadioButton = new QRadioButton("排序", this);
    m_searchRadioButton = new QRadioButton("搜索", this);
    QButtonGroup* modeGroup = new QButtonGroup(this);
    modeGroup->addButton(m_sortRadioButton);
    modeGroup->addButton(m_searchRadioButton);
    modeLayout->addWidget(m_sortRadioButton);
    modeLayout->addWidget(m_searchRadioButton);
    modeGroupBox->setLayout(modeLayout);
    controlLayout->addWidget(modeGroupBox);

    // --- 3. 动态控件区域 (排序或搜索，会根据模式变化) ---
    // 我们创建一个 QHBoxLayout 来容纳这部分，这样可以控制它们的相对顺序
    QHBoxLayout* dynamicControlsLayout = new QHBoxLayout();

    // a. 排序控件 (默认添加到 dynamicControlsLayout)
    m_sortOrderButton = new QPushButton("升序", this);
    dynamicControlsLayout->addWidget(m_sortOrderButton);

    // b. 搜索控件 (默认添加到 dynamicControlsLayout)
    m_searchLineEdit = new QLineEdit(this);
    m_searchLineEdit->setPlaceholderText("输入搜索关键字...");
    m_searchButton = new QPushButton("搜索", this);
    dynamicControlsLayout->addWidget(m_searchLineEdit);
    dynamicControlsLayout->addWidget(m_searchButton);

    // 将这个动态控件布局添加到主控制布局
    controlLayout->addLayout(dynamicControlsLayout);

    // --- 4. 右侧固定操作按钮 (在所有动态控件之后，用伸缩项隔开) ---
    controlLayout->addStretch(); // 添加一个伸缩项，将后续按钮推到最右边

    // a. 反向选择按钮
    m_invertSelectionButton = new QPushButton("反向选择", this);
    m_invertSelectionButton->setIcon(QIcon("resource/images/反选.png"));
    m_invertSelectionButton->setToolTip("选中所有当前未选中的行，并取消选中当前已选中的行");
    controlLayout->addWidget(m_invertSelectionButton);

    // b. 删除按钮 (最右侧)
    m_deleteButton = new QPushButton("删除选中", this);
    m_deleteButton->setIcon(QIcon("resource/images/删除.png"));
    m_deleteButton->setToolTip("删除表格中所有选中的行");
    QgsVectorDataProvider* provider = m_layer->dataProvider();
    if (!provider || !(provider->capabilities())) {
        m_deleteButton->setEnabled(false);
        m_deleteButton->setToolTip("该图层的数据源不支持删除操作。");
    }
    controlLayout->addWidget(m_deleteButton);


    // --- 2. 创建并设置 Table View ---
    m_tableView = new QTableView(this); // **先创建**
    m_tableView->setSortingEnabled(false);
    m_tableView->setSelectionMode(QAbstractItemView::ExtendedSelection); // **后设置**
    m_tableView->setSelectionBehavior(QAbstractItemView::SelectRows);


    // --- 3. 创建并设置数据模型 ---
    QgsVectorLayerCache* layerCache = new QgsVectorLayerCache(m_layer, 1000, this);
    m_tableModel = new QgsAttributeTableModel(layerCache, this);
    m_filterModel = new QgsAttributeTableFilterModel(m_canvas, m_tableModel, this);
    m_tableView->setModel(m_filterModel);
    m_tableModel->loadLayer();

    // 在模型加载数据后，立即尝试同步图层中已有的选择到表格中
    synchronizeTableSelectionWithLayer();

    // --- 4. 组装主布局 ---
    QVBoxLayout* mainLayout = new QVBoxLayout(this);
    mainLayout->addLayout(controlLayout);
    mainLayout->addWidget(m_tableView);
    setLayout(mainLayout);


    // --- 5. 连接信号和槽 ---
    connect(m_fieldComboBox, QOverload<int>::of(&QComboBox::currentIndexChanged), this, &AttributeTableDialog::onFieldSelectionChanged);
    connect(m_sortOrderButton, &QPushButton::clicked, this, &AttributeTableDialog::onSortOrderToggle);
    connect(m_searchButton, &QPushButton::clicked, this, &AttributeTableDialog::onSearchButtonClicked);
    connect(m_sortRadioButton, &QRadioButton::toggled, this, &AttributeTableDialog::onFilterModeChanged);
    connect(m_deleteButton, &QPushButton::clicked, this, &AttributeTableDialog::onDeleteSelectedFeatures);
    connect(m_layer, &QgsVectorLayer::selectionChanged, this, &AttributeTableDialog::synchronizeTableSelectionWithLayer);
    connect(m_invertSelectionButton, &QPushButton::clicked, this, &AttributeTableDialog::onInvertSelection); // +++ 连接新信号槽 +++

    // --- 6. 设置初始状态 ---
    populateFieldsComboBox();
    m_sortRadioButton->setChecked(true);
    updateControlsState();
}

// +++ 实现新增的槽函数和辅助函数 +++

void AttributeTableDialog::populateFieldsComboBox()
{
    m_fieldComboBox->blockSignals(true); // 避免在填充时触发信号
    m_fieldComboBox->clear();
    m_fieldComboBox->addItem("--- (不选择字段) ---", -1); // 添加一个默认/空选项

    const QgsFields fields = m_layer->fields();
    for (int i = 0; i < fields.count(); ++i) {
        m_fieldComboBox->addItem(fields.field(i).name(), i); // 显示字段名，存储字段索引
    }
    m_fieldComboBox->blockSignals(false);
}

void AttributeTableDialog::updateControlsState()
{
    bool fieldSelected = (m_fieldComboBox->currentIndex() > 0);

    m_sortRadioButton->setEnabled(fieldSelected);
    m_searchRadioButton->setEnabled(fieldSelected);

    if (!fieldSelected) {
        m_sortRadioButton->setChecked(false);
        m_searchRadioButton->setChecked(false);
    }

    bool sortMode = m_sortRadioButton->isChecked();
    bool searchMode = m_searchRadioButton->isChecked();

    m_sortOrderButton->setVisible(sortMode && fieldSelected);
    m_searchLineEdit->setVisible(searchMode && fieldSelected);
    m_searchButton->setVisible(searchMode && fieldSelected);
}

// 当用户在下拉框中选择一个新字段时
void AttributeTableDialog::onFieldSelectionChanged(int index)
{
    // 清除排序
    m_filterModel->sort(-1, Qt::AscendingOrder);

    // 清除过滤，并强制刷新视图
    m_filterModel->setFilterMode(QgsAttributeTableFilterModel::ShowAll);
    m_filterModel->setFilterExpression(QgsExpression(), QgsExpressionContext());
    m_filterModel->invalidate(); // ++ 正确的刷新方式 ++

    if (index > 0) {
        m_sortRadioButton->setChecked(true);
    }
    updateControlsState();
}


// 当用户点击“升序/降序”按钮时
void AttributeTableDialog::onSortOrderToggle()
{
    if (m_currentSortOrder == Qt::AscendingOrder) {
        m_currentSortOrder = Qt::DescendingOrder;
        m_sortOrderButton->setText("降序");
    }
    else {
        m_currentSortOrder = Qt::AscendingOrder;
        m_sortOrderButton->setText("升序");
    }

    int fieldIndex = m_fieldComboBox->currentData().toInt();
    if (fieldIndex >= 0) {
        // 排序前，确保是对所有行进行操作
        m_filterModel->setFilterMode(QgsAttributeTableFilterModel::ShowAll);
        m_filterModel->setFilterExpression(QgsExpression(), QgsExpressionContext()); // 清除可能存在的过滤器

        // sort() 方法会自动处理视图更新
        m_filterModel->sort(fieldIndex, m_currentSortOrder);
    }
}

void AttributeTableDialog::onFilterModeChanged()
{
    // 当从“搜索”模式切换回“排序”模式时，清除过滤器
    if (m_sortRadioButton->isChecked()) {
        if (m_filterModel->filterMode() != QgsAttributeTableFilterModel::ShowAll ||
            !m_filterModel->filterExpression().isEmpty()) {

            qDebug() << "Mode switched to Sort. Clearing filter.";
            m_filterModel->setFilterMode(QgsAttributeTableFilterModel::ShowAll);
            m_filterModel->setFilterExpression(QgsExpression(), QgsExpressionContext());
            m_filterModel->invalidate();
        }
    }
    updateControlsState();
}


// 当用户点击“搜索”按钮时
void AttributeTableDialog::onSearchButtonClicked()
{
    qDebug() << "------------------------------------------";
    qDebug() << "[START] onSearchButtonClicked() called.";

    // 字段选择检查
    int fieldIndex = m_fieldComboBox->currentData().toInt();
    qDebug() << "[DEBUG] Current field index from ComboBox:" << fieldIndex;
    if (fieldIndex < 0) {
        QMessageBox::information(this, "提示", "请先从下拉框中选择一个要搜索的字段。");
        qDebug() << "------------------------------------------";
        return;
    }

    // 获取搜索文本
    QString searchText = m_searchLineEdit->text().trimmed();
    qDebug() << "[DEBUG] Search text from LineEdit:" << "\"" << searchText << "\"";

    // 处理空搜索
    if (searchText.isEmpty()) {
        qDebug() << "[ACTION] Clearing filter because search text is empty.";
        m_filterModel->setFilterMode(QgsAttributeTableFilterModel::ShowAll);
        m_filterModel->invalidate();

        // 更新视图
        if (m_tableView) {
            m_tableView->viewport()->update();
        }

        qDebug() << "------------------------------------------";
        return;
    }

    // 获取字段信息
    QString fieldName = m_layer->fields().field(fieldIndex).name();
    QMetaType::Type fieldType = static_cast<QMetaType::Type>(m_layer->fields().field(fieldIndex).type());

    qDebug() << "[DEBUG] Field name:" << fieldName;
    qDebug() << "[DEBUG] Field type (QVariant type):" << fieldType;
    qDebug() << "[DEBUG] Field type name:" << m_layer->fields().field(fieldIndex).typeName();

    // 根据字段类型构建表达式
    QString filterString;
    if (fieldType == QMetaType::Int || fieldType == QMetaType::LongLong ||
        fieldType == QMetaType::Double || fieldType == QMetaType::ULongLong) {
        bool isNumeric;
        double numericValue = searchText.toDouble(&isNumeric);

        if (isNumeric) {
            filterString = QString("\"%1\" = %2").arg(fieldName).arg(numericValue);
            qDebug() << "[INFO] Numeric field. Using exact match:" << filterString;
        }
        else {
            filterString = QString("to_string(\"%1\") ILIKE '%%2%'").arg(fieldName).arg(searchText);
            qDebug() << "[INFO] Numeric field with non-numeric search. Using string conversion:" << filterString;
        }
    }
    else {
        filterString = QString("\"%1\" ILIKE '%%2%'").arg(fieldName).arg(searchText);
        qDebug() << "[INFO] String field. Using ILIKE:" << filterString;
    }

    qDebug() << "[DEBUG] Constructed filter string:" << filterString;

    // 创建表达式
    QgsExpression expression(filterString);
    QgsExpressionContext context;
    context.appendScopes(QgsExpressionContextUtils::globalProjectLayerScopes(m_layer));

    if (!expression.prepare(&context)) {
        qDebug() << "[ERROR] Expression preparation failed:" << expression.parserErrorString();
        QMessageBox::critical(this, "表达式错误",
            QString("无法解析搜索表达式:\n%1\n\n错误信息: %2")
            .arg(expression.expression())
            .arg(expression.parserErrorString()));
        return;
    }

    // ===== 基于官方API的解决方案 =====
    QgsFeatureRequest request;
    request.setFilterExpression(expression);
    request.setExpressionContext(context);

    // 获取匹配的特征ID
    QgsFeatureIds matchingIds;
    QgsFeatureIterator it = m_layer->getFeatures(request);
    QgsFeature feature;
    while (it.nextFeature(feature)) {
        matchingIds.insert(feature.id());
    }

    qDebug() << "[DEBUG] Found" << matchingIds.size() << "matching features";

    // 使用官方API设置过滤特征
    m_filterModel->setFilterMode(QgsAttributeTableFilterModel::ShowFilteredList);
    m_filterModel->setFilteredFeatures(matchingIds);

    // 强制刷新模型 - 官方推荐的更新方式
    m_filterModel->invalidate();

    // 可选：触发特征过滤信号
    emit m_filterModel->featuresFiltered();
    // ================================

    // 更新视图
    if (m_tableView) {
        m_tableView->viewport()->update();
    }

    // 调试输出
    qDebug() << "[DEBUG] After setting filtered features:";
    qDebug() << "  - Filter mode: " << m_filterModel->filterMode();
    qDebug() << "  - Filtered features count: " << m_filterModel->filteredFeatures().size();
    qDebug() << "  - Row count in filter model: " << m_filterModel->rowCount();

    qDebug() << "[END] Filter applied and view updated.";
    qDebug() << "------------------------------------------";
}

// ====================== 新增：实现删除功能 ======================
void AttributeTableDialog::onDeleteSelectedFeatures()
{
    if (!m_layer || !m_filterModel || !m_tableView) return;

    // 1. 获取当前在表格视图中【实际被高亮选中】的行的模型索引
    QModelIndexList selectedViewIndexes = m_tableView->selectionModel()->selectedRows();

    if (selectedViewIndexes.isEmpty()) {
        QMessageBox::information(this, "提示", "没有选中任何行进行删除。");
        return;
    }

    // 2. 将这些视图索引转换为要素ID
    QgsFeatureIds idsToDelete;
    for (const QModelIndex& viewIndex : selectedViewIndexes) {
        if (viewIndex.isValid()) {
            QModelIndex sourceIndex = m_filterModel->mapToSource(viewIndex);
            idsToDelete.insert(m_tableModel->rowToId(sourceIndex.row()));
        }
    }

    if (idsToDelete.isEmpty()) {
        // 这通常不应该发生，但作为保险
        QMessageBox::information(this, "提示", "无法识别选中的要素。");
        return;
    }

    // 3. 弹出确认对话框 (只在本次打开属性表时提示一次)
    if (!m_deleteWarningShown) {
        QMessageBox::StandardButton reply;
        reply = QMessageBox::warning(this, "确认删除",
            QString("您确定要永久删除选中的 %1 个要素吗？\n\n此操作无法撤销！").arg(idsToDelete.size()),
            QMessageBox::Yes | QMessageBox::No);

        if (reply == QMessageBox::No) {
            return;
        }
        m_deleteWarningShown = true;
    }

    // 4. 执行删除操作 (这部分逻辑不变，是正确的)
    if (!m_layer->isEditable()) {
        if (!m_layer->startEditing()) {
            QMessageBox::critical(this, "错误", "无法开启图层编辑模式，删除失败。");
            return;
        }
    }
    if (m_layer->dataProvider()->deleteFeatures(idsToDelete)) {
        if (!m_layer->commitChanges()) {
            QMessageBox::critical(this, "错误", "删除成功，但提交更改失败。请检查数据源。");
            m_layer->rollBack();
        }
        else {
            OutputManager::instance()->logMessage(QString("成功删除 %1 个要素。").arg(idsToDelete.size()));
        }
    }
    else {
        QMessageBox::critical(this, "错误", "从数据源删除要素失败。");
        m_layer->rollBack();
    }

    // 5. 刷新地图和属性表
    m_layer->triggerRepaint();
    // 删除后，模型数据源已改变，让模型自己通知视图刷新
    m_tableModel->loadLayer(); // 重新加载数据，这会强制刷新所有内容
    // 或者更温和的方式，如果上面的loadLayer太慢：
    // m_filterModel->invalidate(); 
}

// +++ 新增一个辅助函数，用于同步表格选择 +++
void AttributeTableDialog::synchronizeTableSelectionWithLayer()
{
    if (!m_layer || !m_filterModel || !m_tableView) return;

    // 1. 清除表格中当前所有的选择
    m_tableView->selectionModel()->clearSelection();

    // 2. 获取图层当前选中的要素ID
    QgsFeatureIds selectedFids = m_layer->selectedFeatureIds();

    if (selectedFids.isEmpty()) {
        return; // 如果图层没有选中要素，则无需操作
    }

    // 3. 遍历选中的要素ID，在表格中找到对应的行并选中它们
    QItemSelection selection;
    for (const QgsFeatureId fid : selectedFids) {
        // QgsAttributeTableFilterModel 有一个 fidToIndexList 方法可以找到对应的 ModelIndex
        QModelIndexList viewIndexes = m_filterModel->fidToIndexList(fid);
        for (const QModelIndex& viewIndex : viewIndexes) {
            if (viewIndex.isValid()) {
                // 我们要选中整行
                QModelIndex left = m_filterModel->index(viewIndex.row(), 0);

                QModelIndex right = m_filterModel->index(viewIndex.row(), m_filterModel->columnCount(QModelIndex()) - 1);

                selection.select(left, right);
            }
        }
    }

    // 4. 应用新的选择到表格视图
    if (!selection.isEmpty()) {
        m_tableView->selectionModel()->select(selection, QItemSelectionModel::Select | QItemSelectionModel::Rows);
        // 可选：滚动到第一个选中的行
        if (!selection.indexes().isEmpty()) {
            m_tableView->scrollTo(selection.indexes().first());
        }
    }
}

void AttributeTableDialog::onInvertSelection()
{
    if (!m_layer || !m_filterModel || !m_tableView) return;

    qDebug() << "[START] onInvertSelection called.";

    // 1. 获取当前表格视图中【所有可见行】的模型索引
    QList<QModelIndex> allVisibleViewIndexes;
    for (int row = 0; row < m_filterModel->rowCount(); ++row) {
        allVisibleViewIndexes.append(m_filterModel->index(row, 0));
    }

    if (allVisibleViewIndexes.isEmpty()) {
        qDebug() << "[INFO] No rows in current view. Nothing to invert.";
        return;
    }

    // 2. 获取当前在表格视图中【实际被高亮选中】的行的模型索引
    QModelIndexList currentlySelectedViewIndexes = m_tableView->selectionModel()->selectedRows();

    // 3. 创建一个新的QItemSelection，用于存储反选后的结果
    QItemSelection newSelection;

    // 4. 遍历所有可见行
    for (const QModelIndex& viewIndex : allVisibleViewIndexes) {
        if (viewIndex.isValid()) {
            bool wasSelected = false;
            // 检查这一行之前是否被选中
            for (const QModelIndex& selectedIdx : currentlySelectedViewIndexes) {
                if (selectedIdx.row() == viewIndex.row()) {
                    wasSelected = true;
                    break;
                }
            }

            if (!wasSelected) {
                // 如果这行之前没被选中，现在就选中它
                QModelIndex left = m_filterModel->index(viewIndex.row(), 0);
                QModelIndex right = m_filterModel->index(viewIndex.row(), m_filterModel->columnCount(QModelIndex()) - 1);
                newSelection.select(left, right);
            }
            // 如果这行之前被选中了，那么在新的selection里它就是未选中状态 (因为我们从空selection开始构建)
        }
    }

    // 5. 应用新的选择到表格视图
    //    a. 先清除旧的视觉选择
    m_tableView->selectionModel()->clearSelection();
    //    b. 再应用新的视觉选择
    if (!newSelection.isEmpty()) {
        m_tableView->selectionModel()->select(newSelection, QItemSelectionModel::Select | QItemSelectionModel::Rows);
    }

    // 6. **核心：根据表格UI的最新选择状态，去更新图层的选择集**
    QgsFeatureIds fidsToSelectInLayer;
    QModelIndexList finalSelectedViewIndexes = m_tableView->selectionModel()->selectedRows();
    for (const QModelIndex& viewIndex : finalSelectedViewIndexes) {
        if (viewIndex.isValid()) {
            QModelIndex sourceIndex = m_filterModel->mapToSource(viewIndex);
            fidsToSelectInLayer.insert(m_tableModel->rowToId(sourceIndex.row()));
        }
    }

    // 更新图层选择集（先清空，再设置）
    m_layer->removeSelection();
    if (!fidsToSelectInLayer.isEmpty()) {
        m_layer->selectByIds(fidsToSelectInLayer);
    }

    qDebug() << "[END] Invert selection finished. UI selection updated. Layer selected count:" << m_layer->selectedFeatureCount();
}
正在处理文件: CustomLayerTreeView.cpp
(CustomLayerTreeView.cpp)
#include "CustomLayerTreeView.h"
#include "Output_Manager.h" // 引入日志管理器
#include "AttributeTableDialog.h"
#include "RasterLayerPropertiesDialog.h"

#include <QTreeView>
#include <QStandardItemModel>
#include <QVBoxLayout>
#include <QVariant>
#include <QMenu>
#include <QColorDialog>
#include <QItemSelection>
#include <qgsmaplayer.h>
#include <qgsvectorlayer.h>
#include <qgsrasterlayer.h>
#include <qgssinglesymbolrenderer.h>
#include <qgssymbol.h>
#include <qgsmapcanvas.h>
#include <QDebug>
#include <QMessageBox>
#include <qgsproject.h> // 需要它来移除图层

const int LayerPtrRole = Qt::UserRole + 1;
CustomLayerTreeView::CustomLayerTreeView(QgsMapCanvas* canvas, QWidget* parent)
    : QWidget(parent), m_mapCanvas(canvas)
{
    m_treeView = new QTreeView(this);
    m_model = new QStandardItemModel(this);
    m_treeView->setModel(m_model);
    m_model->setHorizontalHeaderLabels({ "Layers" });
    m_treeView->setContextMenuPolicy(Qt::CustomContextMenu);

    connect(m_model, &QStandardItemModel::itemChanged, this, &CustomLayerTreeView::onItemChanged);
    connect(m_treeView, &QTreeView::customContextMenuRequested, this, &CustomLayerTreeView::onCustomContextMenuRequested);
    // +++ 连接QTreeView的selectionChanged信号到我们的新槽函数 +++
    connect(m_treeView->selectionModel(), &QItemSelectionModel::selectionChanged,
        this, &CustomLayerTreeView::onSelectionChanged);

    QVBoxLayout* layout = new QVBoxLayout(this);
    layout->setContentsMargins(0, 0, 0, 0);
    layout->addWidget(m_treeView);
    setLayout(layout);

}
CustomLayerTreeView::~CustomLayerTreeView()
{
}
void CustomLayerTreeView::addLayer(QgsMapLayer* layer)
{
    if (!layer) return;
    QStandardItem* item = new QStandardItem(layer->name());
    item->setCheckable(true);
    item->setCheckState(Qt::Checked);
    item->setData(QVariant::fromValue(static_cast<void*>(layer)), LayerPtrRole);

    item->setEditable(true);// 设置为可编辑

    QgsVectorLayer* vlayer = qobject_cast<QgsVectorLayer*>(layer);
    if (vlayer) {
        QgsSingleSymbolRenderer* renderer = dynamic_cast<QgsSingleSymbolRenderer*>(vlayer->renderer());
        if (renderer) {
            updateLayerItemIcon(item, renderer->symbol()->color());
        }
    }

    // 将新图层插入到模型的第0行
    m_model->insertRow(0, item);
}
// 当model的属性改变时立即同步
void CustomLayerTreeView::onItemChanged(QStandardItem* item)
{
    if (!item) return;
    // 获取关联的图层
    QgsMapLayer* layer = static_cast<QgsMapLayer*>(item->data(LayerPtrRole).value<void*>());
    if (!layer) return;

    // ==================== 关键修改 2: 处理重命名 ====================
    // 检查是否是名称发生了变化
    QString newName = item->text();
    if (layer->name() != newName) {
        QString oldName = layer->name();
        layer->setName(newName); // <<< 核心：更新QGIS图层对象的名称
        OutputManager::instance()->logMessage(QString("图层 '%1' 已重命名为 '%2'").arg(oldName).arg(newName));
        emit modelChanged(); // <<< 核心：发出信号，通知主窗口项目已变“脏”
        return; // 处理完重命名后直接返回，避免下面的逻辑重复执行
    }
    // ================================================================

    // 处理可见性变化（原有的逻辑）
    qDebug() << "Item changed:" << item->text() << "Check state:" << item->checkState();
    updateMapCanvasLayers();
    emit modelChanged(); // 可见性变化也应该标记为“脏”
}


// 右键菜单
void CustomLayerTreeView::onCustomContextMenuRequested(const QPoint& pos)
{
    QModelIndex index = m_treeView->indexAt(pos);
    if (!index.isValid()) {
        return;
    }
    QStandardItem* item = m_model->itemFromIndex(index);
    if (!item) return;
    QgsMapLayer* layer = static_cast<QgsMapLayer*>(item->data(LayerPtrRole).value<void*>());
    if (!layer) return;

    QMenu contextMenu(this);
    QAction* action = nullptr; // 用于接收创建的QAction指针

    // --- 1. 重命名 (通用) ---
    action = contextMenu.addAction("重命名");
    connect(action, &QAction::triggered, this, [=]() {
        m_treeView->edit(index);
        });

    // --- 2. 修改颜色 (仅矢量) ---
    if (auto vlayer = qobject_cast<QgsVectorLayer*>(layer)) {
        action = contextMenu.addAction("修改颜色...");
        connect(action, &QAction::triggered, this, [=]() {
            this->onChangeLayerColor(layer); // 内部会再次cast，安全
            });
    }
    contextMenu.addSeparator(); // 在编辑属性和移动顺序之间加分隔符

    // --- 3. 排序功能 (通用) ---
    action = contextMenu.addAction("上移一层");
    connect(action, &QAction::triggered, this, [=]() { this->onMoveLayerUp(index); });
    action->setEnabled(index.row() > 0);

    action = contextMenu.addAction("下移一层");
    connect(action, &QAction::triggered, this, [=]() { this->onMoveLayerDown(index); });
    action->setEnabled(index.row() < m_model->rowCount() - 1);

    contextMenu.addSeparator(); // 一层移动和顶/底移动之间加分隔符

    action = contextMenu.addAction("置于顶层");
    connect(action, &QAction::triggered, this, [=]() { this->onMoveToTop(index); });
    action->setEnabled(index.row() > 0);

    action = contextMenu.addAction("置于底层");
    connect(action, &QAction::triggered, this, [=]() { this->onMoveToBottom(index); });
    action->setEnabled(index.row() < m_model->rowCount() - 1);

    contextMenu.addSeparator(); // 在排序和打开属性/删除之间加分隔符

    // --- 4. 打开特定属性对话框 (根据类型) ---
    if (auto vlayer = qobject_cast<QgsVectorLayer*>(layer)) {
        action = contextMenu.addAction("打开属性表");
        connect(action, &QAction::triggered, this, [=]() {
            AttributeTableDialog* dialog = new AttributeTableDialog(vlayer, m_mapCanvas, this->window());
            dialog->setAttribute(Qt::WA_DeleteOnClose);
            dialog->show();
            });
    }
    else if (auto rlayer = qobject_cast<QgsRasterLayer*>(layer)) {
        action = contextMenu.addAction("属性...");
        connect(action, &QAction::triggered, this, [=]() {
            RasterLayerPropertiesDialog* dialog = new RasterLayerPropertiesDialog(rlayer, this->window());
            dialog->setAttribute(Qt::WA_DeleteOnClose);
            dialog->show();
            });
    }
    // (未来可以为其他图层类型添加 else if 分支)

    // 只有在确实添加了“打开属性表”或“属性...”后才加分隔符
    if (contextMenu.actions().size() > 0 && !contextMenu.actions().last()->isSeparator()) {
        contextMenu.addSeparator();
    }


    // --- 5. 删除图层 (通用，通常放最后) ---
    action = contextMenu.addAction("删除图层");
    connect(action, &QAction::triggered, this, [=]() { this->onRemoveLayer(index); });

    contextMenu.exec(m_treeView->viewport()->mapToGlobal(pos));
}

void CustomLayerTreeView::onMoveLayerUp(const QModelIndex& index)
{
    if (!index.isValid()) return;
    int row = index.row();
    if (row > 0) {
        QList<QStandardItem*> rowItems = m_model->takeRow(row);
        m_model->insertRow(row - 1, rowItems);
        updateMapCanvasLayers();
        m_treeView->setCurrentIndex(m_model->index(row - 1, 0));
        emit modelChanged(); // <<< 发出信号
    }
}
void CustomLayerTreeView::onMoveLayerDown(const QModelIndex& index)
{
    if (!index.isValid()) return;
    int row = index.row();
    if (row < m_model->rowCount() - 1) {
        QList<QStandardItem*> rowItems = m_model->takeRow(row);
        m_model->insertRow(row + 1, rowItems);
        updateMapCanvasLayers();
        m_treeView->setCurrentIndex(m_model->index(row + 1, 0));
        emit modelChanged(); // <<< 发出信号
    }
}

void CustomLayerTreeView::onMoveToTop(const QModelIndex& index)
{
    if (!index.isValid() || index.row() == 0) return; // 如果已经是顶层，则不操作

    // 从当前位置取出该行
    QList<QStandardItem*> rowItems = m_model->takeRow(index.row());
    // 将其插入到模型的第0行 (UI的顶层)
    m_model->insertRow(0, rowItems);

    updateMapCanvasLayers(); // 根据新的UI顺序刷新画布
    m_treeView->setCurrentIndex(m_model->index(0, 0)); // 更新选中项
    emit modelChanged();
}

void CustomLayerTreeView::onMoveToBottom(const QModelIndex& index)
{
    if (!index.isValid() || index.row() == m_model->rowCount() - 1) return; // 如果已经是底层，则不操作

    // 从当前位置取出该行
    QList<QStandardItem*> rowItems = m_model->takeRow(index.row());
    // 将其追加到模型的末尾 (UI的底层)
    m_model->appendRow(rowItems);

    updateMapCanvasLayers(); // 根据新的UI顺序刷新画布
    m_treeView->setCurrentIndex(m_model->index(m_model->rowCount() - 1, 0)); // 更新选中项
    emit modelChanged();
}


void CustomLayerTreeView::onChangeLayerColor(QgsMapLayer* layer)
{
    QgsVectorLayer* vectorLayer = qobject_cast<QgsVectorLayer*>(layer);
    if (!vectorLayer) return;
    // !! 修正: 对非QObject的类使用 dynamic_cast !!
    QgsSingleSymbolRenderer* renderer = dynamic_cast<QgsSingleSymbolRenderer*>(vectorLayer->renderer());
    if (!renderer) {
        qDebug() << "Cannot change color: layer does not use a single symbol renderer.";
        return;
    }

    const QColor newColor = QColorDialog::getColor(renderer->symbol()->color(), this, "选择新颜色");

    if (newColor.isValid()) {
        renderer->symbol()->setColor(newColor);
        vectorLayer->triggerRepaint();

        for (int i = 0; i < m_model->rowCount(); ++i) {
            QStandardItem* item = m_model->item(i);
            QgsMapLayer* itemLayer = static_cast<QgsMapLayer*>(item->data(LayerPtrRole).value<void*>());
            if (itemLayer == layer) {
                updateLayerItemIcon(item, newColor);
                emit modelChanged();
                break;
            }
        }
    }
}
void CustomLayerTreeView::updateLayerItemIcon(QStandardItem* item, const QColor& color)
{
    if (!item) return;
    QPixmap pixmap(16, 16);
    pixmap.fill(color);
    item->setIcon(QIcon(pixmap));
}
// --- !! 新增的槽函数实现 !! ---
void CustomLayerTreeView::onRemoveLayer(const QModelIndex& index)
{
    if (!index.isValid()) return;
    // 1. 获取图层和Item
    QStandardItem* item = m_model->itemFromIndex(index);
    if (!item) return;

    QgsMapLayer* layer = static_cast<QgsMapLayer*>(item->data(LayerPtrRole).value<void*>());
    if (!layer) return;

    // 2. 弹出确认对话框
    QMessageBox::StandardButton reply;
    reply = QMessageBox::question(this, "确认删除", QString("确定要删除图层 '%1' 吗？此操作无法撤销。").arg(layer->name()),
        QMessageBox::Yes | QMessageBox::No);
    if (reply == QMessageBox::No) {
        return;
    }

    // 3. 从 QGIS 项目中移除图层。
    //    这一步是核心，它会触发信号，让QGIS框架负责清理图层对象。
    QgsProject::instance()->removeMapLayer(layer->id());

    // 4. 从我们的视图模型中移除对应的行。
    //    此时，layer 指针已经是一个“悬垂指针”，QGIS很快会删除它。
    //    我们绝对不能再使用它，尤其是不能 delete 它。
    m_model->removeRow(index.row());

    // 5. 更新画布
    //    在 QGIS 3.x 中，removeMapLayer 信号通常会连接到画布的更新槽，
    //    所以这一步可能不是必需的，但为了保险起见，可以保留。
    updateMapCanvasLayers();
    m_mapCanvas->refresh();

}


void CustomLayerTreeView::updateMapCanvasLayers()
{
    QList<QgsMapLayer*> layersToRender;

    // 从UI模型的顶部 (index 0, 用户看到的顶层) 开始遍历
    for (int uiRow = 0; uiRow < m_model->rowCount(); ++uiRow)
    {
        QStandardItem* item = m_model->item(uiRow);
        if (item && item->checkState() == Qt::Checked)
        {
            QVariant layerVariant = item->data(LayerPtrRole);
            if (layerVariant.isValid()) {
                QgsMapLayer* layer = static_cast<QgsMapLayer*>(layerVariant.value<void*>());
                // 将UI列表中的图层，按顺序【追加】到渲染列表的【末尾】
                layersToRender.append(layer);
            }
        }
    }

    m_mapCanvas->setLayers(layersToRender);
    qDebug() << "Map canvas updated. UI Top (" << (m_model->rowCount() > 0 ? m_model->item(0)->text() : "N/A")
        << ") is Map Top. Render order (bottom to top):";
    for (QgsMapLayer* lyr : layersToRender) {
        qDebug() << "  - " << lyr->name();
    }
}



void CustomLayerTreeView::clear()
{
    m_model->clear();
    m_model->setHorizontalHeaderLabels({ "Layers" });
    updateMapCanvasLayers(); // 清空画布
}
// +++ 实现新槽函数的逻辑 +++
void CustomLayerTreeView::onSelectionChanged(const QItemSelection& selected, const QItemSelection& deselected)
{
    Q_UNUSED(deselected); // 不关心之前选中的是什么

    QModelIndexList indexes = selected.indexes();
    if (indexes.isEmpty()) {
        // 如果没有选中任何项（例如，清空图层后），发出一个nullptr信号
        emit currentLayerChanged(nullptr);
        return;
    }

    // 通常我们只关心第一个被选中的项
    QModelIndex currentIndex = indexes.first();
    QStandardItem* item = m_model->itemFromIndex(currentIndex);
    if (item) {
        QgsMapLayer* layer = static_cast<QgsMapLayer*>(item->data(LayerPtrRole).value<void*>());
        // 发出信号，将当前选中的图层指针传递出去
        emit currentLayerChanged(layer);
    }

}
正在处理文件: FeatureSelectionTool.cpp
(FeatureSelectionTool.cpp)
#include "featureselectiontool.h"
#include <qgsmapcanvas.h>
#include <qgsvectorlayer.h>
#include <qgsfeature.h>
#include <qgsproject.h>
#include <qgsmaplayer.h>
#include <qgsapplication.h>

#include <QToolTip> // 使用 Qt 的工具提示

FeatureSelectionTool::FeatureSelectionTool(QgsMapCanvas* canvas)
    : QgsMapToolIdentify(canvas)
{
    this->setCursor(Qt::ArrowCursor);
}

// 当工具被激活时，重置状态
void FeatureSelectionTool::activate()
{
    QgsMapTool::activate();
    clearCurrentSelection();
}

// 当工具被停用时，清理所有状态
void FeatureSelectionTool::deactivate()
{
    QgsMapTool::deactivate();
    clearCurrentSelection();
    QToolTip::hideText();
}

// 新的核心逻辑：鼠标移动事件
void FeatureSelectionTool::canvasMoveEvent(QgsMapMouseEvent* e)
{
    // 识别鼠标下的要素
    QList<IdentifyResult> results = this->identify(e->x(), e->y(), IdentifyMode::TopDownAll);

    if (results.isEmpty())
    {
        // 如果鼠标下没有要素，隐藏提示
        QToolTip::hideText();
        return;
    }

    // 只处理最顶层的矢量图层结果
    IdentifyResult topResult = results.first();
    QgsMapLayer* layer = topResult.mLayer;
    QgsFeature feature = topResult.mFeature;

    QgsVectorLayer* vlayer = qobject_cast<QgsVectorLayer*>(layer);
    if (!vlayer || !feature.isValid())
    {
        QToolTip::hideText();
        return;
    }

    // 获取要素的 "name" 属性
    QString displayName;
    int nameFieldIndex = vlayer->fields().indexOf("name");
    if (nameFieldIndex != -1) {
        displayName = feature.attribute("name").toString();
    }
    else {
        displayName = QString("ID: %1").arg(feature.id());
    }

    // 显示提示信息
    if (!displayName.isEmpty()) {
        QString tipText = QString("<b>名称:</b><br>%1").arg(displayName);
        QPoint globalPos = canvas()->mapToGlobal(e->pos());
        QToolTip::showText(globalPos, tipText, canvas());
    }
}


// 我们保留点击事件，用于真正“选定”和高亮要素
void FeatureSelectionTool::canvasReleaseEvent(QgsMapMouseEvent* e)
{
    QList<IdentifyResult> results = this->identify(e->x(), e->y(), IdentifyMode::TopDownAll);

    // 先清除之前的选择
    clearCurrentSelection();

    if (results.isEmpty()) {
        canvas()->refresh();
        return;
    }

    // 只处理最顶层的矢量图层结果
    IdentifyResult topResult = results.first();
    QgsMapLayer* layer = topResult.mLayer;
    QgsFeature feature = topResult.mFeature;

    QgsVectorLayer* vlayer = qobject_cast<QgsVectorLayer*>(layer);
    if (!vlayer || !feature.isValid()) {
        canvas()->refresh();
        return;
    }

    // 在图层上选择该要素，使其高亮
    vlayer->select(feature.id());

    // 记录下这次选择，方便之后清除
    m_lastSelectedLayer = vlayer;
    m_lastSelectedFeatureId = feature.id();
}

// 辅助函数，用于清除当前的选择
void FeatureSelectionTool::clearCurrentSelection()
{
    if (m_lastSelectedLayer)
    {
        m_lastSelectedLayer->deselect(m_lastSelectedFeatureId);
        m_lastSelectedLayer = nullptr;
    }
    else
    {
        // 如果没有特定记录，则作为备用方案，清除所有图层的选择
        QList<QgsMapLayer*> layers = QgsProject::instance()->mapLayers().values();
        for (QgsMapLayer* layer : layers) {
            // 使用动态类型检查来确保图层是矢量图层
            QgsVectorLayer* vectorLayer = qobject_cast<QgsVectorLayer*>(layer);
            if (vectorLayer) {
                vectorLayer->removeSelection();
            }
        }
    }
}
正在处理文件: FileLogger.cpp
(FileLogger.cpp)
#pragma once
#include "FileLogger.h"
#include <QDateTime>
#include <QDebug>

FileLogger::FileLogger(const QString& logFilePath, QObject* parent)
    : QObject(parent)
{
    m_logFile.setFileName(logFilePath);

    // 以追加模式打开文件，这样即使程序快速重启也不会覆盖日志
    // QIODevice::Text 会自动处理不同操作系统下的换行符
    if (!m_logFile.open(QIODevice::WriteOnly | QIODevice::Append | QIODevice::Text))
    {
        qWarning() << "无法打开日志文件进行写入:" << logFilePath;
        return;
    }

    // 将文本流与文件关联
    m_logStream.setDevice(&m_logFile);
    // 确保使用UTF-8编码，以支持中文字符
    m_logStream.setCodec("UTF-8");

    // (可选) 在日志文件开头写入一条启动信息
    QString startMessage = QString("===== 日志开始于 %1 =====\n")
        .arg(QDateTime::currentDateTime().toString("yyyy-MM-dd hh:mm:ss"));
    m_logStream << startMessage;
    m_logStream.flush(); // 立即写入
}

FileLogger::~FileLogger()
{
    // 在对象销毁时，确保所有缓冲数据都已写入文件并关闭文件
    if (m_logFile.isOpen()) {
        m_logStream.flush();
        m_logFile.close();
    }
}

void FileLogger::onMessageLogged(const QString& message, const QString& type)
{
    if (!m_logFile.isOpen()) {
        return; // 如果文件未成功打开，则不执行任何操作
    }

    // 格式化日志条目，与您在OutputWidget中的格式完全一致
    QString formattedMessage = QString("[%1][%2] %3")
        .arg(QDateTime::currentDateTime().toString("yyyy-MM-dd hh:mm:ss"))
        .arg(type)
        .arg(message);

    // 将格式化后的消息写入文件流，并添加换行符
    m_logStream << formattedMessage << Qt::endl;
}
正在处理文件: main.cpp
(main.cpp)
#pragma warning(disable:4996)
#include "QGIS_dev.h"
#include "FileLogger.h"
#include "Output_Manager.h"
#include <QTextCodec>
#include <QDir>
#include <QDateTime>
#include <qgsapplication.h>
#include <qgscoordinatereferencesystem.h>
#include <qgsproviderregistry.h>
#include <qgsmaplayer.h>
#include <qdebug.h>
#include <QMessageBox>
#include <QMetaType>

// 一个简单的函数，用于在屏幕上显示诊断信息
void showDiagnosis(const QString& title, const QString& message) {
    qDebug() << "---" << title << "---";
    qDebug() << message;
    QMessageBox::information(nullptr, title, message);
}

int main(int argc, char* argv[])
{
    // === STAGE 1: 创建QApplication实例 ===
    // 这是所有UI操作的前提，必须是第一步。
    QgsApplication a(argc, argv, true);
    qDebug() << "STAGE 1 PASSED: QgsApplication instance created.";

    // 注册 QgsMapLayer* 类型，让Qt的元对象系统在处理 QVariant 时能更好地识别它
    qRegisterMetaType<QgsMapLayer*>("QgsMapLayer*");

    // === STAGE 2: 强制设置环境变量 ===
    // 此时 QApplication 已存在，但 QGIS 核心还未初始化。
    // 这是设置环境变量的最佳时机。
    QString prefixPath = QgsApplication::applicationDirPath();

    // 使用 Qt 的 qputenv，它更安全
    // 它在内部处理了字符串的生命周期问题
    qputenv("PROJ_LIB", QDir::toNativeSeparators(prefixPath + "/share/proj").toLocal8Bit());
    qputenv("GDAL_DATA", QDir::toNativeSeparators(prefixPath + "/share/gdal").toLocal8Bit());
    qputenv("QT_PLUGIN_PATH", QDir::toNativeSeparators(prefixPath + "/plugins").toLocal8Bit());

    // 添加核心DLL目录到PATH，以防万一
    QByteArray pathEnv = qgetenv("PATH");
    QString newPath = QDir::toNativeSeparators(prefixPath) + ";" + pathEnv;
    qputenv("PATH", newPath.toLocal8Bit());

    // === STAGE 3: 初始化QGIS核心 ===
    // 此时环境变量已设置完毕，initQgis() 会在正确的环境下运行
    QgsApplication::setPrefixPath(prefixPath, true); // 仍然建议设置，因为它影响QGIS内部的其他路径逻辑
    QgsApplication::initQgis();
    qDebug() << "STAGE 3: QGIS Init 完成";

    // === STAGE 4: 关键功能测试 - CRS创建 ===
    QgsCoordinateReferenceSystem testCrs("EPSG:4326");
    if (testCrs.isValid()) {
        qDebug() << "STAGE 4: CRS Test - SUCCESS! 'EPSG:4326' created. Problem solved!";
    }
    else {
        qDebug() << "STAGE 4: CRS Test - FAILURE! Still cannot create CRS. This indicates a fundamental DLL or data file version mismatch.";
        return -1;
    }

    // === STAGE 5: 启动主程序 ===
    qDebug() << "All checks passed. Starting main application...";

    int result = 0;
    {
        QGIS_dev w;
        w.setMinimumSize(1920, 1080);
        w.show();

        // 日志系统现在可以安全初始化并使用了
        QDir logDir(QApplication::applicationDirPath());
        logDir.cdUp(); 
        logDir.cdUp();
        logDir.mkdir("logs");
        if (logDir.exists("logs")) {
            logDir.cd("logs");
        }
        QString timestamp = QDateTime::currentDateTime().toString("yyyy-MM-dd-HH-mm");
        QString logFilePath = logDir.filePath(timestamp + ".log");
        FileLogger* fileLogger = new FileLogger(logFilePath, &a);
        QObject::connect(OutputManager::instance(), &OutputManager::messageLogged, fileLogger, &FileLogger::onMessageLogged);
        OutputManager::instance()->logMessage("应用程序启动成功。");

        result = a.exec();
    }

    QgsApplication::exitQgis();
    return result;
}

正在处理文件: MapCanvas.cpp
(MapCanvas.cpp)
#include "MapCanvas.h"
#include <qgsmapcanvas.h>
#include <qgsmaptoolpan.h>
#include <qgsproject.h>
#include <qgsmaplayer.h>
#include <QVBoxLayout>
#include <QDebug>

MapCanvas::MapCanvas(QWidget* parent)
    : QWidget(parent)
{
    m_qgsCanvas = new QgsMapCanvas();
    m_qgsCanvas->setCanvasColor(Qt::white);
    m_qgsCanvas->enableAntiAliasing(true);

    QVBoxLayout* layout = new QVBoxLayout(this);
    layout->setContentsMargins(0, 0, 0, 0);
    layout->addWidget(m_qgsCanvas);
    setLayout(layout);

    // 平移工具
    m_panTool = new QgsMapToolPan(m_qgsCanvas);
    m_qgsCanvas->setMapTool(m_panTool);
    m_panTool->setCursor(Qt::OpenHandCursor);

    // ====================== 核心修正 ======================
    // 删除所有主动设置 QgsProject::instance()->setCrs() 的代码。
    // MapCanvas 的职责：只做一件事 —— 忠实地跟随 QgsProject 的CRS。

    // 1. 启动时，将自己的目标CRS设置为当前项目的CRS (此时可能无效)
    m_qgsCanvas->setDestinationCrs(QgsProject::instance()->crs());

    // 2. 建立一个永久的连接：只要项目CRS变了，画布就跟着变。
    connect(QgsProject::instance(), &QgsProject::crsChanged,
        m_qgsCanvas, [this]() {
            m_qgsCanvas->setDestinationCrs(QgsProject::instance()->crs());
        });

    // ========================================================

    // 连接比例尺信号 (这部分不变)
    connect(m_qgsCanvas, &QgsMapCanvas::scaleChanged, this, &MapCanvas::onCanvasScaleChanged);
    onCanvasScaleChanged(m_qgsCanvas->scale());
}

MapCanvas::~MapCanvas()
{
}

QgsMapCanvas* MapCanvas::getCanvas() const
{
    return m_qgsCanvas;
}

// 获取平移工具的实现
QgsMapToolPan* MapCanvas::getPanTool() const
{
    return m_panTool;
}

void MapCanvas::zoomToLayer(QgsMapLayer* layer)
{
    if (layer && layer->isValid()) {
        m_qgsCanvas->setExtent(layer->extent());
        m_qgsCanvas->refresh();
        // 注意：setExtent会自动改变比例尺，从而触发scaleChanged信号，所以这里无需额外操作
    }
}

// --- 新增接口的实现 ---

void MapCanvas::zoomIn()
{
    if (m_qgsCanvas) {
        m_qgsCanvas->zoomIn(); // 将调用传递给QGIS画布
    }
}

void MapCanvas::zoomOut()
{
    if (m_qgsCanvas) {
        m_qgsCanvas->zoomOut(); // 将调用传递给QGIS画布
    }
}

// --- 新增私有槽的实现 ---

void MapCanvas::onCanvasScaleChanged(double newScale)
{
    // 将double类型的比例尺分母格式化为 "1:XXXXX" 的字符串
    QString formattedScale = QString("比例尺 1:%1").arg(static_cast<int>(newScale));

    // 发射我们自己的、携带格式化字符串的信号
    emit scaleChanged(formattedScale);
    qDebug() << "Scale changed to:" << formattedScale;
}
正在处理文件: OutputWidget.cpp
(OutputWidget.cpp)
#include "Output_Manager.h"
#include <OutputWidget.h>
#include <QTextEdit>
#include <QVBoxLayout>
#include <QDateTime>
#include <QString>

OutputWidget::OutputWidget(QWidget* parent)
	: QWidget(parent)
{
    // 输出控制台
    m_outputConsole = new QTextEdit();
    m_outputConsole->setReadOnly(true);
    m_outputConsole->setWordWrapMode(QTextOption::WordWrap);

    // 添加布局
    QVBoxLayout* layout = new QVBoxLayout(this);
    layout->addWidget(m_outputConsole);
    setLayout(layout);

    QString testMessage = "This is a test message!";
    m_outputConsole->append(testMessage);
    connect(OutputManager::instance(), &OutputManager::messageLogged, this, &OutputWidget::displayMessage);
}

void OutputWidget::displayMessage(const QString& message,const QString& type) {
    QString formattedMessage = QString("[%1] [%2] %3").arg(QDateTime::currentDateTime().toString("yyyy-MM-ddhh:mm:ss")).arg(type).arg(message);
    m_outputConsole->append(formattedMessage);
}

OutputWidget::~OutputWidget() {

}
正在处理文件: Output_Manager.cpp
(Output_Manager.cpp)
#include "Output_Manager.h"
#include <QDebug>

OutputManager* OutputManager::m_instance = nullptr;


OutputManager::OutputManager(QObject* parent)
	:	QObject(parent) 
{
	qDebug() << "OutputManager instance created.";
}

OutputManager* OutputManager::instance()
{
	if (!m_instance) {
		m_instance = new OutputManager();
	}
	return m_instance;
}

void OutputManager::logMessage(const QString& message) {
	emit messageLogged(message, "INFO");
}

void OutputManager::logWarning(const QString& message) {
	emit messageLogged(message, "WARNING");
}

void OutputManager::logError(const QString& message) {
	emit messageLogged(message, "ERROR");
}


正在处理文件: QGIS_dev.cpp
(QGIS_dev.cpp)
#include "QGIS_dev.h"
#include "Output_Manager.h"
#include "MapCanvas.h"
#include "OutputWidget.h"
#include "CustomLayerTreeView.h"
#include "FeatureSelectionTool.h"
#include "AnalysisToolboxWidget.h"

#include <QDockWidget>
#include <QMenu>
#include <QMenuBar>
#include <QAction>
#include <QToolBar>
#include <QFileInfo>
#include <QDebug>
#include <QFileDialog> // 用于文件对话框
#include <QDir>        // 用于获取默认路径
#include <QMessageBox>
#include <QLabel>
#include <QStatusBar>
#include <QPushButton> // 添加此行以包含 QPushButton 的完整定义
#include <QProcess>
#include <QUrl>
#include <QUrlQuery>
#include <qgsvectorlayer.h>
#include <qgsrasterlayer.h> // 需要包含栅格图层头文件
#include <qgslayertree.h>
#include <qgsproject.h>
#include <qgsmaptoolpan.h>
#include <qgsMapLayer.h>
#include <qgsapplication.h> // 添加此行以包含 QgsApplication 的完整定义
#include <qgsprojectionselectiondialog.h>

const int LayerPtrRole = Qt::UserRole + 1;


QGIS_dev::QGIS_dev(QWidget *parent)
    : QMainWindow(parent), m_isProjectDirty(false),m_currentLayer(nullptr) // 初始化项目状态
{
    // 调用辅助函数来创建和设置UI
    setupUI();
    setupActions();
    setupToolBar();

    // 默认激活平移工具
    m_panAction->setChecked(true);
    onActivatePanTool(); // 确保程序启动时，平移工具是激活状态

    // 连接 CustomLayerTreeView 的修改信号，以更新“脏”状态
    // (这需要在 CustomLayerTreeView 中添加一个信号)
    connect(m_customLayerTreeView, &CustomLayerTreeView::modelChanged, this, &QGIS_dev::onProjectDirty);

    // 在 QGIS_dev 构造函数中

    connect(QgsProject::instance(), &QgsProject::layersAdded, this, &QGIS_dev::onProjectDirty);
    connect(QgsProject::instance(), &QgsProject::layersAdded, this, [this](const QList<QgsMapLayer*>& layers) {
        for (QgsMapLayer* layer : layers) {
            // 在rebuildLayerTreeFromProject中已经有这个逻辑了，
            // layersAdded 信号应该只用来触发UI更新，而不是直接添加
            m_customLayerTreeView->addLayer(layer);
        }
        // 关键修改：添加图层后，手动更新一次画布，确保显示
        m_customLayerTreeView->updateMapCanvasLayers();
        });
    connect(QgsProject::instance(), QOverload<const QStringList&>::of(&QgsProject::layersWillBeRemoved), this, [this]() {
        this->onProjectDirty();
        });

    // 关键：连接地图画布的信号到新槽函数
    QgsMapCanvas* canvas = m_mapCanvas->getCanvas();
    connect(m_mapCanvas->getCanvas(), &QgsMapCanvas::scaleChanged, this, &QGIS_dev::updateScale);
    connect(canvas, &QgsMapCanvas::xyCoordinates, this, &QGIS_dev::updateCoordinates);
    connect(canvas, &QgsMapCanvas::scaleChanged, this, &QGIS_dev::updateScale);

    // +++ 将图层树的选中事件连接到主窗口的槽 +++
    connect(m_customLayerTreeView, &CustomLayerTreeView::currentLayerChanged,
        this, &QGIS_dev::onCurrentLayerChanged);

    // ====================== 核心修改 ======================
    // 1. 连接 QgsProject 的 crsChanged 信号到我们的新槽函数
    connect(QgsProject::instance(), &QgsProject::crsChanged, this, &QGIS_dev::updateProjectCrs);

    // 2. 在程序启动时，手动调用一次，以显示初始的CRS状态
    updateProjectCrs();
    // ========================================================

    updateWindowTitle();

    updateScale(m_mapCanvas->getCanvas()->scale());
}

QGIS_dev::~QGIS_dev()
{
}

// ---在此设置所有窗口UI---
void QGIS_dev::setupUI()
{
    // 创建核心组件
    m_mapCanvas = new MapCanvas(this); // MapCanvas保持不变

    // 将地图画布的指针传递给它
    m_customLayerTreeView = new CustomLayerTreeView(m_mapCanvas->getCanvas(), this);

    m_outputWidget = new OutputWidget(this);

    setCentralWidget(m_mapCanvas);

    // 将customLayerTreeView 放入DockWidget
    m_layerTreeDock = new QDockWidget("图层 (自定义)", this);
    m_layerTreeDock->setWidget(m_customLayerTreeView);
    addDockWidget(Qt::LeftDockWidgetArea, m_layerTreeDock);

    // ====================== 创建两个右侧Dock ======================
    // a. 创建“空间分析”Dock，并放入自定义Widget
    m_analysisToolsWidget = new AnalysisToolboxWidget(this);

    m_analysisDock = new QDockWidget("空间分析工具", this);
    m_analysisDock->setWidget(m_analysisToolsWidget);

    // b. 创建“输出”Dock
    m_outputDock = new QDockWidget("输出", this);
    m_outputDock->setWidget(m_outputWidget);

    // c. 先添加上面的（分析），再添加下面的（输出）
    addDockWidget(Qt::RightDockWidgetArea, m_analysisDock);
    addDockWidget(Qt::RightDockWidgetArea, m_outputDock);

    // d. 将它们垂直排列
    //    如果它们默认是tab页，就用 splitDockWidget 强制拆分
    //    通常后一个add会放在前一个的下面，但如果不是，就用split
    splitDockWidget(m_analysisDock, m_outputDock, Qt::Vertical);

    // 在 setupUI 函数的最后
    m_analysisDock->setMinimumWidth(350);
    m_outputDock->setMinimumWidth(350);

    // =======================================================================
    
    // 创建菜单栏
    m_fileMenu = menuBar()->addMenu("文件(&F)"); // &F 设置快捷键 Alt+F
    m_checkMenu = menuBar()->addMenu("查看(&C)");

    // 创建工具栏
    m_toolBar = new QToolBar(this);
    addToolBar(Qt::TopToolBarArea, m_toolBar);
    m_toolBar->setFloatable(false);       // 设置是否浮动
    m_toolBar->setMovable(false);         // 设置工具栏不允许移动

    // 新增：设置状态栏 
    QStatusBar* sb = statusBar(); // 获取主窗口的状态栏

    // 创建坐标标签
    m_coordsLabel = new QLabel("坐标: (移动鼠标查看)", this);
    m_coordsLabel->setMinimumWidth(250); // 设置一个最小宽度，防止跳动
    m_coordsLabel->setFrameShape(QFrame::StyledPanel); // 可选：添加边框使其更像QGIS
    m_coordsLabel->setFrameShadow(QFrame::Sunken);

    // 创建比例尺标签
    m_scaleLabel = new QLabel("比例尺: N/A", this);
    m_scaleLabel->setMinimumWidth(150);
    m_scaleLabel->setFrameShape(QFrame::StyledPanel);
    m_scaleLabel->setFrameShadow(QFrame::Sunken);

    // 将标签作为永久部件添加到状态栏（这样它们就不会被临时消息覆盖）
    sb->addPermanentWidget(m_coordsLabel);
    sb->addPermanentWidget(m_scaleLabel);

    // ====================== 核心修改：创建 QPushButton ======================
    m_crsButton = new QPushButton("未知坐标系", this);
    m_crsButton->setToolTip("点击以更改项目的坐标参考系(CRS)");
    m_crsButton->setFlat(true); // 让它看起来像个标签，但可以点击
    m_crsButton->setCursor(Qt::PointingHandCursor); // 鼠标悬停时显示手形
    connect(m_crsButton, &QPushButton::clicked, this, &QGIS_dev::onChangeProjectCrs);

    sb->addPermanentWidget(m_crsButton);
}

// ---在此设置所有的菜单栏---
void QGIS_dev::setupActions()
{
    // 创建“添加矢量图层”动作
    m_addVectorAction = new QAction("添加矢量图层", this);
    m_addVectorAction->setStatusTip("从文件加载一个矢量图层 (如: .shp)");
    connect(m_addVectorAction, &QAction::triggered, this, &QGIS_dev::onAddVectorLayer);

    // 创建“添加栅格图层”动作
    m_addRasterAction = new QAction("添加栅格图层", this);
    m_addRasterAction->setStatusTip("从文件加载一个栅格图层 (如: .tif)");
    connect(m_addRasterAction, &QAction::triggered, this, &QGIS_dev::onAddRasterLayer);

    // ====================== 新增动作 ======================
   // 创建“添加分隔符文本图层”动作
    m_addDelimitedTextLayerAction = new QAction("添加分隔符文本图层...", this);
    m_addDelimitedTextLayerAction->setStatusTip("从CSV或其他文本文件加载点图层");
    connect(m_addDelimitedTextLayerAction, &QAction::triggered, this, &QGIS_dev::onAddDelimitedTextLayer);
    // ======================================================

    // 新建项目动作
    m_newAction = new QAction("新建项目", this);
    m_newAction->setShortcut(QKeySequence::New);
    connect(m_newAction, &QAction::triggered, this, &QGIS_dev::onNewProject);

    // 打开项目动作
    m_openAction = new QAction("打开项目...", this);
    m_openAction->setShortcut(QKeySequence::Open);
    connect(m_openAction, &QAction::triggered, this, &QGIS_dev::onOpenProject);

    // 保存项目动作
    m_saveAction = new QAction("保存项目", this);
    m_saveAction->setShortcut(QKeySequence::Save);
    connect(m_saveAction, &QAction::triggered, this, &QGIS_dev::onSaveProject);

    // 另存为动作
    m_saveAsAction = new QAction("项目另存为...", this);
    m_saveAsAction->setShortcut(QKeySequence::SaveAs);
    connect(m_saveAsAction, &QAction::triggered, this, &QGIS_dev::onSaveProjectAs);

    // 将新动作添加到菜单栏
    m_fileMenu->addAction(m_newAction);
    m_fileMenu->addAction(m_openAction);
    m_fileMenu->addAction(m_saveAction);
    m_fileMenu->addAction(m_saveAsAction);
    m_fileMenu->addSeparator();
    m_fileMenu->addAction(m_addVectorAction);
    m_fileMenu->addAction(m_addRasterAction);
    m_fileMenu->addAction(m_addDelimitedTextLayerAction);

    m_checkLogsAction = new QAction("日志", this);
    connect(m_checkLogsAction, &QAction::triggered, this, &QGIS_dev::onOpenLogFolder);
    m_checkMenu->addAction(m_checkLogsAction); // 假设你想加到“查看”菜单

}

// ---- 新的项目管理槽函数 ----

// **修改 onNewProject 函数**
// QgsProject::clear() 也会发出 crsChanged 信号，所以也无需手动调用
void QGIS_dev::onNewProject()
{
    if (maybeSave()) {
        QgsProject::instance()->clear();

        QgsCoordinateReferenceSystem defaultCrs("EPSG:4326");
        if (defaultCrs.isValid()) {
            QgsProject::instance()->setCrs(defaultCrs);
        }

        // 强制处理事件队列，确保UI更新
        QApplication::processEvents();

        m_customLayerTreeView->clear();
        m_projectFilePath.clear();
        m_isProjectDirty = false;
        updateWindowTitle();
        OutputManager::instance()->logMessage("新项目已创建，默认CRS为WGS 84。");
    }
}

// **修改 onOpenProject 函数**
// 在成功读取项目后，我们不需要手动调用 updateProjectCrs，因为 QgsProject::read() 
// 会自动设置新的CRS，并发出 crsChanged 信号，从而自动触发我们的槽函数。
void QGIS_dev::onOpenProject()
{
    if (maybeSave()) {
        QString filePath = QFileDialog::getOpenFileName(this, "打开QGIS项目", QDir::homePath(), "QGIS Projects (*.qgz *.qgs)");
        if (filePath.isEmpty()) return;

        QgsProject::instance()->clear();
        m_customLayerTreeView->clear();

        if (QgsProject::instance()->read(filePath)) {
            m_projectFilePath = filePath;
            rebuildLayerTreeFromProject();
            m_isProjectDirty = false;
            updateWindowTitle();
            OutputManager::instance()->logMessage("项目已打开: " + filePath);
            // **注意**: 这里不需要手动调用 updateProjectCrs()
        }
        else {
            QMessageBox::critical(this, "错误", "无法读取项目文件: " + filePath);
            m_projectFilePath.clear();
            updateWindowTitle();
        }
    }
}

bool QGIS_dev::onSaveProject()
{
    if (m_projectFilePath.isEmpty()) {
        return onSaveProjectAs();
    }
    else {
        // 设置项目路径，以便QGIS保存相对路径
        QgsProject::instance()->setFileName(QFileInfo(m_projectFilePath).path());
        if (QgsProject::instance()->write(m_projectFilePath)) {
            m_isProjectDirty = false;
            updateWindowTitle();
            OutputManager::instance()->logMessage("项目已保存: " + m_projectFilePath);
            return true;
        }
        else {
            QMessageBox::critical(this, "错误", "项目保存失败！");
            return false;
        }
    }
}

bool QGIS_dev::onSaveProjectAs()
{
    QString filePath = QFileDialog::getSaveFileName(this, "项目另存为", m_projectFilePath.isEmpty() ? QDir::homePath() : m_projectFilePath, "QGIS Projects (*.qgz)");
    if (filePath.isEmpty()) return false;

    // 如果没有.qgz后缀，则添加
    if (!filePath.endsWith(".qgz", Qt::CaseInsensitive)) {
        filePath += ".qgz";
    }

    m_projectFilePath = filePath;
    return onSaveProject();
}

void QGIS_dev::onOpenLogFolder()
{
    // 获取可执行文件所在目录
    QDir exeDir = QCoreApplication::applicationDirPath(); // 修改为 QDir 类型  
    exeDir.cdUp();
    exeDir.cdUp();
    QString logDir = exeDir.filePath("logs");

    QDir dir(logDir);
    if (!dir.exists()) {
        QMessageBox::warning(this, "提示", "日志文件夹不存在: " + logDir);
        return;
    }
#if defined(Q_OS_WIN)
    QProcess::startDetached("explorer.exe", { QDir::toNativeSeparators(logDir) });
#elif defined(Q_OS_MAC)
    QProcess::startDetached("open", { logDir });
#else // Linux/Unix
    QProcess::startDetached("xdg-open", { logDir });
#endif
}

// --- 在此设置所有的工具栏 ---
void QGIS_dev::setupToolBar() 
{   
    //--- 放大缩小工具---
    m_zoomInAction = new QAction("放大", this);
    m_zoomInAction->setStatusTip("放大");
    m_zoomInAction->setIcon(QIcon("resource/images/放大.png"));
    connect(m_zoomInAction, &QAction::triggered, m_mapCanvas, &MapCanvas::zoomIn);

    m_zoomOutAction = new QAction("缩小", this);
    m_zoomOutAction->setStatusTip("缩小");
    m_zoomOutAction->setIcon(QIcon("resource/images/缩小.png"));
    connect(m_zoomOutAction, &QAction::triggered, m_mapCanvas, &MapCanvas::zoomOut);

    // --- 地图工具 ---
    m_selectionTool = new FeatureSelectionTool(m_mapCanvas->getCanvas());

    m_panAction = new QAction("平移", this);
    m_panAction->setIcon(QIcon("resource/images/平移.png"));
    m_panAction->setCheckable(true); // 工具按钮是状态性的，所以设为可选中
    m_panAction->setStatusTip("平移地图");
    connect(m_panAction, &QAction::triggered, this, &QGIS_dev::onActivatePanTool);

    m_selectAction = new QAction("选择要素", this);
    m_selectAction->setIcon(QIcon("resource/images/选择.png"));
    m_selectAction->setCheckable(true);
    m_selectAction->setStatusTip("点击以选择要素并查看信息");
    connect(m_selectAction, &QAction::triggered, this, &QGIS_dev::onActivateSelectTool);

    // 3. 使用 QActionGroup 确保同一时间只有一个工具被激活
    m_toolActionGroup = new QActionGroup(this);
    m_toolActionGroup->addAction(m_panAction);
    m_toolActionGroup->addAction(m_selectAction);

    m_toolBar->addAction(m_zoomInAction);
    m_toolBar->addAction(m_zoomOutAction);
    m_toolBar->addSeparator();
    m_toolBar->addAction(m_panAction);
    m_toolBar->addAction(m_selectAction);
}

// --- 新增：实现激活工具的槽函数 ---
void QGIS_dev::onActivatePanTool()
{
    m_mapCanvas->getCanvas()->setMapTool(m_mapCanvas->getPanTool());
}

void QGIS_dev::onActivateSelectTool()
{
    m_mapCanvas->getCanvas()->setMapTool(m_selectionTool);
}

// QGIS_dev.cpp

void QGIS_dev::onAddVectorLayer()
{
    // ... (前面的项目保存检查逻辑不变) ...
    if (m_projectFilePath.isEmpty()) {
        QMessageBox::information(this, "提示", "请先保存您的项目，然后才能添加图层。");
        if (!onSaveProjectAs()) {
            return;
        }
    }

    QString filter = "Shapefile (*.shp);;GeoPackage (*.gpkg);;All files (*.*)";
    QString sourceFilePath = QFileDialog::getOpenFileName(this, "选择一个矢量文件", QDir::homePath(), filter);

    if (sourceFilePath.isEmpty()) return;

    QString copiedFileRelativePath;
    // 复制文件到项目文件夹
    if (!copyLayerDataToProject(sourceFilePath, copiedFileRelativePath)) {
        OutputManager::instance()->logError("复制图层数据失败！");
        return;
    }

    // ================== 关键修改 ==================
    // 1. 获取复制后文件的【绝对路径】
    QDir projectDir(QFileInfo(m_projectFilePath).path());
    QString copiedFileAbsolutePath = projectDir.absoluteFilePath(copiedFileRelativePath);

    // 2. 使用【绝对路径】加载图层
    QString layerName = QFileInfo(copiedFileAbsolutePath).baseName();
    QgsVectorLayer* vectorLayer = new QgsVectorLayer(copiedFileAbsolutePath, layerName, "ogr");
    // ===============================================

    if (vectorLayer->isValid()) {
        if (vectorLayer->isValid()) {
            // +++ 恢复调用 +++
            if (!resolveLayerCrs(vectorLayer)) {
                delete vectorLayer;
                return;
            }

            QgsProject::instance()->addMapLayer(vectorLayer);
            updateProjectCrs();
            //m_mapCanvas->zoomToLayer(vectorLayer);
            m_mapCanvas->getCanvas()->zoomToFullExtent();
            OutputManager::instance()->logMessage("成功加载矢量图层: " + copiedFileAbsolutePath);
        }
        else {
            // ================== 关键修改 ==================
            // 添加错误处理，这样才能看到失败的原因
            QString errorMsg = "加载矢量图层失败: " + copiedFileAbsolutePath;
            OutputManager::instance()->logError(errorMsg);
            OutputManager::instance()->logError("错误详情: " + vectorLayer->error().message());
            delete vectorLayer; // 释放内存
            // ===============================================
        }
    }
}

void QGIS_dev::onAddRasterLayer()
{
    if (m_projectFilePath.isEmpty()) {
        QMessageBox::information(this, "提示", "请先保存您的项目，然后才能添加图层。");
        if (!onSaveProjectAs()) return;
    }

    QString filter = "GeoTIFF (*.tif *.tiff);;Erdas Imagine (*.img);;All files (*.*)";
    QString sourceFilePath = QFileDialog::getOpenFileName(this, "选择一个栅格文件", QDir::homePath(), filter);

    if (sourceFilePath.isEmpty()) return;

    QString copiedFileRelativePath;
    if (!copyLayerDataToProject(sourceFilePath, copiedFileRelativePath)) {
        QString errorString = QFile().errorString(); // 获取静态方法的返回值
        OutputManager::instance()->logError(
            QString("复制文件失败: %1 -> %2, 错误: %3")
            .arg(sourceFilePath)
            .arg(copiedFileRelativePath)
            .arg(errorString)
        );
        return;
    }

    // ================== 关键修改 ==================
    // 1. 获取复制后文件的【绝对路径】
    QDir projectDir(QFileInfo(m_projectFilePath).path());
    QString copiedFileAbsolutePath = projectDir.absoluteFilePath(copiedFileRelativePath);

    // 2. 使用【绝对路径】加载图层
    QString layerName = QFileInfo(copiedFileAbsolutePath).baseName();
    // 注意: QGIS 3.x 推荐用 "gdal" provider for rasters
    QgsRasterLayer* rasterLayer = new QgsRasterLayer(copiedFileAbsolutePath, layerName, "gdal");
    // ===============================================

    if (rasterLayer->isValid()) {
        // +++ 恢复调用 +++
        if (!resolveLayerCrs(rasterLayer)) {
            delete rasterLayer;
            return;
        }

        QgsProject::instance()->addMapLayer(rasterLayer);
        updateProjectCrs();
        //m_mapCanvas->zoomToLayer(rasterLayer);
        m_mapCanvas->getCanvas()->zoomToFullExtent();
        OutputManager::instance()->logMessage("成功加载栅格图层: " + copiedFileAbsolutePath);
    }
    else {
        // ================== 关键修改 ==================
        // 添加错误处理
        QString errorMsg = "加载栅格图层失败: " + copiedFileAbsolutePath;
        OutputManager::instance()->logError(errorMsg);
        OutputManager::instance()->logError("错误详情: " + rasterLayer->error().message());
        delete rasterLayer;
        // ===============================================
    }
}

// ---- 辅助函数实现 ----

void QGIS_dev::onProjectDirty() {
    m_isProjectDirty = true;
    updateWindowTitle();
}

void QGIS_dev::updateWindowTitle() {
    QString title = m_projectFilePath.isEmpty() ? "未命名项目" : QFileInfo(m_projectFilePath).fileName();
    if (m_isProjectDirty) {
        title += "*";
    }
    title += " - My GIS App";
    setWindowTitle(title);
}

// 检查并提示保存
bool QGIS_dev::maybeSave() {
    if (!m_isProjectDirty) return true;

    const QMessageBox::StandardButton ret = QMessageBox::warning(this, "未保存的更改",
        "当前项目有未保存的更改，您想保存吗？",
        QMessageBox::Save | QMessageBox::Discard | QMessageBox::Cancel);

    if (ret == QMessageBox::Save) {
        return onSaveProject();
    }
    else if (ret == QMessageBox::Cancel) {
        return false;
    }
    return true; // Discard
}

// 关闭事件
void QGIS_dev::closeEvent(QCloseEvent* event) {
    if (maybeSave()) {
        event->accept();
    }
    else {
        event->ignore();
    }
}

// 重新构建图层树
void QGIS_dev::rebuildLayerTreeFromProject() {
    m_customLayerTreeView->clear();
    // QgsProject::mapLayers() 返回的是一个 map，值是图层指针
    // 我们需要按照图层树的顺序来添加
    QgsLayerTree* layerTree = QgsProject::instance()->layerTreeRoot();
    for (QgsLayerTreeNode* node : layerTree->children()) {
        if (node->nodeType() == QgsLayerTreeNode::NodeLayer) {
            QgsLayerTreeLayer* layerNode = static_cast<QgsLayerTreeLayer*>(node);
            m_customLayerTreeView->addLayer(layerNode->layer());
        }
    }
    // 确保画布也更新
    m_customLayerTreeView->updateMapCanvasLayers();
}

// 复制数据文件到项目目录
bool QGIS_dev::copyLayerDataToProject(const QString& sourceFilePath, QString& newRelativePath) {
    QDir projectDir(QFileInfo(m_projectFilePath).path());
    if (!projectDir.exists("data")) {
        projectDir.mkdir("data");
    }
    QDir dataDir(projectDir.filePath("data"));

    QString fileName = QFileInfo(sourceFilePath).fileName();
    QString destFilePath = dataDir.filePath(fileName);

    // 特殊处理 Shapefile
    if (sourceFilePath.endsWith(".shp", Qt::CaseInsensitive)) {
        if (!copyShapefile(sourceFilePath, dataDir.path(), fileName)) {
            return false;
        }
    }
    else { // 处理单个文件 (如.tif, .gpkg)
        if (QFile::exists(destFilePath)) {
            // 可选：询问用户是否覆盖
        }
        if (!QFile::copy(sourceFilePath, destFilePath)) {
            return false;
        }
    }

    newRelativePath = "data/" + fileName;
    return true;
}

// 专门用来复制Shapefile及其所有组件的函数
bool QGIS_dev::copyShapefile(const QString& sourceShpPath, const QString& destDir, QString& newFileName) {
    QString baseName = QFileInfo(sourceShpPath).completeBaseName();
    QDir sourceDir = QFileInfo(sourceShpPath).dir();

    QStringList extensions = { ".shp", ".shx", ".dbf", ".prj", ".cpg", ".sbn", ".sbx" };
    for (const QString& ext : extensions) {
        QString sourceFile = sourceDir.filePath(baseName + ext);
        if (QFile::exists(sourceFile)) {
            QString destFile = QDir(destDir).filePath(QFileInfo(sourceFile).fileName());
            if (QFile::exists(destFile)) QFile::remove(destFile); // 先删除以防万一
            if (!QFile::copy(sourceFile, destFile)) {
                OutputManager::instance()->logError("无法复制文件: " + sourceFile);
                return false;
            }
        }
    }
    newFileName = QFileInfo(sourceShpPath).fileName();
    return true;
}

void QGIS_dev::onCurrentLayerChanged(QgsMapLayer* layer)
{
    m_currentLayer = layer;
    // 不再需要在这里更新任何状态栏的标签。
    // 状态栏的更新应该由它们各自的事件驱动。
    // 比如坐标由鼠标移动事件驱动，比例尺由画布缩放事件驱动，CRS由项目CRS改变事件驱动。
}


// 修正 updateCoordinates，去掉对 m_currentLayer 的依赖
void QGIS_dev::updateCoordinates(const QgsPointXY& point)
{
    // 这个函数之前的版本已经是正确的了，我们保持它
    try {
        const QgsCoordinateReferenceSystem destCrs = m_mapCanvas->getCanvas()->mapSettings().destinationCrs();

        if (!destCrs.isValid()) {
            m_coordsLabel->setText("坐标: (未知坐标系)");
            return;
        }

        m_coordsLabel->setText(QString::asprintf("坐标: %.4f, %.4f", point.x(), point.y()));
    }
    catch (const std::exception& e) {
        // ... (异常处理不变) ...
    }
}


// **核心修正：彻底解耦 updateScale 与 m_currentLayer**
void QGIS_dev::updateScale(double scale)
{
    // **删除 if (!m_currentLayer) 的判断**

    if (scale <= 0) {
        m_scaleLabel->setText("比例尺: N/A");
        return;
    }

    // 直接更新比例尺标签
    m_scaleLabel->setText(QString("比例尺 1:%1").arg(static_cast<long>(scale)));
}

// +++ 新增槽函数的实现 +++
// updateProjectCrs 函数实现修改 (使用 m_crsButton)
void QGIS_dev::updateProjectCrs()
{
    // 这个函数的 try-catch 结构很好，保持它
    try {
        QgsCoordinateReferenceSystem crs = QgsProject::instance()->crs();

        if (crs.isValid()) {
            // 我们只显示简短的 authid，把详细描述放在 tooltip 里
            m_crsButton->setText(crs.authid());
            m_crsButton->setToolTip(QString("当前项目CRS: %1\n点击以更改...").arg(crs.description()));
        }
        else {
            m_crsButton->setText("未知坐标系");
            m_crsButton->setToolTip("当前项目未设置CRS\n点击以选择...");
        }
    }
    catch (const std::exception& e) {
        // ... (异常处理不变) ...
    }
}

// +++ 实现新的槽函数 onChangeProjectCrs +++
void QGIS_dev::onChangeProjectCrs()
{
    // ====================== 使用新API的核心修改 ======================

    // 1. 创建 QgsProjectionSelectionDialog 实例
    //    它继承自 QDialog，所以用法和旧的 QgsProjectionSelector 类似
    QgsProjectionSelectionDialog dialog(this);
    dialog.setWindowTitle("选择项目坐标参考系");

    // 2. 设置对话框的初始CRS，为当前项目的CRS
    dialog.setCrs(QgsProject::instance()->crs());

    // 3. 执行对话框，并检查用户是否点击了 "OK"
    if (dialog.exec() == QDialog::Accepted)
    {
        // 4. 从对话框中获取用户选择的CRS
        QgsCoordinateReferenceSystem newCrs = dialog.crs();

        if (newCrs.isValid()) {
            // 直接设置项目的CRS，这会自动触发 crsChanged 信号，
            // 进而调用 updateProjectCrs 来更新按钮文本。
            QgsProject::instance()->setCrs(newCrs);
        }
    }
    // =================================================================
}

// resolveLayerCrs 函数的最终实现
// 最终专业版 resolveLayerCrs
bool QGIS_dev::resolveLayerCrs(QgsMapLayer* layer)
{
    if (!layer) return false;

    QgsCoordinateReferenceSystem layerCrs = layer->crs();

    // Case 1: 图层完全没有CRS定义
    if (!layerCrs.isValid()) {
        QMessageBox msgBox(this);
        msgBox.setIcon(QMessageBox::Warning);
        msgBox.setWindowTitle("缺少坐标参考系");
        msgBox.setText(QString("图层 '%1' 缺少坐标参考系(CRS)定义。").arg(layer->name()));
        msgBox.setInformativeText("您必须为该图层指定一个CRS，否则无法正确加载。\n"
            "如果您不确定，通常可以选择 'WGS 84' (EPSG:4326)。");

        QPushButton* selectButton = msgBox.addButton("指定CRS...", QMessageBox::ActionRole);
        msgBox.addButton("取消加载", QMessageBox::RejectRole);
        msgBox.exec();

        if (msgBox.clickedButton() == selectButton) {
            QgsProjectionSelectionDialog dialog(this);
            if (dialog.exec() == QDialog::Accepted) {
                QgsCoordinateReferenceSystem newCrs = dialog.crs();
                if (newCrs.isValid()) {
                    layer->setCrs(newCrs); // 这是“定义/指定”操作
                    OutputManager::instance()->logMessage(QString("用户为图层 '%1' 指定了CRS: %2").arg(layer->name()).arg(newCrs.description()));
                    return true;
                }
            }
        }

        OutputManager::instance()->logWarning(QString("用户取消为图层 '%1' 指定CRS，加载中止。").arg(layer->name()));
        return false;
    }
    // Case 2: 图层有CRS，但可能不规范 (如没有authid)
    else if (layerCrs.authid().isEmpty()) {
        OutputManager::instance()->logWarning(
            QString("图层 '%1' 的CRS '%2' 缺少标准的EPSG代码，可能会影响部分功能，但仍将加载。")
            .arg(layer->name()).arg(layerCrs.description())
        );
        // 我们选择接受它，并让QGIS尝试动态投影
        return true;
    }

    // Case 3: 图层有一个合格的、带authid的CRS。一切正常。
    return true;
}

void QGIS_dev::onAddDelimitedTextLayer()
{
    QString filePath = QFileDialog::getOpenFileName(this,
        "选择一个分隔符文本文件",
        QDir::homePath(),
        "CSV (逗号分隔) (*.csv);;文本文件 (*.txt);;所有文件 (*.*)");

    if (filePath.isEmpty()) {
        return;
    }

    // ====================== 核心加固 ======================

    // 1. 确保文件路径使用正斜杠
    QString forwardSlashPath = filePath;
    forwardSlashPath.replace('\\', '/');

    // 2. 使用 QUrl 来安全地构造URI，它会自动处理特殊字符和协议前缀
    QUrl fileUrl = QUrl::fromLocalFile(forwardSlashPath);

    // 3. 构建参数部分
    QUrlQuery query;
    query.addQueryItem("encoding", "UTF-8");
    query.addQueryItem("delimiter", ",");
    query.addQueryItem("xField", "lon");
    query.addQueryItem("yField", "lat");
    query.addQueryItem("crs", "epsg:4326");
    query.addQueryItem("spatialIndex", "yes");
    query.addQueryItem("subsetIndex", "no");
    query.addQueryItem("watchFile", "no");

    // 4. 将参数附加到URL上
    fileUrl.setQuery(query);

    // 5. 从 QUrl 获取最终的、格式正确的URI字符串
    QString uri = fileUrl.toString();

    OutputManager::instance()->logMessage("构造的URI: " + uri); // 打印URI到日志，方便调试
    // =======================================================

    QString layerName = QFileInfo(filePath).baseName();
    QgsVectorLayer* layer = new QgsVectorLayer(uri, layerName, "delimitedtext");

    if (!layer || !layer->isValid()) {
        // ... (错误信息对话框不变) ...
        // +++ 增加更详细的错误日志 +++
        OutputManager::instance()->logError("加载分隔符文本图层失败。");
        OutputManager::instance()->logError("Provider 错误: " + layer->error().message());
        delete layer;
        return;
    }

    QgsProject::instance()->addMapLayer(layer);
    m_mapCanvas->getCanvas()->zoomToFullExtent();
    OutputManager::instance()->logMessage("成功加载分隔符文本图层: " + filePath);
}
正在处理文件: RasterLayerPropertiesDialog.cpp
(RasterLayerPropertiesDialog.cpp)
// RasterLayerPropertiesDialog.cpp
#include "RasterLayerPropertiesDialog.h"
#include <qgsrasterlayer.h>
#include <qgscoordinatereferencesystem.h>
#include <qgsrectangle.h>
#include <qgsrasterbandstats.h>
#include "gdal_priv.h"
#include "cpl_conv.h"
#include <QVBoxLayout>
#include <QLabel>
#include <QTableWidget>
#include <QTextEdit>
#include <QHeaderView>
#include <QGroupBox>
#include <QDebug>
#include <QPushButton>
#include <QFile>

RasterLayerPropertiesDialog::RasterLayerPropertiesDialog(QgsRasterLayer* layer, QWidget* parent)
    : QDialog(parent), m_rasterLayer(layer)
{
    if (!m_rasterLayer || !m_rasterLayer->isValid()) {
        qWarning() << "RasterLayerPropertiesDialog created with invalid layer.";
        // 如果在构造时就出错，最好不要继续执行setupUI，可以简单地reject
        // QTimer::singleShot(0, this, &QDialog::reject); // 异步关闭，避免在构造中直接reject可能的问题
        return; // 或者直接返回，让调用者检查并处理
    }

    setWindowTitle(QString("栅格图层属性 - %1").arg(m_rasterLayer->name()));
    resize(700, 650); // 尝试一个更大的尺寸
    setupUI();
    populateGeneralInfo();
    populateAllBandStatistics(); // 初始化时就显示所有波段统计
}

RasterLayerPropertiesDialog::~RasterLayerPropertiesDialog()
{
}

void RasterLayerPropertiesDialog::setupUI()
{
    QVBoxLayout* mainLayout = new QVBoxLayout(this);

    // --- 1. 基本信息组 ---
    QGroupBox* infoGroup = new QGroupBox("基本信息", this);
    QVBoxLayout* infoLayout = new QVBoxLayout(infoGroup);
    m_infoTableWidget = new QTableWidget(this);
    m_infoTableWidget->setColumnCount(2);
    m_infoTableWidget->setHorizontalHeaderLabels({ "属性", "值" });

    m_infoTableWidget->horizontalHeader()->setSectionResizeMode(0, QHeaderView::ResizeToContents); // “属性”列根据内容自动调整
    m_infoTableWidget->horizontalHeader()->setSectionResizeMode(1, QHeaderView::Stretch);       // “值”列自动拉伸填充

    m_infoTableWidget->horizontalHeader()->setStretchLastSection(true);
    m_infoTableWidget->verticalHeader()->setVisible(false);
    m_infoTableWidget->setEditTriggers(QAbstractItemView::NoEditTriggers);
    m_infoTableWidget->setSelectionMode(QAbstractItemView::NoSelection);
    infoLayout->addWidget(m_infoTableWidget);
    infoGroup->setLayout(infoLayout);
    mainLayout->addWidget(infoGroup);

    // --- 2. 所有波段统计信息组 ---
    QGroupBox* allStatsGroup = new QGroupBox("所有波段统计", this);
    QVBoxLayout* allStatsLayout = new QVBoxLayout(allStatsGroup);
    m_allBandStatsTextEdit = new QTextEdit(this);
    m_allBandStatsTextEdit->setReadOnly(true);

    // 调整字体
    QFont statsFont("Courier", 9); // 使用Courier字体（等宽），字号设为9
    m_allBandStatsTextEdit->setFont(statsFont);
    // 或者只改变字号:
    // QFont currentFont = m_allBandStatsTextEdit->font();
    // currentFont.setPointSize(9); // 设置一个较小的字号
    // m_allBandStatsTextEdit->setFont(currentFont);

    allStatsLayout->addWidget(m_allBandStatsTextEdit);
    allStatsGroup->setLayout(allStatsLayout);
    mainLayout->addWidget(allStatsGroup);

    mainLayout->addStretch(); // 确保内容靠上

    // (可选) 添加一个关闭按钮
    QHBoxLayout* buttonLayout = new QHBoxLayout();
    buttonLayout->addStretch();
    QPushButton* closeButton = new QPushButton("关闭", this);
    connect(closeButton, &QPushButton::clicked, this, &QDialog::accept);
    buttonLayout->addWidget(closeButton);
    mainLayout->addLayout(buttonLayout);

    setLayout(mainLayout);
}

void RasterLayerPropertiesDialog::populateGeneralInfo()
{
    if (!m_rasterLayer) return;

    m_infoTableWidget->setRowCount(0); // 清空旧内容

    auto addInfoRow = [&](const QString& label, const QString& value) {
        int row = m_infoTableWidget->rowCount();
        m_infoTableWidget->insertRow(row);
        m_infoTableWidget->setItem(row, 0, new QTableWidgetItem(label));
        m_infoTableWidget->setItem(row, 1, new QTableWidgetItem(value));
        };

    addInfoRow("名称:", m_rasterLayer->name());
    addInfoRow("路径:", m_rasterLayer->source());
    addInfoRow("宽度 (列):", QString::number(m_rasterLayer->width()));
    addInfoRow("高度 (行):", QString::number(m_rasterLayer->height()));
    addInfoRow("波段数量:", QString::number(m_rasterLayer->bandCount()));

    QgsCoordinateReferenceSystem crs = m_rasterLayer->crs();
    if (crs.isValid()) {
        addInfoRow("坐标参考系:", QString("%1 (%2)").arg(crs.description()).arg(crs.authid()));
    }
    else {
        addInfoRow("坐标参考系:", "未知");
    }

    QgsRectangle extent = m_rasterLayer->extent();
    if (!extent.isEmpty()) {
        addInfoRow("范围 (XMin):", QString::number(extent.xMinimum()));
        addInfoRow("范围 (YMin):", QString::number(extent.yMinimum()));
        addInfoRow("范围 (XMax):", QString::number(extent.xMaximum()));
        addInfoRow("范围 (YMax):", QString::number(extent.yMaximum()));
    }
    else {
        addInfoRow("范围:", "未知");
    }
    m_infoTableWidget->resizeColumnsToContents();
}

void RasterLayerPropertiesDialog::populateAllBandStatistics()
{
    if (!m_rasterLayer) return;

    m_allBandStatsTextEdit->clear();
    QString statsTextAccumulator; // 用于累积所有波段的文本

    // 获取栅格文件的完整路径
    QString rasterFilePath = m_rasterLayer->source();
    if (rasterFilePath.isEmpty() || !QFile::exists(rasterFilePath)) {
        statsTextAccumulator = "错误：无法获取有效的栅格文件路径。";
        m_allBandStatsTextEdit->setText(statsTextAccumulator);
        return;
    }

    qDebug() << "Populating all band statistics using GDAL for:" << rasterFilePath;

    // 注册所有GDAL驱动 (通常在QgsApplication::initQgis()中已完成，但再次调用无害)
    GDALAllRegister();

    // 打开栅格数据集
    GDALDataset* poDataset = (GDALDataset*)GDALOpen(rasterFilePath.toUtf8().constData(), GA_ReadOnly);
    if (poDataset == nullptr) {
        statsTextAccumulator = QString("GDAL错误：无法打开栅格文件。\n%1").arg(CPLGetLastErrorMsg());
        m_allBandStatsTextEdit->setText(statsTextAccumulator);
        return;
    }

    int numBands = poDataset->GetRasterCount();
    if (numBands == 0) {
        statsTextAccumulator = "错误：栅格文件不包含任何波段。";
        m_allBandStatsTextEdit->setText(statsTextAccumulator);
        GDALClose(poDataset);
        return;
    }

    // 遍历所有波段
    for (int i = 1; i <= numBands; ++i) {
        statsTextAccumulator += QString("--- 波段 %1 ---\n").arg(i);

        GDALRasterBand* poBand = poDataset->GetRasterBand(i);
        if (poBand == nullptr) {
            statsTextAccumulator += QString("  错误：无法获取波段 %1 的数据。\n\n").arg(i);
            continue; // 继续下一个波段
        }

        // 尝试获取元数据中的统计值，或进行近似计算
        double dfMin = 0.0, dfMax = 0.0, dfMean = 0.0, dfStdDev = 0.0;
        int bSuccessMin, bSuccessMax;

        dfMin = poBand->GetMinimum(&bSuccessMin);
        dfMax = poBand->GetMaximum(&bSuccessMax);

        // 如果元数据中没有Min/Max，或者获取失败，则计算近似值
        if (!bSuccessMin || !bSuccessMax) {
            qDebug() << "Band" << i << ": No Min/Max in metadata, computing (approximate)...";
            // ComputeRasterMinMax的第二个参数是输出数组，第一个是Min，第二个是Max
            double adfMinMax[2];
            if (poBand->ComputeRasterMinMax(TRUE, adfMinMax) == CE_None) { // TRUE for ApproxOK
                dfMin = adfMinMax[0];
                dfMax = adfMinMax[1];
            }
            else {
                qDebug() << "GDAL ComputeRasterMinMax for band" << i << "FAILED:" << CPLGetLastErrorMsg();
            }
        }

        // 尝试获取均值和标准差 (GetStatistics会尝试从元数据读取，如果不存在则计算)
        // 第一个参数 bApproxOK 设为 TRUE
        if (poBand->GetStatistics(TRUE, TRUE, &dfMin, &dfMax, &dfMean, &dfStdDev) == CE_Failure) {
            qDebug() << "GDAL GetStatistics for band" << i << "FAILED: " << CPLGetLastErrorMsg();
            // 作为后备，再尝试一次 ComputeStatistics (近似)
            if (poBand->ComputeStatistics(TRUE, &dfMean, &dfStdDev, nullptr, nullptr, nullptr, nullptr) == CE_Failure) {
                qDebug() << "GDAL ComputeStatistics (fallback) for band" << i << "FAILED: " << CPLGetLastErrorMsg();
            }
        }

        // 获取NoData值
        int bGotNoData;
        double nodataValue = poBand->GetNoDataValue(&bGotNoData);

        statsTextAccumulator += QString("  最小值: %1\n").arg(dfMin);
        statsTextAccumulator += QString("  最大值: %1\n").arg(dfMax);
        statsTextAccumulator += QString("  平均值: %1\n").arg(dfMean);
        statsTextAccumulator += QString("  标准差: %1\n").arg(dfStdDev);
        if (bGotNoData) {
            statsTextAccumulator += QString("  NoData值: %1\n").arg(nodataValue);
        }
        statsTextAccumulator += "\n";
    }

    GDALClose(poDataset); // 关闭数据集
    m_allBandStatsTextEdit->setText(statsTextAccumulator);
}
正在处理文件: ReprojectRasterDialog.cpp
(ReprojectRasterDialog.cpp)
#include "ReprojectRasterDialog.h"
#include <QVBoxLayout>
#include <QHBoxLayout>
#include <QGridLayout>
#include <QLabel>
#include <QComboBox>
#include <QPushButton>
#include <QLineEdit>
#include <QFileDialog>
#include <QMessageBox>
#include <QStandardPaths>
#include <QFileInfo>

#include <qgsproject.h>
#include <qgsrasterlayer.h>
// #include <qgsprojectionselectionwidget.h> // 不再需要
// #include <qgsprojectionselectiondialog.h> // 不再需要
#include "Output_Manager.h"
#include <QDebug>

// GDAL
#include "gdal_priv.h"
#include "gdalwarper.h"
#include "cpl_conv.h"
#include "cpl_string.h"
#include "ogr_spatialref.h"


ReprojectRasterDialog::ReprojectRasterDialog(QWidget* parent)
    : QDialog(parent),
    // +++ 明确初始化所有指针成员为 nullptr +++
    m_inputRasterCombo(nullptr),
    m_btnSelectInputRasterFile(nullptr),
    m_lblSelectedRasterInfo(nullptr),
    m_lblCurrentCrsInfo(nullptr),
    m_lblTargetCrs(nullptr),
    m_targetCrsCombo(nullptr),
    m_editOutputRasterPath(nullptr),
    m_btnSelectOutputRaster(nullptr),
    m_btnOk(nullptr),
    m_btnCancel(nullptr)
    // m_currentTargetCrs 会被默认构造
{
    setWindowTitle("栅格投影转换");
    setMinimumWidth(550);

    setupUI(); // 创建并布局所有UI控件

    populateInputRasterComboBox();
    populateTargetCrsComboBox();

    // --- 将所有 connect 语句集中到构造函数的末尾 ---
    // 确保此时所有UI控件都已创建完毕
    if (m_inputRasterCombo) { // 防御性检查
        connect(m_inputRasterCombo, QOverload<int>::of(&QComboBox::currentIndexChanged), this, &ReprojectRasterDialog::onInputRasterChanged);
    }
    if (m_targetCrsCombo) { // 防御性检查
        connect(m_targetCrsCombo, QOverload<int>::of(&QComboBox::currentIndexChanged), this, &ReprojectRasterDialog::onTargetCrsComboChanged);
    }
    if (m_btnSelectInputRasterFile) { // 防御性检查
        connect(m_btnSelectInputRasterFile, &QPushButton::clicked, this, &ReprojectRasterDialog::onSelectInputRasterClicked);
    }
    if (m_btnSelectOutputRaster) { // 防御性检查
        connect(m_btnSelectOutputRaster, &QPushButton::clicked, this, &ReprojectRasterDialog::onSelectOutputRasterClicked);
    }
    if (m_btnOk) { // 防御性检查
        connect(m_btnOk, &QPushButton::clicked, this, &ReprojectRasterDialog::onOkClicked);
    }
    if (m_btnCancel) { // 防御性检查
        connect(m_btnCancel, &QPushButton::clicked, this, &QDialog::reject);
    }
}

ReprojectRasterDialog::~ReprojectRasterDialog()
{
    // 如果有资源需要释放，可以在这里添加代码
}

void ReprojectRasterDialog::setupUI()
{
    // === 1. 创建布局 ===
    QVBoxLayout* mainLayout = new QVBoxLayout(this);
    QGridLayout* gridLayout = new QGridLayout();

    // === 2. 创建所有UI控件 (严格按照先new再使用的顺序) ===
    // 输入栅格
    QLabel* lblInputRaster = new QLabel("输入栅格图层:", this);
    m_inputRasterCombo = new QComboBox(this);
    m_btnSelectInputRasterFile = new QPushButton("从文件...", this);
    m_lblSelectedRasterInfo = new QLabel("当前选择: 无", this);
    m_lblCurrentCrsInfo = new QLabel("源CRS: 未知", this);

    // 目标CRS选择
    m_lblTargetCrs = new QLabel("选择目标CRS:", this);
    m_targetCrsCombo = new QComboBox(this);

    // 输出栅格路径
    QLabel* lblOutputPath = new QLabel("输出栅格路径:", this);
    m_editOutputRasterPath = new QLineEdit(this);
    m_editOutputRasterPath->setPlaceholderText("选择输出文件路径...");
    m_btnSelectOutputRaster = new QPushButton("浏览...", this);

    // 确定和取消按钮
    m_btnOk = new QPushButton("确定", this);
    m_btnCancel = new QPushButton("取消", this);

    // === 3. 将控件添加到布局中 ===
    gridLayout->addWidget(lblInputRaster, 0, 0);
    gridLayout->addWidget(m_inputRasterCombo, 0, 1);
    gridLayout->addWidget(m_btnSelectInputRasterFile, 0, 2);
    gridLayout->addWidget(m_lblSelectedRasterInfo, 1, 0, 1, 3);
    gridLayout->addWidget(m_lblCurrentCrsInfo, 2, 0, 1, 3);

    gridLayout->addWidget(m_lblTargetCrs, 3, 0);
    gridLayout->addWidget(m_targetCrsCombo, 3, 1, 1, 2);

    gridLayout->addWidget(lblOutputPath, 4, 0);
    gridLayout->addWidget(m_editOutputRasterPath, 4, 1);
    gridLayout->addWidget(m_btnSelectOutputRaster, 4, 2);

    mainLayout->addLayout(gridLayout);
    mainLayout->addStretch();

    QHBoxLayout* buttonLayout = new QHBoxLayout();
    buttonLayout->addStretch();
    buttonLayout->addWidget(m_btnOk);
    buttonLayout->addWidget(m_btnCancel);
    mainLayout->addLayout(buttonLayout);

    setLayout(mainLayout);

    // **注意：将connect语句移到构造函数的末尾，在所有控件创建之后**
}

void ReprojectRasterDialog::populateInputRasterComboBox()
{
    m_inputRasterCombo->clear();
    m_inputRasterCombo->addItem("--- 从项目中选择栅格 ---", QVariant());
    QList<QgsMapLayer*> layers = QgsProject::instance()->mapLayers().values();
    for (QgsMapLayer* layer : layers) {
            if (auto rasterLayer = qobject_cast<QgsRasterLayer*>(layer)) {
                m_inputRasterCombo->addItem(rasterLayer->name() + QString(" (%1)").arg(rasterLayer->crs().authid().isEmpty() ? "未知CRS" : rasterLayer->crs().authid()),
                    QVariant::fromValue(rasterLayer));
            }
    }
    onInputRasterChanged(0); // 更新初始状态
}


// +++ 新增：填充目标CRS下拉框的函数 +++
void ReprojectRasterDialog::populateTargetCrsComboBox()
{
    m_targetCrsCombo->clear();
    // 添加一些常见的CRS
    // 格式: 显示名称, QVariant(EPSG字符串)
    m_targetCrsCombo->addItem("WGS 84 (EPSG:4326)", "EPSG:4326");
    m_targetCrsCombo->addItem("Web Mercator (EPSG:3857)", "EPSG:3857");
    m_targetCrsCombo->addItem("CGCS2000 (EPSG:4490)", "EPSG:4490");
    m_targetCrsCombo->addItem("UTM Zone 48N (WGS84, EPSG:32648)", "EPSG:32648");
    m_targetCrsCombo->addItem("UTM Zone 49N (WGS84, EPSG:32649)", "EPSG:32649");
    m_targetCrsCombo->addItem("UTM Zone 50N (WGS84, EPSG:32650)", "EPSG:32650");
    m_targetCrsCombo->addItem("UTM Zone 51N (WGS84, EPSG:32651)", "EPSG:32651");
    // 可以根据需要添加更多

    // 默认选中第一个，并更新成员变量
    if (m_targetCrsCombo->count() > 0) {
        onTargetCrsComboChanged(0); // 触发更新 m_currentTargetCrs 和默认输出路径
    }
}


void ReprojectRasterDialog::onSelectInputRasterClicked()
{
    QString filePath = QFileDialog::getOpenFileName(this, "选择输入栅格文件",
        QStandardPaths::writableLocation(QStandardPaths::HomeLocation),
        "栅格文件 (*.tif *.tiff *.img);;所有文件 (*.*)");
    if (!filePath.isEmpty()) {
        m_currentInputRasterPath = filePath;
        m_lblSelectedRasterInfo->setText(QString("当前选择: %1 (文件)").arg(QFileInfo(filePath).fileName()));
        m_inputRasterCombo->setCurrentIndex(0);

        // 尝试读取文件CRS
        QgsRasterLayer tempLayer(filePath);
        if (tempLayer.isValid()) {
            QgsCoordinateReferenceSystem crs = tempLayer.crs();
            m_lblCurrentCrsInfo->setText(QString("源CRS: %1").arg(crs.isValid() ? crs.description() : "未知/无法读取"));
        }
        else {
            m_lblCurrentCrsInfo->setText("源CRS: 无法读取");
        }
        updateDefaultOutputPath();
    }
}

void ReprojectRasterDialog::onInputRasterChanged(int index)
{
    if (index > 0) { // 从项目中选择
        QVariant data = m_inputRasterCombo->itemData(index);
        QgsRasterLayer* layer = qvariant_cast<QgsRasterLayer*>(data);
        if (layer && QgsProject::instance()->mapLayer(layer->id())) {
            m_currentInputRasterPath = layer->source();
            m_lblSelectedRasterInfo->setText(QString("当前选择: %1 (项目)").arg(layer->name()));
            QgsCoordinateReferenceSystem crs = layer->crs();
            m_lblCurrentCrsInfo->setText(QString("源CRS: %1").arg(crs.isValid() ? crs.description() : "未知"));
        }
    }
    else {
        // 如果选择了 "---选择---" 但之前文件路径有值，保留文件路径的信息
        if (m_currentInputRasterPath.isEmpty() || !m_lblSelectedRasterInfo->text().contains("(文件)")) {
            m_currentInputRasterPath.clear();
            m_lblSelectedRasterInfo->setText("当前选择: 无");
            m_lblCurrentCrsInfo->setText("源CRS: 未知");
        }
    }
    updateDefaultOutputPath();
}


// +++ 新增：当目标CRS下拉框选项改变时 +++
void ReprojectRasterDialog::onTargetCrsComboChanged(int index)
{
    if (index >= 0) {
        QString epsgString = m_targetCrsCombo->itemData(index).toString();
        m_currentTargetCrs.createFromString(epsgString); // 更新成员变量
        if (!m_currentTargetCrs.isValid()) {
            qWarning() << "Failed to create target CRS from string:" << epsgString;
        }
    }
    else {
        m_currentTargetCrs = QgsCoordinateReferenceSystem(); // 设为无效
    }
    updateDefaultOutputPath(); // 目标CRS变了，默认输出名也可能要变
}


void ReprojectRasterDialog::updateDefaultOutputPath()
{
    if (m_currentInputRasterPath.isEmpty()) {
        m_editOutputRasterPath->clear();
        return;
    }

    QFileInfo fi(m_currentInputRasterPath);
    QString baseName = fi.completeBaseName();
    QString dirPath = fi.absolutePath();
    QString suffix = fi.suffix();

    QString crsSuffix = "reprojected";
    if (m_currentTargetCrs.isValid() && !m_currentTargetCrs.authid().isEmpty()) {
        crsSuffix = m_currentTargetCrs.authid().replace(":", "_");
    }
    else if (m_currentTargetCrs.isValid()) {
        // 如果没有authid但有效，可以用描述的一部分（需要处理特殊字符）
        QString desc = m_currentTargetCrs.description().simplified().replace(" ", "_").remove(QRegExp("[^a-zA-Z0-9_]"));
        crsSuffix = desc.left(15); // 取前15个字符
    }


    QString defaultOutputName = QString("%1_%2.%3").arg(baseName).arg(crsSuffix).arg(suffix.isEmpty() ? "tif" : suffix);
    m_editOutputRasterPath->setText(QDir(dirPath).filePath(defaultOutputName));
}

void ReprojectRasterDialog::onSelectOutputRasterClicked()
{
    // ... (与ResampleDialog中的实现类似，确保有默认后缀) ...
    QString defaultPath = m_editOutputRasterPath->text();
    // ... (获取并设置路径) ...
    QString filePath = QFileDialog::getSaveFileName(this, "选择输出栅格文件路径",
        defaultPath.isEmpty() ? QStandardPaths::writableLocation(QStandardPaths::HomeLocation) : defaultPath,
        "GeoTIFF (*.tif *.tiff);;Erdas Imagine (*.img);;所有文件 (*.*)");
    if (!filePath.isEmpty()) {
        if (QFileInfo(filePath).suffix().isEmpty()) {
            if (!filePath.endsWith(".")) filePath += ".";
            filePath += "tif";
        }
        m_editOutputRasterPath->setText(filePath);
    }
}

void ReprojectRasterDialog::onOkClicked()
{
    QString inputPath = m_currentInputRasterPath;
    // === 修改：从QComboBox获取目标CRS ===
    QgsCoordinateReferenceSystem targetCrs = m_currentTargetCrs;
    // ==================================
    QString outputPath = m_editOutputRasterPath->text();

    // --- 参数验证 ---
    if (inputPath.isEmpty()) { /* ... */ return; }
    if (!targetCrs.isValid()) { QMessageBox::warning(this, "输入错误", "请选择一个有效的目标坐标参考系。"); return; }
    if (outputPath.isEmpty()) { /* ... */ return; }

    qDebug() << "Reprojecting Raster (using GDALCreateAndReprojectImage):";
    qDebug() << "  Input:" << inputPath;
    qDebug() << "  Target CRS AuthID:" << targetCrs.authid() << "Desc:" << targetCrs.description();
    qDebug() << "  Output:" << outputPath;

    GDALAllRegister();
    GDALDatasetH hSrcDS = GDALOpen(inputPath.toUtf8().constData(), GA_ReadOnly);
    if (!hSrcDS) { /* ... */ return; }

    const char* pszSrcWKT = GDALGetProjectionRef(hSrcDS);
    if (pszSrcWKT == nullptr || strlen(pszSrcWKT) == 0) { /* ...警告并返回... */ GDALClose(hSrcDS); return; }

    // --- 获取目标WKT (从QgsCoordinateReferenceSystem对象) ---
    std::string targetWktStdString = targetCrs.toWkt().toStdString();
    // 或者 QgsCoordinateReferenceSystem::Wkt वन (更兼容旧GDAL)
    // std::string targetWktStdString = targetCrs.toWkt().toStdString(); 

    const char* pszDstWKT = targetWktStdString.c_str();
    // ----------------------------------------------------

    if (strlen(pszDstWKT) == 0) { /* ...错误并返回... */ GDALClose(hSrcDS); return; }
    qDebug() << "Source WKT:" << pszSrcWKT;
    qDebug() << "Target WKT:" << pszDstWKT;

    GDALResampleAlg eResampleAlg = GRA_Bilinear;
    GDALDriverH hDstDriver = GDALGetDriverByName("GTiff");
    if (!hDstDriver) { /* ... */ GDALClose(hSrcDS); return; }
    char** papszCreateOptions = nullptr;
    papszCreateOptions = CSLSetNameValue(papszCreateOptions, "TILED", "YES");
    papszCreateOptions = CSLSetNameValue(papszCreateOptions, "COMPRESS", "LZW");

    GDALWarpOptions* psOptions = GDALCreateWarpOptions(); // 仍然创建它，因为 GDALCreateAndReprojectImage 会用到

    CPLErr eErr = GDALCreateAndReprojectImage(
        hSrcDS, pszSrcWKT,
        outputPath.toUtf8().constData(), pszDstWKT,
        hDstDriver, papszCreateOptions,
        eResampleAlg,
        0.0, 0.125,
        GDALTermProgress, nullptr,
        psOptions
    );

    CSLDestroy(papszCreateOptions);
    GDALDestroyWarpOptions(psOptions);
    GDALClose(hSrcDS);

    if (eErr == CE_None) {
        QMessageBox::information(this, "成功",
            QString("栅格投影转换完成！\n输出文件已保存到:\n%1").arg(outputPath));
        // =====================================================================

        // (可选) 如果您希望转换成功后，自动将新生成的图层添加到项目中
        // QgsRasterLayer* newLayer = new QgsRasterLayer(outputPath, QFileInfo(outputPath).baseName());
        // if (newLayer->isValid()) {
        //     QgsProject::instance()->addMapLayer(newLayer);
        //     // 也可以在这里让主窗口的图层树刷新，或者缩放到新图层
        // } else {
        //     qWarning() << "Failed to load reprojected layer:" << outputPath << newLayer->error().message();
        //     delete newLayer;
        // }

        accept(); // 关闭对话框
    }
    else { QMessageBox::critical(this, "投影转换失败", "GDAL操作失败: " + QString(CPLGetLastErrorMsg())); }
}
正在处理文件: ResampleDialog.cpp
(ResampleDialog.cpp)
// ResampleDialog.cpp
#include "ResampleDialog.h"
#include <QVBoxLayout>
#include <QHBoxLayout>
#include <QGridLayout>
#include <QLabel>
#include <QComboBox>
#include <QPushButton>
#include <QLineEdit>
#include <QFileDialog>
#include <QMessageBox>
#include <QStandardPaths>
#include <QFileInfo>
#include <QDoubleSpinBox>

#include <qgsproject.h>
#include <qgsrasterlayer.h>
#include <qgsapplication.h> // For QgsApplication::messageBar() if needed
#include "Output_Manager.h" // 用于日志输出
#include <QDebug>
#include <qgsunittypes.h>

// GDAL for resampling (gdalwarp functionality)
#include "gdal_priv.h"
#include "gdalwarper.h"
#include "cpl_conv.h"
#include "gdal_alg.h"
#include "cpl_string.h"
#include "ogr_spatialref.h" // 如果涉及投影字符串

ResampleDialog::ResampleDialog(QWidget* parent)
    : QDialog(parent)
{
    setWindowTitle("栅格重采样");
    setMinimumWidth(550);
    setupUI();
    populateInputRasterComboBox();
    connect(m_inputRasterCombo, QOverload<int>::of(&QComboBox::currentIndexChanged), this, &ResampleDialog::onInputLayerOrMethodChanged);
    connect(m_resampleMethodCombo, QOverload<int>::of(&QComboBox::currentIndexChanged), this, &ResampleDialog::onInputLayerOrMethodChanged);

}

ResampleDialog::~ResampleDialog()
{
}

void ResampleDialog::setupUI()
{
    QVBoxLayout* mainLayout = new QVBoxLayout(this);
    QGridLayout* gridLayout = new QGridLayout();

    // 1. 输入栅格
    gridLayout->addWidget(new QLabel("输入栅格图层:", this), 0, 0);
    m_inputRasterCombo = new QComboBox(this);
    gridLayout->addWidget(m_inputRasterCombo, 0, 1);
    m_btnSelectInputRasterFile = new QPushButton("从文件...", this);
    gridLayout->addWidget(m_btnSelectInputRasterFile, 0, 2);
    m_lblSelectedRasterInfo = new QLabel("当前选择: 无", this);
    gridLayout->addWidget(m_lblSelectedRasterInfo, 1, 0, 1, 3);

    // 2. 重采样方法
    gridLayout->addWidget(new QLabel("重采样方法:", this), 2, 0);
    m_resampleMethodCombo = new QComboBox(this);
    m_resampleMethodCombo->addItem("最近邻 (Nearest Neighbour)", static_cast<int>(GRA_NearestNeighbour));
    m_resampleMethodCombo->addItem("双线性插值 (Bilinear)", static_cast<int>(GRA_Bilinear));
    m_resampleMethodCombo->addItem("立方卷积 (Cubic Convolution)", static_cast<int>(GRA_Cubic));
    // m_resampleMethodCombo->addItem("三次样条 (Cubic Spline)", static_cast<int>(GRA_CubicSpline));
    // m_resampleMethodCombo->addItem("Lanczos", static_cast<int>(GRA_Lanczos));
    gridLayout->addWidget(m_resampleMethodCombo, 2, 1, 1, 2);

    // 3. 输出像元大小 (可选)
    gridLayout->addWidget(new QLabel("输出像元大小 X:", this), 3, 0);
    m_spinOutputPixelSizeX = new QDoubleSpinBox(this);
    m_spinOutputPixelSizeX->setDecimals(6); // 允许更高精度
    m_spinOutputPixelSizeX->setMinimum(0);  // 0 表示使用源分辨率
    m_spinOutputPixelSizeX->setSuffix(" (地图单位)");
    m_spinOutputPixelSizeX->setSpecialValueText("使用源分辨率"); // 当值为0时显示
    gridLayout->addWidget(m_spinOutputPixelSizeX, 3, 1);

    gridLayout->addWidget(new QLabel("输出像元大小 Y:", this), 4, 0);
    m_spinOutputPixelSizeY = new QDoubleSpinBox(this);
    m_spinOutputPixelSizeY->setDecimals(6);
    m_spinOutputPixelSizeY->setMinimum(0);
    m_spinOutputPixelSizeY->setSuffix(" (地图单位)");
    m_spinOutputPixelSizeY->setSpecialValueText("使用源分辨率");
    gridLayout->addWidget(m_spinOutputPixelSizeY, 4, 1);

    m_lblPixelSizeHint = new QLabel("提示: X和Y都设为0或留空，则保持原始分辨率。", this);
    m_lblPixelSizeHint->setStyleSheet("font-style: italic; color: gray;");
    gridLayout->addWidget(m_lblPixelSizeHint, 5, 0, 1, 3);


    // 4. 输出栅格路径
    gridLayout->addWidget(new QLabel("输出栅格路径:", this), 6, 0);
    m_editOutputRasterPath = new QLineEdit(this);
    m_editOutputRasterPath->setPlaceholderText("选择输出文件路径...");
    gridLayout->addWidget(m_editOutputRasterPath, 6, 1);
    m_btnSelectOutputRaster = new QPushButton("浏览...", this);
    gridLayout->addWidget(m_btnSelectOutputRaster, 6, 2);

    mainLayout->addLayout(gridLayout);
    mainLayout->addStretch();

    // 5. 按钮
    QHBoxLayout* buttonLayout = new QHBoxLayout();
    buttonLayout->addStretch();
    m_btnOk = new QPushButton("确定", this);
    m_btnCancel = new QPushButton("取消", this);
    buttonLayout->addWidget(m_btnOk);
    buttonLayout->addWidget(m_btnCancel);
    mainLayout->addLayout(buttonLayout);

    setLayout(mainLayout);

    // 连接信号
    connect(m_inputRasterCombo, QOverload<int>::of(&QComboBox::currentIndexChanged), this, [this](int index) {
        QString unitSuffix = " (未知单位)";
        if (index > 0) {
            QVariant data = m_inputRasterCombo->itemData(index);
            QgsRasterLayer* layer = qvariant_cast<QgsRasterLayer*>(data);
            if (layer && QgsProject::instance()->mapLayer(layer->id())) {
                m_currentInputRasterPath = layer->source();
                m_lblSelectedRasterInfo->setText(QString("当前选择: %1 (项目)").arg(layer->name()));
                if (layer->crs().isGeographic()) {
                    unitSuffix = " (度)";
                }
                else {
                    unitSuffix = QString(" (%1)").arg(QgsUnitTypes::toString(layer->crs().mapUnits()));
                }
            }
        }
        else {
            if (m_currentInputRasterPath.isEmpty() || !m_lblSelectedRasterInfo->text().contains("(文件)")) {
                // ... (之前的逻辑)
            }
            else { // 如果是从文件选择的路径
                QgsRasterLayer tempLayer(m_currentInputRasterPath);
                if (tempLayer.isValid() && tempLayer.crs().isValid()) {
                    if (tempLayer.crs().isGeographic()) {
                        unitSuffix = " (度)";
                    }
                    else {
                        unitSuffix = QString(" (%1)").arg(QgsUnitTypes::toString(tempLayer.crs().mapUnits()));
                    }
                }
            }
        }
        m_spinOutputPixelSizeX->setSuffix(unitSuffix);
        m_spinOutputPixelSizeY->setSuffix(unitSuffix);
        updateDefaultOutputPath();
        });
    connect(m_btnSelectInputRasterFile, &QPushButton::clicked, this, &ResampleDialog::onSelectInputRasterClicked);
    connect(m_resampleMethodCombo, QOverload<int>::of(&QComboBox::currentIndexChanged), this, &ResampleDialog::onInputLayerOrMethodChanged);
    connect(m_btnSelectOutputRaster, &QPushButton::clicked, this, &ResampleDialog::onSelectOutputRasterClicked);
    connect(m_btnOk, &QPushButton::clicked, this, &ResampleDialog::onOkClicked);
    connect(m_btnCancel, &QPushButton::clicked, this, &QDialog::reject);
}

void ResampleDialog::populateInputRasterComboBox()
{
    m_inputRasterCombo->clear();
    m_inputRasterCombo->addItem("--- 从项目中选择栅格 ---", QVariant());
    QList<QgsMapLayer*> layers = QgsProject::instance()->mapLayers().values();
    for (QgsMapLayer* layer : layers) {
            if (auto rasterLayer = qobject_cast<QgsRasterLayer*>(layer)) {
                m_inputRasterCombo->addItem(rasterLayer->name(), QVariant::fromValue(rasterLayer));
            }
    }
}

void ResampleDialog::onSelectInputRasterClicked()
{
    QString filePath = QFileDialog::getOpenFileName(this, "选择输入栅格文件",
        QStandardPaths::writableLocation(QStandardPaths::HomeLocation),
        "栅格文件 (*.tif *.tiff *.img);;所有文件 (*.*)");
    if (!filePath.isEmpty()) {
        m_currentInputRasterPath = filePath;
        m_lblSelectedRasterInfo->setText(QString("当前选择: %1 (文件)").arg(QFileInfo(filePath).fileName()));
        m_inputRasterCombo->setCurrentIndex(0); // 清除下拉框选择
        updateDefaultOutputPath();
    }
}

void ResampleDialog::onInputLayerOrMethodChanged()
{
    updateDefaultOutputPath();
}

void ResampleDialog::updateDefaultOutputPath()
{
    if (m_currentInputRasterPath.isEmpty()) {
        m_editOutputRasterPath->clear();
        return;
    }

    QFileInfo fi(m_currentInputRasterPath);
    QString baseName = fi.completeBaseName();
    QString dirPath = fi.absolutePath();
    QString suffix = fi.suffix(); // 保留原始后缀

    QString methodSuffix;
    GDALResampleAlg alg = static_cast<GDALResampleAlg>(m_resampleMethodCombo->currentData().toInt());
    switch (alg) {
    case GRA_NearestNeighbour: methodSuffix = "nn"; break;
    case GRA_Bilinear:         methodSuffix = "bilinear"; break;
    case GRA_Cubic:            methodSuffix = "cubic"; break;
        // case GRA_CubicSpline:      methodSuffix = "cubicspline"; break;
        // case GRA_Lanczos:          methodSuffix = "lanczos"; break;
    default:                   methodSuffix = "res"; break;
    }

    QString defaultOutputName = QString("%1_resampled_%2.%3").arg(baseName).arg(methodSuffix).arg(suffix);
    m_editOutputRasterPath->setText(QDir(dirPath).filePath(defaultOutputName));
}


void ResampleDialog::onSelectOutputRasterClicked()
{
    QString defaultPath = m_editOutputRasterPath->text();
    if (defaultPath.isEmpty() && !m_currentInputRasterPath.isEmpty()) {
        // 尝试基于输入路径生成一个默认的保存路径
        QFileInfo fi(m_currentInputRasterPath);
        defaultPath = fi.absolutePath();
    }
    else if (defaultPath.isEmpty()) {
        defaultPath = QStandardPaths::writableLocation(QStandardPaths::HomeLocation);
    }

    QString filePath = QFileDialog::getSaveFileName(this, "选择输出栅格文件路径",
        defaultPath,
        "GeoTIFF (*.tif *.tiff);;Erdas Imagine (*.img);;所有文件 (*.*)");
    if (!filePath.isEmpty()) {
        // 确保有后缀
        if (QFileInfo(filePath).suffix().isEmpty()) {
            if (!filePath.endsWith(".")) filePath += ".";
            filePath += "tif"; // 默认tif
        }
        m_editOutputRasterPath->setText(filePath);
    }
}

// 公共接口实现
QString ResampleDialog::selectedInputRasterPath() const {
    return m_currentInputRasterPath;
}

Qgis::RasterResamplingMethod ResampleDialog::selectedResamplingMethod() const {
    // GDALResampleAlg 与 Qgis::RasterResamplingMethod 的值是对应的
    return static_cast<Qgis::RasterResamplingMethod>(m_resampleMethodCombo->currentData().toInt());
}

QString ResampleDialog::outputRasterPath() const {
    return m_editOutputRasterPath->text();
}

double ResampleDialog::outputPixelSizeX() const {
    double val = m_spinOutputPixelSizeX->value();
    return (val <= 0) ? -1.0 : val; // 0或负数表示使用源分辨率
}
double ResampleDialog::outputPixelSizeY() const {
    double val = m_spinOutputPixelSizeY->value();
    return (val <= 0) ? -1.0 : val;
}


// ResampleDialog.cpp

void ResampleDialog::onOkClicked()
{
    // --- 步骤 0: 获取所有输入参数 ---
    QString inputPath = selectedInputRasterPath();
    GDALResampleAlg resampleAlg = static_cast<GDALResampleAlg>(m_resampleMethodCombo->currentData().toInt());
    QString outputPath = outputRasterPath();
    double targetPixelSizeX = outputPixelSizeX(); // -1.0 或 0.0 表示使用源分辨率
    double targetPixelSizeY = outputPixelSizeY(); // -1.0 或 0.0 表示使用源分辨率

    // --- 参数检查 ---
    if (inputPath.isEmpty()) { QMessageBox::warning(this, "输入错误", "请选择输入栅格图层。"); return; }
    if (outputPath.isEmpty()) { QMessageBox::warning(this, "输入错误", "请输入输出栅格路径。"); return; }

    qDebug() << "\n====== 开始重采样操作 (直接WarpOperation) ======";
    qDebug() << "GDAL版本:" << GDALVersionInfo("RELEASE_NAME");
    qDebug() << "输入文件:" << inputPath;
    qDebug() << "输出文件:" << outputPath;
    qDebug() << "重采样算法 (int):" << static_cast<int>(resampleAlg);
    qDebug() << "目标像元大小 X:" << targetPixelSizeX << " Y:" << targetPixelSizeY;

    GDALAllRegister();

    // --- 步骤 1: 打开输入数据集 ---
    GDALDatasetH hSrcDS = GDALOpen(inputPath.toUtf8().constData(), GA_ReadOnly);
    if (!hSrcDS) {
        QMessageBox::critical(this, "GDAL错误", "无法打开输入栅格: " + inputPath + "\n" + CPLGetLastErrorMsg());
        return;
    }

    // --- 步骤 2: 获取输入参数，计算输出几何参数 ---
    const int srcWidth = GDALGetRasterXSize(hSrcDS);
    const int srcHeight = GDALGetRasterYSize(hSrcDS);
    const int bandCount = GDALGetRasterCount(hSrcDS);
    if (bandCount == 0) {
        QMessageBox::critical(this, "GDAL错误", "输入栅格不包含任何波段。");
        GDALClose(hSrcDS);
        return;
    }
    const GDALDataType dataType = GDALGetRasterDataType(GDALGetRasterBand(hSrcDS, 1));
    double adfSrcGeoTransform[6];
    if (GDALGetGeoTransform(hSrcDS, adfSrcGeoTransform) != CE_None) {
        QMessageBox::critical(this, "GDAL错误", "无法获取输入栅格的地理变换参数。");
        GDALClose(hSrcDS);
        return;
    }
    const char* pszSrcProjection = GDALGetProjectionRef(hSrcDS);

    int dstWidth = srcWidth;
    int dstHeight = srcHeight;
    double adfDstGeoTransform[6];
    memcpy(adfDstGeoTransform, adfSrcGeoTransform, sizeof(double) * 6); // 初始化目标地理变换

    // 用户指定了目标分辨率
    if (targetPixelSizeX > 0 && targetPixelSizeY > 0) {
        double dfSrcXMin = adfSrcGeoTransform[0];
        double dfSrcYMax = adfSrcGeoTransform[3];
        double dfSrcXMax = dfSrcXMin + adfSrcGeoTransform[1] * srcWidth;
        double dfSrcYMin = dfSrcYMax + adfSrcGeoTransform[5] * srcHeight;

        qDebug() << "  源X范围:" << dfSrcXMin << "to" << dfSrcXMax << "(宽度:" << (dfSrcXMax - dfSrcXMin) << ")";
        qDebug() << "  源Y范围:" << dfSrcYMin << "to" << dfSrcYMax << "(高度:" << (dfSrcYMax - dfSrcYMin) << ")";
        qDebug() << "  目标像元X:" << targetPixelSizeX << "目标像元Y:" << targetPixelSizeY;

        // 确保除数不为0，并且是有意义的正值
        if (targetPixelSizeX <= 0 || targetPixelSizeY <= 0) {
            QMessageBox::critical(this, "参数错误", "目标像元大小必须为正数。");
            GDALClose(hSrcDS);
            return;
        }

        double extentWidth = std::abs(dfSrcXMax - dfSrcXMin);
        double extentHeight = std::abs(dfSrcYMax - dfSrcYMin);

        // 如果源数据的地理范围本身非常小（例如，接近0），则不应进行基于分辨率的尺寸计算
        if (extentWidth < 1e-9 || extentHeight < 1e-9) { // 1e-9 是一个很小的阈值
            qWarning() << "源数据地理范围过小，无法根据目标分辨率计算尺寸。将使用源尺寸。";
            // 保持 dstWidth = srcWidth, dstHeight = srcHeight
        }
        else {
            dstWidth = static_cast<int>(extentWidth / targetPixelSizeX + 0.5);
            dstHeight = static_cast<int>(extentHeight / std::abs(targetPixelSizeY) + 0.5); // Y像元大小通常用绝对值
        }

        // 保持原始栅格左上角坐标和像元大小符号
        adfDstGeoTransform[0] = adfSrcGeoTransform[0];
        adfDstGeoTransform[1] = targetPixelSizeX;
        adfDstGeoTransform[2] = adfSrcGeoTransform[2]; // 保留旋转参数
        adfDstGeoTransform[3] = adfSrcGeoTransform[3];
        adfDstGeoTransform[4] = adfSrcGeoTransform[4]; // 保留旋转参数
        adfDstGeoTransform[5] = (adfSrcGeoTransform[5] < 0) ? -std::abs(targetPixelSizeY) : std::abs(targetPixelSizeY);
    }

    qDebug() << "计算出的目标尺寸:" << dstWidth << "x" << dstHeight;
    if (dstWidth <= 0 || dstHeight <= 0) {
        QMessageBox::critical(this, "参数错误",
            QString("计算出的目标栅格尺寸为 %1x%2，这是一个无效尺寸。\n\n"
                "这通常意味着您设定的“目标像元大小”相对于源栅格的地理范围过大。\n\n"
                "源栅格宽度（地理单位）: %3\n"
                "源栅格高度（地理单位）: %4\n"
                "您设定的目标像元大小 X: %5, Y: %6 (单位与源栅格一致)")
            .arg(dstWidth).arg(dstHeight)
            .arg(std::abs(adfSrcGeoTransform[1] * srcWidth)) // 源地理宽度
            .arg(std::abs(adfSrcGeoTransform[5] * srcHeight)) // 源地理高度
            .arg(targetPixelSizeX).arg(targetPixelSizeY)
        );
        GDALClose(hSrcDS);
        return;
    }

    // --- 步骤 3: 创建输出数据集 ---
    GDALDriverH hDriver = GDALGetDriverByName("GTiff");
    if (!hDriver) {
        QMessageBox::critical(this, "GDAL错误", "无法获取GTiff驱动。");
        GDALClose(hSrcDS);
        return;
    }
    char** papszCreateOptions = nullptr;
    papszCreateOptions = CSLSetNameValue(papszCreateOptions, "TILED", "YES");
    papszCreateOptions = CSLSetNameValue(papszCreateOptions, "COMPRESS", "LZW");

    GDALDatasetH hDstDS = GDALCreate(hDriver, outputPath.toUtf8().constData(),
        dstWidth, dstHeight, bandCount, dataType, papszCreateOptions);
    CSLDestroy(papszCreateOptions);

    if (!hDstDS) {
        QMessageBox::critical(this, "GDAL错误", "无法创建输出文件: " + outputPath + "\n" + CPLGetLastErrorMsg());
        GDALClose(hSrcDS);
        return;
    }

    // 设置输出数据集的地理转换和投影
    GDALSetGeoTransform(hDstDS, adfDstGeoTransform);
    if (pszSrcProjection != nullptr && strlen(pszSrcProjection) > 0) {
        GDALSetProjection(hDstDS, pszSrcProjection);
    }
    qDebug() << "输出数据集已创建。";

    // --- 步骤 4: 配置并执行 GDALWarpOperation ---
    GDALWarpOptions* psWarpOptions = GDALCreateWarpOptions();
    psWarpOptions->eResampleAlg = resampleAlg;

    // 关键：将源和已创建的目标数据集都提供给WarpOptions
    psWarpOptions->hSrcDS = hSrcDS;
    psWarpOptions->hDstDS = hDstDS;

    psWarpOptions->nBandCount = bandCount;
    psWarpOptions->panSrcBands = (int*)CPLMalloc(sizeof(int) * bandCount);
    psWarpOptions->panDstBands = (int*)CPLMalloc(sizeof(int) * bandCount);
    for (int i = 0; i < bandCount; i++) {
        psWarpOptions->panSrcBands[i] = i + 1;
        psWarpOptions->panDstBands[i] = i + 1;
    }

    // 创建转换器，此时源和目标数据集的投影和地理变换都已确定
    // 如果源和目标投影不同，GDALCreateGenImgProjTransformer2会处理重投影
    // 如果相同，它主要处理地理变换之间的映射
    psWarpOptions->pTransformerArg = GDALCreateGenImgProjTransformer2(hSrcDS, hDstDS, nullptr); // 第三个参数可传NULL或创建选项
    psWarpOptions->pfnTransformer = GDALGenImgProjTransform;

    if (!psWarpOptions->pTransformerArg) {
        QMessageBox::critical(this, "GDAL错误", "创建坐标转换器失败:\n" + QString(CPLGetLastErrorMsg()));
        CPLFree(psWarpOptions->panSrcBands); CPLFree(psWarpOptions->panDstBands);
        GDALDestroyWarpOptions(psWarpOptions);
        GDALClose(hDstDS); GDALClose(hSrcDS);
        return;
    }
    qDebug() << "WarpOptions配置完毕，转换器已创建。";

    GDALWarpOperation oWarper;
    CPLErr eErr = oWarper.Initialize(psWarpOptions);

    if (eErr == CE_None) {
        qDebug() << "WarpOperation初始化成功，开始ChunkAndWarpImage...";
        // 目标尺寸从hDstDS获取
        eErr = oWarper.ChunkAndWarpImage(0, 0, GDALGetRasterXSize(hDstDS), GDALGetRasterYSize(hDstDS));
        if (eErr != CE_None) {
            QMessageBox::critical(this, "重采样失败", "GDAL ChunkAndWarpImage 操作失败: " + QString(CPLGetLastErrorMsg()));
        }
    }
    else {
        QMessageBox::critical(this, "GDAL错误", "初始化Warp操作失败: " + QString(CPLGetLastErrorMsg()));
    }

    // --- 步骤 5: 清理资源 ---
    if (psWarpOptions != nullptr) {
        if (psWarpOptions->pTransformerArg != nullptr) {
            GDALDestroyTransformer(psWarpOptions->pTransformerArg);
            psWarpOptions->pTransformerArg = nullptr;
        }
        CPLFree(psWarpOptions->panSrcBands); psWarpOptions->panSrcBands = nullptr;
        CPLFree(psWarpOptions->panDstBands); psWarpOptions->panDstBands = nullptr;
        // papszWarpOptions 在这个版本中未使用，所以不需要CSLDestroy
        GDALDestroyWarpOptions(psWarpOptions); psWarpOptions = nullptr;
    }

    if (hDstDS != nullptr) {
        GDALClose(hDstDS); // 确保先关闭目标数据集，数据才会完全写入
        hDstDS = nullptr;
    }
    if (hSrcDS != nullptr) {
        GDALClose(hSrcDS);
        hSrcDS = nullptr;
    }

    // --- 步骤 6: 结果反馈 ---
    if (eErr == CE_None) {
        QMessageBox::information(this, "成功", "栅格重采样完成！\n输出文件: " + outputPath);
        accept();
    }
}
正在处理文件: AnalysisToolboxWidget.h
(AnalysisToolboxWidget.h)
// AnalysisToolboxWidget.h
#ifndef ANALYSISTOOLBOXWIDGET_H
#define ANALYSISTOOLBOXWIDGET_H

#include <QWidget>
#include <QStandardItemModel> // 我们用QStandardItemModel来构建树

// 前向声明
class QTreeView;
class QStandardItem;
class QModelIndex;

// 定义一个枚举或常量来唯一标识每个工具
enum class AnalysisToolId {
    SpatialJoin,
    Buffer,
    RasterStats,
    RasterClip,
    RasterResample,
    RasterReproject,
    ZonalStats
    // ... 可以继续添加
};
// 将工具ID存储在QStandardItem的UserRole中
const int ToolIdRole = Qt::UserRole + 1;


class AnalysisToolboxWidget : public QWidget
{
    Q_OBJECT

public:
    explicit AnalysisToolboxWidget(QWidget* parent = nullptr);
    ~AnalysisToolboxWidget();

private slots:
    // 当用户双击树中的项时调用
    void onItemDoubleClicked(const QModelIndex& index);

private:
    void setupUI();
    void populateToolTree(); // 填充工具树的内容

    QTreeView* m_toolTreeView;
    QStandardItemModel* m_toolModel;
};

#endif // ANALYSISTOOLBOXWIDGET_H
正在处理文件: AttributeTableDialog.h
(AttributeTableDialog.h)
#include <QDialog>
#include <QItemSelectionModel> // +++ 新增，用于获取选中行

// 前向声明
class QgsVectorLayer;
class QgsMapCanvas;
class QTableView;
class QgsAttributeTableModel;
class QgsAttributeTableFilterModel;
class QComboBox;
class QRadioButton;
class QPushButton;
class QLineEdit;

class AttributeTableDialog : public QDialog
{
    Q_OBJECT

public:
    explicit AttributeTableDialog(QgsVectorLayer* layer, QgsMapCanvas* canvas, QWidget* parent = nullptr);
    ~AttributeTableDialog();

private slots:
    // +++ 新增的槽函数 +++
    void onFieldSelectionChanged(int index);
    void onSortOrderToggle();
    void onSearchButtonClicked();
    void onFilterModeChanged(); // 响应排序/搜索模式的切换

    // +++ 新增槽函数 +++
    void onDeleteSelectedFeatures();

    void synchronizeTableSelectionWithLayer();

    void onInvertSelection();

private:
    void setupUI();
    void populateFieldsComboBox();
    void updateControlsState(); // 一个用于更新控件启用/禁用状态的辅助函数

    // UI 控件
    QTableView* m_tableView;
    QComboBox* m_fieldComboBox;
    QRadioButton* m_sortRadioButton;
    QRadioButton* m_searchRadioButton;
    QPushButton* m_sortOrderButton;
    QLineEdit* m_searchLineEdit;
    QPushButton* m_searchButton;
    QPushButton* m_deleteButton; // +++ 新增删除按钮 +++
    QPushButton* m_invertSelectionButton; // +++ 新增反选按钮 +++

    // 数据模型
    QgsVectorLayer* m_layer;
    QgsMapCanvas* m_canvas;
    QgsAttributeTableModel* m_tableModel;
    QgsAttributeTableFilterModel* m_filterModel;

    // 状态变量
    Qt::SortOrder m_currentSortOrder;

    // +++ 新增状态变量，用于控制删除提示只显示一次 +++
    bool m_deleteWarningShown;
};
正在处理文件: CustomLayerTreeView.h
(CustomLayerTreeView.h)
#include <QWidget>
#include <QPoint>

// 前向声明
class QTreeView;
class QStandardItemModel;
class QStandardItem;
class QgsMapLayer;
class QgsMapCanvas;
class QModelIndex;
class QItemSelection;

class CustomLayerTreeView : public QWidget
{
    Q_OBJECT

public:
    explicit CustomLayerTreeView(QgsMapCanvas* canvas, QWidget* parent = nullptr);
    ~CustomLayerTreeView();
    void updateMapCanvasLayers();

signals:
    void modelChanged(); // 新增信号
    // +++ 新增信号，当选中项改变时发出 +++
    void currentLayerChanged(QgsMapLayer* layer);

public slots:
    void addLayer(QgsMapLayer* layer);
    void clear();

    // +++ 新增槽函数，响应QTreeView自身的选中事件 +++
    void onSelectionChanged(const QItemSelection& selected, const QItemSelection& deselected);

private slots:
    void onItemChanged(QStandardItem* item);
    void onCustomContextMenuRequested(const QPoint& pos);
    void onChangeLayerColor(QgsMapLayer* layer);

    // -- !! 新增的私有槽函数，用于处理排序 !! --
    void onMoveLayerUp(const QModelIndex& index);
    void onMoveLayerDown(const QModelIndex& index);

    // 置于顶层/底层
    void onMoveToTop(const QModelIndex& index);
    void onMoveToBottom(const QModelIndex& index);


private:
    void updateLayerItemIcon(QStandardItem* item, const QColor& color);
    void onRemoveLayer(const QModelIndex& index);

private:
    QTreeView* m_treeView;
    QStandardItemModel* m_model;
    QgsMapCanvas* m_mapCanvas;
};


正在处理文件: FeatureSelectionTool.h
(FeatureSelectionTool.h)
#include <qgsmaptoolidentify.h> // 使用这个基类，它为识别要素提供了便利
#include <qgsmapcanvas.h> // 确保包含QgsMapCanvas相关定义
#include <qgsmapmouseevent.h> // 确保包含QgsMapCanvasMouseEvent相关定义

class QgsMapCanvas;
class QgsVectorLayer;
class QgsFeature;

class FeatureSelectionTool : public QgsMapToolIdentify
{
    Q_OBJECT

public:
    explicit FeatureSelectionTool(QgsMapCanvas* canvas);

    // 重写父类的鼠标事件处理函数
    void canvasMoveEvent(QgsMapMouseEvent* e) override; // 主要逻辑在这里
    void canvasReleaseEvent(QgsMapMouseEvent* e) override;

    // 当工具被激活或停用时调用
    void activate() override;
    void deactivate() override;

private:
    void clearCurrentSelection();

    // 记录当前高亮的要素，避免重复操作
    QgsVectorLayer* m_lastSelectedLayer = nullptr;
    QgsFeatureId m_lastSelectedFeatureId;
};

正在处理文件: FileLogger.h
(FileLogger.h)
#pragma once
#include <QObject>
#include <QFile>
#include <QTextStream>

class FileLogger : public QObject
{
    Q_OBJECT

public:
    // 构造函数接收日志文件的完整路径
    explicit FileLogger(const QString& logFilePath, QObject* parent = nullptr);
    ~FileLogger();

public slots:
    // 这个槽将连接到 OutputManager::messageLogged 信号
    void onMessageLogged(const QString& message, const QString& type);

private:
    QFile m_logFile;
    QTextStream m_logStream;
};
正在处理文件: MapCanvas.h
(MapCanvas.h)
#include <QWidget>

class QgsMapCanvas;
class QgsMapLayer;
class QgsMapToolPan;
class FeatureSelectionTool; // <-- 新增
class QToolBar;             // <-- 新增
class QActionGroup;         // <-- 新增

class MapCanvas : public QWidget
{
    Q_OBJECT // << 必须添加，因为我们使用了信号和槽

public:
    MapCanvas(QWidget* parent = nullptr);
    ~MapCanvas();

    QgsMapCanvas* getCanvas() const;
    QgsMapToolPan* getPanTool() const; // 获取平移工具
    void zoomToLayer(QgsMapLayer* layer);

public slots:
    // --- 新增的公共槽函数 ---
    void zoomIn();  // 放大
    void zoomOut(); // 缩小

signals:
    // 当比例尺变化时，发出此信号，携带格式化好的字符串
    void scaleChanged(const QString& scaleText);

private slots:
    // --- 新增的私有槽函数 ---
    // 用于接收来自 QgsMapCanvas 内部的 scaleChanged 信号
    void onCanvasScaleChanged(double newScale);

private:
    QgsMapCanvas* m_qgsCanvas;
    QgsMapToolPan* m_panTool;
};

正在处理文件: OutputWidget.h
(OutputWidget.h)
#pragma once
#include <QWidget>

// 前向声明
class QTextEdit;

class OutputWidget : public QWidget
{
	Q_OBJECT

public:
	OutputWidget(QWidget* parent = nullptr);
	~OutputWidget();

	void displayMessage(const QString& message,const QString& type);

private:
	QTextEdit* m_outputConsole;
};
正在处理文件: Output_Manager.h
(Output_Manager.h)
#pragma once
#include <QObject>

class OutputManager : public QObject 
{
	Q_OBJECT

private:
	// 私有构造函数，防止外部创建实例
	explicit OutputManager(QObject* parent = nullptr);

	// 静态私有成员，拥有唯一实例
	static OutputManager* m_instance;

public:
	// 公共静态方法，用于记录并发送内容
	static OutputManager* instance();

public slots:
	// 公共槽函数，用于记录发送内容
	void logMessage(const QString& message);
	void logWarning(const QString& message);
	void logError(const QString& message);

signals:
	// 信号，当有新消息时发送
	void messageLogged(const QString& message, const QString& type = "INFO"); // 信号类型，可以是INFO，WARNING，ERROR

};
正在处理文件: QGIS_dev.h
(QGIS_dev.h)
#include <QMainWindow>
#include <QMenu>
#include <QAction>
#include <QDockWidget>
#include <QToolBar>


class MapCanvas;
class CustomLayerTreeView;
class OutputWidget;
class QgsMapTool;
class FeatureSelectionTool; // 我们自定义的选择工具
class QActionGroup;       // 用于确保工具按钮的互斥性
class QLabel;
class QgsPointXY;
class QgsMapLayer;
class QgsCoordinateReferenceSystem;
class QPushButton;

class QGIS_dev : public QMainWindow
{
    Q_OBJECT

public:
    QGIS_dev(QWidget *parent = nullptr);
    ~QGIS_dev();

protected:
    // 添加关闭事件处理，用于检查未保存的更改
    void closeEvent(QCloseEvent* event) override;

private slots:
    // 文件操作
    void onNewProject();
    void onOpenProject();
    bool onSaveProject();
    bool onSaveProjectAs();

    // 查看操作
    void onOpenLogFolder();

    // 内部槽函数，用于标记项目为已修改
    void onProjectDirty();

    // -- 将要实现的槽函数 --
    void onAddVectorLayer();
    void onAddRasterLayer();

    // --- 地图工具激活槽函数 ---
    void onActivatePanTool();
    void onActivateSelectTool();

    // +++ 新增的槽函数，用于更新状态栏 +++
    void updateCoordinates(const QgsPointXY& point);
    void updateScale(double scale);

    // 选择图层发生变化时接收信号
    void onCurrentLayerChanged(QgsMapLayer* layer);

    // +++ 新增槽函数 +++
    void updateProjectCrs(); // 用于更新状态栏的CRS显示

    // +++ 新增槽函数，用于响应CRS按钮的点击 +++
    void onChangeProjectCrs();

    // +++ 新增槽函数 +++
    void onAddDelimitedTextLayer();

private:
    // 初始化函数
    void setupUI();
    void setupActions();
    void setupToolBar();

    // 构件工程的辅助函数
    void updateWindowTitle();
    void rebuildLayerTreeFromProject(); // 从QgsProject重建图层树
    bool maybeSave(); // 检查是否需要保存，并执行保存逻辑
    bool copyLayerDataToProject(const QString& sourceFilePath, QString& newRelativePath); // 复制数据文件
    bool copyShapefile(const QString& sourceShpPath, const QString& destDir, QString& newFileName); // 专门处理Shapefile

    // UI 组件
    MapCanvas* m_mapCanvas;
    CustomLayerTreeView* m_customLayerTreeView;
    OutputWidget* m_outputWidget;

    // ... Dock 窗口 ...
    QDockWidget* m_layerTreeDock;
    QDockWidget* m_outputDock; // 我们保留输出Dock

    // +++ 新增空间分析工具的Dock和占位符Widget +++
    QDockWidget* m_analysisDock;
    QWidget* m_analysisToolsWidget;


    // 菜单和菜单动作
    QMenu* m_fileMenu;
    QAction* m_addVectorAction;
    QAction* m_addRasterAction;
    // +++ 新增菜单动作 +++
    QAction* m_addDelimitedTextLayerAction;
    QAction* m_newAction;
    QAction* m_openAction;
    QAction* m_saveAction;
    QAction* m_saveAsAction;

    QMenu* m_checkMenu;
    QAction* m_checkLogsAction;

    // --- 工具栏和工具动作 ---
    QToolBar* m_toolBar;
    QAction* m_zoomInAction;
    QAction* m_zoomOutAction;
    QAction* m_panAction;           // 平移动作
    QAction* m_selectAction;        // 选择要素动作
    QActionGroup* m_toolActionGroup; // 工具动作组

    // --- 地图工具实例 ---
    FeatureSelectionTool* m_selectionTool;

    // --- 项目状态 ---
    QString m_projectFilePath;
    bool m_isProjectDirty;

    // +++ 新增的成员变量，用于状态栏显示 +++
    QLabel* m_coordsLabel;
    QLabel* m_scaleLabel;

    // +++ 将 m_crsLabel 的类型从 QLabel* 修改为 QPushButton* +++
    bool resolveLayerCrs(QgsMapLayer* layer);
    QPushButton* m_crsButton;
    QgsMapLayer* m_currentLayer;
};

正在处理文件: RasterLayerPropertiesDialog.h
(RasterLayerPropertiesDialog.h)
#include <QDialog>

// 前向声明
class QgsRasterLayer;
class QLabel;
class QTableWidget; // 我们仍然用表格来美观地显示信息
class QTextEdit;    // 用于显示多波段统计

class RasterLayerPropertiesDialog : public QDialog
{
    Q_OBJECT

public:
    explicit RasterLayerPropertiesDialog(QgsRasterLayer* layer, QWidget* parent = nullptr);
    ~RasterLayerPropertiesDialog();

private:
    void setupUI();
    void populateGeneralInfo();
    void populateAllBandStatistics(); // 新函数：填充所有波段的统计

    QgsRasterLayer* m_rasterLayer;

    // UI - 基本信息区
    QTableWidget* m_infoTableWidget;

    // UI - 多波段统计区
    QLabel* m_lblBandStatsTitle;
    QTextEdit* m_allBandStatsTextEdit; // 用一个简单的文本框显示所有波段统计
};

正在处理文件: ReprojectRasterDialog.h
(ReprojectRasterDialog.h)
// ReprojectRasterDialog.h
#ifndef REPROJECTRASTERDIALOG_H
#define REPROJECTRASTERDIALOG_H

#include <QDialog>
#include <qgscoordinatereferencesystem.h> // 包含QgsCoordinateReferenceSystem

// 前向声明
class QComboBox;
class QPushButton;
class QLineEdit;
class QLabel;
class QgsRasterLayer;

class ReprojectRasterDialog : public QDialog
{
    Q_OBJECT

public:
    explicit ReprojectRasterDialog(QWidget* parent = nullptr);
    ~ReprojectRasterDialog();

private slots:
    void onSelectInputRasterClicked();
    void onSelectOutputRasterClicked();
    void onInputRasterChanged(int index);
    void onTargetCrsComboChanged(int index); // 当目标CRS下拉框改变时
    void onOkClicked();

private:
    void setupUI();
    void populateInputRasterComboBox();
    void populateTargetCrsComboBox(); // 新函数：填充目标CRS下拉框
    void updateDefaultOutputPath();

    // UI 控件
    QComboBox* m_inputRasterCombo;
    QPushButton* m_btnSelectInputRasterFile;
    QLabel* m_lblSelectedRasterInfo;
    QLabel* m_lblCurrentCrsInfo;

    // === 修改：使用QComboBox替代QgsProjectionSelectionWidget ===
    QLabel* m_lblTargetCrs;
    QComboBox* m_targetCrsCombo;
    // =======================================================

    QLineEdit* m_editOutputRasterPath;
    QPushButton* m_btnSelectOutputRaster;

    QPushButton* m_btnOk;
    QPushButton* m_btnCancel;

    // 数据
    QString m_currentInputRasterPath;
    QgsCoordinateReferenceSystem m_currentTargetCrs; // 存储当前选中的目标CRS
};

#endif // REPROJECTRASTERDIALOG_H
正在处理文件: ResampleDialog.h
(ResampleDialog.h)
#include <QDialog>
#include <qgis.h> // For Qgis::ResamplingMethod

// 前向声明
class QComboBox;
class QPushButton;
class QLineEdit;
class QLabel;
class QgsRasterLayer;
class QDoubleSpinBox;

class ResampleDialog : public QDialog
{
    Q_OBJECT

public:
    explicit ResampleDialog(QWidget* parent = nullptr);
    ~ResampleDialog();

    // 公共接口获取参数
    QString selectedInputRasterPath() const; // 返回输入栅格的路径
    Qgis::RasterResamplingMethod selectedResamplingMethod() const;
    QString outputRasterPath() const;
    double outputPixelSizeX() const; // -1 表示使用源分辨率
    double outputPixelSizeY() const; // -1 表示使用源分辨率

private slots:
    void onSelectInputRasterClicked();
    void onSelectOutputRasterClicked();
    void onInputLayerOrMethodChanged(); // 当输入图层或方法改变时，更新默认输出名
    void onOkClicked();

private:
    void setupUI();
    void populateInputRasterComboBox();
    void updateDefaultOutputPath();

    // UI 控件
    QComboBox* m_inputRasterCombo;
    QPushButton* m_btnSelectInputRasterFile;
    QLabel* m_lblSelectedRasterInfo;

    QComboBox* m_resampleMethodCombo;

    QLabel* m_lblOutputPixelSizeX;
    QDoubleSpinBox* m_spinOutputPixelSizeX;
    QLabel* m_lblOutputPixelSizeY;
    QDoubleSpinBox* m_spinOutputPixelSizeY;
    QLabel* m_lblPixelSizeHint; // 提示用户留空则使用源分辨率


    QLineEdit* m_editOutputRasterPath;
    QPushButton* m_btnSelectOutputRaster;

    QPushButton* m_btnOk;
    QPushButton* m_btnCancel;

    // 数据
    QString m_currentInputRasterPath; // 存储当前选择的输入栅格路径
};

